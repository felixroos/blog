## scale graph 

<center>
  <PathGraph
    paths={[
      { path: ['D dorian', 'G mixolydian', 'C major'] },
      { path: ['D dorian', 'G mixolydian', 'C lydian'] },
      { path: ['D aeolian', 'G mixolydian', 'C major'] },
      { path: ['D aeolian', 'G mixolydian', 'C lydian'] },
      { path: ['D phrygian', 'G mixolydian', 'C major'] },
      { path: ['D phrygian', 'G mixolydian', 'C lydian'] },
    ].map(decoratePathValues((a, b) => scaleDifference(a, b) / 2))}
    getColor={(scale) => scaleColor(scale)}
    includeStartNode={false}
    showCalculation={false}
    showDuplicates={false}
  />
</center>

## scale tree

<center>
  <PathTree
    containerStyle={{}}
    paths={[
      { path: ['D dorian', 'G mixolydian', 'C major'] },
      { path: ['D dorian', 'G mixolydian', 'C lydian'] },
      { path: ['D aeolian', 'G mixolydian', 'C major'] },
      { path: ['D aeolian', 'G mixolydian', 'C lydian'] },
      { path: ['D phrygian', 'G mixolydian', 'C major'] },
      { path: ['D phrygian', 'G mixolydian', 'C lydian'] },
    ].map(decoratePathValues((a, b) => scaleDifference(a, b) / 2))}
    getColor={(scale) => scaleColor(scale)}
  />
</center>

## What's in a Path?

We can describe a path like this:

```ts
declare type Path = {
  value: number;
  path: string[];
};
```

In the above example, our winning path is:

```json
{
  "value": 0,
  "path": ["D dorian", "G mixolydian", "C major", "D dorian", "G mixolydian", "C major"]
}
```

### Value Function

Also, we need a function that calculates the difference / cost between two graph nodes:

```ts
declare type ValueFn = (source: string, target: string, path: Path) => number;
```

## Generating Choice Trees

Turning

## Finding the Best Path

To get this path, what we want is this:

```js
// scale graph as 2D array:
const graph = [['D aeolian', 'D dorian'], ['G mixolydian'], ['C major', 'C lydian']];
// function that tells the "distance" between two scales:
const getValue = (source, target) => {
  return chromaDifference(scaleChroma(source), scaleChroma(target));
};
expect(findBestPath(graph, getValue)).toEqual(['D dorian', 'G mixolydian', 'C major']);
```

By pulling out `getValue`, we can reuse the function for similar uses later (like finding the absolute best voice leading for a whole tune).

### Basic Algorithm

The basic algorithm looks like this:

```js
import { minIndex } from 'd3-array';

export default function findBestPath(graph: string[][], getValue: ValueFn): string[] {
  // initialize variables:
  let paths: Path[] = [];
  let isFinished = false;
  while (!isFinished) {
    // run this magic function
    const extended = extendBestPath(paths, graph, getValue);
    if (!extended) {
      // if the result is false, we are finished
      isFinished = true;
    } else {
      // replace paths with extended edition
      paths = extended;
    }
  }
  // when we are finished, find the path with the lowest value
  const best = paths[minIndex(paths, (path) => path.value)];
  // and return just the actual path array
  return best.path;
}
```

I guess that does not look that complicated. But of course, this is just a skeleton, with the real meat hiding in the extendBestPath function.


### Extending the Best Path

To really understand what the function does, let's look at the 251 again, step by step:

#### Step 0

export const graph = [['D aeolian', 'D dorian'], ['G mixolydian'], ['C major', 'C lydian']];
export const getValue = (source, target) => {
  return chromaDifference(scaleChroma(source), scaleChroma(target));
};
export let path = [];

Before we do anything, we start with:

```js
const graph = [['D aeolian', 'D dorian'], ['G mixolydian'], ['C major', 'C lydian']];
const getValue = (source, target) => {
  return chromaDifference(scaleChroma(source), scaleChroma(target));
};
let paths = [];
```

#### Step 1

export const step1 = extendBestPath([], graph, getValue);

As a first step, we start with 2 paths leading to the 2 scale choices for the first chord:

<center>
  <PathTree paths={step1} getColor={(scale) => scaleColor(scale)} />
</center>

So we can formulate our first expectation:

```js
const step1 = [
  {
    path: ['D aeolian'],
    value: 0,
  },
  {
    path: ['D dorian'],
    value: 0,
  },
];
paths = extendBestPath(paths, graph, getValue);
expect(paths).toEqual(step1);
```

This is a special case, as the paths are initially populated. In the graphic, the "start" node is just a dummy, to be able to show the start values.

#### Step 2

export const step2 = extendBestPath(step1, graph, getValue);

In the second step, we extend the (first found) best path:

<!--<PathGraph height={300} paths={step2} getColor={(scale) => scaleColor(scale)} />-->

<center>
  <PathTree paths={step2} getColor={(scale) => scaleColor(scale)} />
</center>

```js
const step2 = extendBestPath(step1, graph, getValue);
expect(step2).toEqual([
  {
    path: ['D aeolian', 'G mixolydian'],
    value: 2,
    values: [0, 2],
  },
  step1[1], // index 1 does not change so we spare some writing
]);
```

#### Step 3

export const step3 = extendBestPath(step2, graph, getValue);

Next, the second root branch seems more tempting, as it is still zero:

<!--<PathGraph height={300} paths={step3} getColor={(scale) => scaleColor(scale)} />-->

<center>
  <PathTree paths={step3} getColor={(scale) => scaleColor(scale)} />
</center>

```js
const step3 = extendBestPath(step2, graph, getValue);
expect(step3).toEqual([
  step2[0],
  {
    path: ['D dorian', 'G mixolydian'],
    value: 0,
    values: [0, 0],
  },
]);
```

#### Step 4

export const step4 = extendBestPath(step3, graph, getValue);

Now, we continue extending the right branch, as it is still zero (compared to 2):

<!-- TODO: add PathView with tree + graph + json modes and maybe a minimap -->

<center>
  <PathTree paths={step4} getColor={(scale) => scaleColor(scale)} />
</center>

```js
const step4 = extendBestPath(step3, graph, getValue);
expect(step4).toEqual([
  step2[0],
  {
    path: ['D dorian', 'G mixolydian', 'C major'],
    value: 0,
    values: [0, 0, 0],
  },
  {
    path: ['D dorian', 'G mixolydian', 'C lydian'],
    value: 2,
    values: [0, 0, 2],
  },
]);
```

Now, we're pretty much done.

#### Step 5

export const step5 = extendBestPath(step4, graph, getValue);

Now that the minimal path is done, we do not need to check the rest, as they will be longer anyway, as long as we do not allow negative values.
To satisfy our algorithm, we now expect the function to return false:

```js
const step5 = extendBestPath(step4, graph, getValue);
expect(step5).toBe(false);
```

#### The actual function

After that in depth example, the algorithm might be digestible:

```js
import { minIndex } from 'd3-array';

export default function extendBestPath(paths: Path[], graph: string[][], getValue: ValueFn): Path[] | false {
  if (!paths.length) {
    // if no paths are given, return initial paths, see step 1
    return graph[0].map((candidate) => ({ value: 0, path: [candidate] }));
  }
  // find index with lowest value
  const bestIndex = minIndex(paths, (path) => path.value);
  const best = paths[bestIndex];
  const { path, value } = best;
  if (path.length >= graph.length) {
    // we are done: see step 5
    return false;
  }
  // generate next possible steps by splitting up the best path for all possible next candidates
  // see steps 2 - 4
  const nextSteps: Path[] = graph[path.length].map((candidate) => {
    const nextValue = getValue(path[path.length - 1], candidate, best);
    return {
      value: value + nextValue,
      path: path.concat(candidate),
    };
  });
  // replace best path with nextSteps
  return [...paths.slice(0, bestIndex), ...nextSteps, ...paths.slice(bestIndex + 1)];
}
```

That's the basic trick! But we might run into some unforseen problems when throwing more complex graphs in..

## Branch Pruning

Like a diligent gardener, we might need some branch pruning to get better results..
To illustrate the problem, let's the chord progression `TODO`

export const pentatonicScales = Scale.names().filter((scale) => Scale.get(`C ${scale}`).notes.length === 5);
