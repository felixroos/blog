
### Keyboard design

Just imagine we want to design a keyboard layout for the piano, without knowing anything about its current design.

Those are the design requirements:

1. There are 12 different notes
2. The 12 keys repeat to up to 88 keys to fill the human hearing range
3. Our eyes & fingers should be able to find key locations quickly

Design insight #1:

> If we would make all the keys look the same, we would have no clue which is which.

_What if we label the keys with letters ABCDEFGHIJKL?_

This would, to some extent, work for our eyes, but our fingers alone would be clueless

Design insight #2:

> We need at least two different types of keys, to give haptic information

So we can comprehend the decision to use white and black keys

- they have different colors (eyes)
- and different positions/forms (fingers)

Having two types of keys, we have to decide how many of each we will use:

_What about 6 white and 6 black keys?_

Schematically, this would look something like this:

> X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X

or this

> XX--XX--XX--

or this

> XXX---XXX---

or this

> XXXXXX------

or this

> XXXX--XX----

...or any other permutation of 6 inside 12.

("X" is one type of key, and "-" the other type)

If we think through the above proposals, none of them, except maybe the last one meet our requirements.

Design insight #3:

> Regular patterns create ambiguity

This means, that for example in the first proposal, there are no quickly recognizable properties of a certain key:

```txt
X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-
          ^ this is the 6th X key from the left
```

```txt
X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-X-
                                ^ this is the 5th X key from the right
```

As you see, we can not recognize a key without counting.
If we want a keyboard that fills the human hearing range, we need about 80 keys.
This would make 40 white and 40 black keys. Counting from left or right, to identify a key in the middle, we have to count at max to 20!

Without going into detail, thinking through the other proposals, yields a similar result:
We always have to count our way to the middle if we want to recognize a key.

Design insight #4:

> Irregular patterns create recognizable anchors

The last pattern is the only one thats irregular. Lets extend it to more keys:

```txt
XXXX--XX----XXXX--XX----XXXX--XX----XXXX--XX----XXXX--XX----
             ^ this is the 2nd key of the 4 Xes
```

```txt
XXXX--XX----XXXX--XX----XXXX--XX----XXXX--XX----XXXX--XX----
                              ^ this is first key of the 2 Xes
```

```txt
XXXX--XX----XXXX--XX----XXXX--XX----XXXX--XX----XXXX--XX----
                     ^ this is second key after the 2 Xes
```

This is great! We no longer have to count to the middle to find identify one of the 12 keys.
All we have to do is looking at a smaller region of keys to find out its relation to the others.

_Can we do better?_

In the 4 vs 2 design, we have to count up to 4, or to two if we use the from the right/left shortcut.
Maybe there are patterns that are better in terms of max count size & simplicity.

> Design insight #5: If irregularity is the key, maybe we should use numbers that do NOT divide 12

So which numbers do not divide 12? AHA: 5 and 7:

> X-X-X--X-X--

1.  X-----------
2.  X-----X-----
3.  X---X---X---
4.  X--X--X--X--
5.  X-X-X--X-X--
6.  X-X-X-X-X-X-
7.  ?
8.  -XX-XX-XX-XX
9.  -XXX-XXX-XXX
10. -XXXXX-XXXXX
11. -XXXXXXXXXXX
12. XXXXXXXXXXXX
