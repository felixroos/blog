---
title: Chord Scales
date: 2021-01-04
---

import { BlockMath, InlineMath } from 'react-katex';
import { Chord } from '@tonaljs/tonal';
import Tree from '../components/rhythmical/components/Tree.tsx';
import GraphvizJSON from '../components/graphs/GraphvizJSON.tsx';
import PathBuilder from '../components/graphs/PathBuilder.tsx';
import PathGraph from '../components/graphs/PathGraph.tsx';
import PathTree from '../components/graphs/PathTree.tsx';
import '../styles.css';
import scaleChroma from '../components/sets/scaleChroma';
import chromaDifference from '../components/sets/chromaDifference';
import scaleDifference from '../components/sets/scaleDifference';
import reorderChroma from '../components/sets/reorderChroma';
import scaleModes from '../components/sets/scaleModes';
import chordScales from '../components/sets/chordScales';
import bySetNum from '../components/sets/bySetNum';
import chordScaleGraph from '../components/graphs/chordScaleGraph';
import extendBestPath from '../components/graphs/extendBestPath';
import decoratePathValues from '../components/graphs/decoratePathValues';
import scaleColor from '../components/sets/scaleColor';
import { Graphviz } from 'graphviz-react';
import { groupBy } from 'lodash';
import { Scale, Note } from '@tonaljs/tonal';
import ChromaticCircle from '../components/sets/ChromaticCircle.tsx';
import HarmonicCircle from '../components/sets/HarmonicCircle.tsx';
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';

To build a hackable backing track player, we already laid the foundation of [rhythm](../rhythmical-objects/) and [harmony](../rhythmical-chords/).
What's missing: Melodies.
Even if we just want a backing track player, playing melodies is required for basslines, or any kind of melodic fill in.

So far, we were generating voicings from chord symbols. The problem: melodies will eventually use notes that are not a chord note.
Therefore, we need a way to find scales that fit to chord changes.

## Problem: Chord Scale Ambiguity

The main problem when searching for chord scales: most of the time, there are serveral scales that could be played over a single chord.
And it depends on the surrounding chords which scale choices are better than others. 
Here is a video where Barry Harris talks about chords vs keys:

<iframe width="560" height="315" src="https://www.youtube.com/embed/3V2eNh8qWVo" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

### Hello 251

Let's start with the "Hello World" of jazz chord progressions, the 251 in C major: `Dm7 G7 C^7`.

When only using the 7 modes of the major scale (diatonic scales), there are 3 scales that could be played over the D minor 7 chord:

export const chordScale = (chord, scale) => {
  const smallCircle = { r: 90, nodeRadius: 16 };
  const { notes: scaleNotes, tonic: scaleTonic } = Scale.get(scale);
  const { notes: chordNotes, tonic: chordTonic } = Chord.get(chord);
  const pcChromas = (notes) => notes.map((pc) => Note.get(pc).chroma);
  const scaleSet = pcChromas(scaleNotes.concat([scaleTonic]));
  const chordSet = pcChromas(chordNotes.concat([chordTonic]));
  const circle = {
    label: `${chord} ${scale}`,
    sets: [
      { stroke: scaleColor(scale), set: scaleSet },
      { stroke: 'steelblue', set: chordSet },
    ],
    pitches: scaleNotes,
    tonic: scaleTonic,
    ...smallCircle,
  };
  return (
    <div>
      <ChromaticCircle {...circle} />
    </div>
  );
};

<div style={{ display: 'flex' }}>
  {chordScale('Dm7', 'D dorian')}
  {chordScale('Dm7', 'D aeolian')}
  {chordScale('Dm7', 'D phrygian')}
</div>

There is only one (diatonic) scale that can be played over a the G7 chord:

<div>{chordScale('G7', 'G mixolydian')}</div>

There are 2 scales that could be played over a the C major 7 chord:

<div style={{ display: 'flex' }}>
  {chordScale('C^7', 'C lydian')}
  {chordScale('C^7', 'C major')}
</div>

### Scale Graph

We can visualize the transitions between the possible scales in a graph like this:

<center>
  <PathGraph
    paths={[
      { path: ['D dorian', 'G mixolydian', 'C major'] },
      { path: ['D dorian', 'G mixolydian', 'C lydian'] },
      { path: ['D aeolian', 'G mixolydian', 'C major'] },
      { path: ['D aeolian', 'G mixolydian', 'C lydian'] },
      { path: ['D phrygian', 'G mixolydian', 'C major'] },
      { path: ['D phrygian', 'G mixolydian', 'C lydian'] },
    ].map(decoratePathValues((a, b) => scaleDifference(a, b) / 2))}
    getColor={(scale) => scaleColor(scale)}
    includeStartNode={false}
    showCalculation={false}
    showDuplicates={false}
  />
</center>

<!--<GraphvizJSON
  options={{ height: 300 }}
  json={{
    graph: {
      directed: true,
      ...chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major'), true),
    },
  }}
/>-->

- Each column shows the possible scales for one chord, with the arrows representing transitions between scales.
- The numbers indicate the number of accidentals that change between scales. We can use them to evaluate how smooth the scale transition will be.
- The colorization is used like described in [this post](coloring-scales/).

Using this representation, we can turn it into a path finding problem.

### Choice Tree

Navigating the graph above, we can follow one of 6 possible paths:

<center>
  <PathTree
    paths={[
      { path: ['D dorian', 'G mixolydian', 'C major'] },
      { path: ['D dorian', 'G mixolydian', 'C lydian'] },
      { path: ['D aeolian', 'G mixolydian', 'C major'] },
      { path: ['D aeolian', 'G mixolydian', 'C lydian'] },
      { path: ['D phrygian', 'G mixolydian', 'C major'] },
      { path: ['D phrygian', 'G mixolydian', 'C lydian'] },
    ].map(decoratePathValues((a, b) => scaleDifference(a, b) / 2))}
    width={600}
    height={300}
    getColor={(scale) => scaleColor(scale)}
  />
</center>

Here, the leftmost path is the best, as its sum of values is 0. The worst path has a value of 3.

### Naive Approach

A naive approach for the algorithm would be to

1. find all possible chord scales for the given progression
2. calculate all possible transition values (accidental changes)
3. walk all possible paths and sum transition values
4. the path with the lowest transition value sum is the smoothest

### Complexity

Before implementing the algorithm above, let's think about its complexity.
To find out the total number of paths, we can multiply the number of scale choices for each chord:

<BlockMath>{`3 * 1 * 2 = 6`}</BlockMath>

In a common tune, there might be 32 bars of chords (and more). Event if each bar only has one chord with only 2 possible scales, we get:

<BlockMath>{`2^{32} = 4294967296`}</BlockMath>

paths, which is quite a lot.

### Smart Approach

A much more clever approach for path finding is something like the [A\* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
I won't go into detail here, but generally a heuristic is applied that favors certain more promising paths before less promising ones.

## Implementation

Now that we have a general idea of the problem, let's implement this!

### Finding chord scales

As a first step, we need to find all possible scales for a chord progression. What we want is something like this:

```js
const chords = ['Dm7', 'G7', 'C^7'];
chords.map((chord) => chordScales(chord, scaleModes('major')));
/*
[
  [ 'phrygian', 'aeolian', 'dorian' ],
  [ 'mixolydian' ],
  [ 'lydian', 'major' ]
]
*/
```

Instead of just using [Chord.chordScales](https://github.com/tonaljs/tonal/tree/master/packages/chord#chordchordscaleschordname-string--string), I am using a custom implementation that allows to filter the scales.
As this is not really the topic of this post, I put the details in a yellow box:

<Card elevation={3} >
<CardContent style={{backgroundColor:'#E9E850'}}>


<details>
  <summary>Show Implementation Details</summary>


### Subsets and Supersets

To be able to find out which scales contain a chord, we need to understand the concept of subsets and supersets.
To fully understand this, I recommend you to read my [pitch class sets post](../pitch-class-sets/) first.

Sets can be related by being sub or supersets. For example, a C major chord is a subset of the C major scale. Also, the C major scale is a superset of a C major chord.
So, a superset contains all notes of its subset + some more, while a subset contains some of its superset (and no others!).

In tonal, we can check if chromas are subsets or supersets:

```js
const isSupersetOfChord = (chord) => PcSet.isSupersetOf(Chord.get(chord).chroma);
isSupersetOfChord('M')(Scale.get('major').chroma); // true
isSupersetOfChord('M')(Scale.get('minor').chroma); // false

const isSubsetOfScale = (chord) => PcSet.isSubsetOf(Scale.get(chord).chroma);
isSubsetOfScale('major')(Chord.get('M').chroma); // true
isSubsetOfScale('major')(Chord.get('m').chroma); // false

const isChordScale = (scale, chord) => isSupersetOfChord(chord)(Scale.get(scale).chroma);
isChordScale('major', 'M'); // true
isChordScale('major', 'm'); // false

const isScaleChord = (chord, scale) => isSubsetOfScale(scale)(Chord.get(chord).chroma);
isScaleChord('M', 'major'); // true
isScaleChord('m', 'major'); // false
```

For a better understanding, let's implement our own isSuperset function:

```js
function isSuperset(superset, subset) {
  const superDec = parseInt(superset, 2);
  const subDec = parseInt(subset, 2);
  return (superDec | subDec) === superDec;
}
isSuperset(Scale.get('major').chroma, Chord.get('M').chroma); // true
isSuperset(Scale.get('major').chroma, Chord.get('m').chroma); // false
```

Here we are using a [bitwise OR operator](<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR#:~:text=The%20bitwise%20OR%20operator%20(%20%7C%20),both%20operands%20are%201%20s.>).
As bitwise OR expects a decimal input, we have to convert our chromas to decimal beforehand.
Now, if we apply the or between superset and subset, the superset will be the result if the subset has no additional ones!

For completeness, we can now implement isSubset, using isSuperset:

```js
function isSubset(subset, superset) {
  return isSuperset(superset, subset);
}
isSubset(Chord.get('M').chroma, Scale.get('major').chroma); // true
isSubset(Chord.get('m').chroma, Scale.get('major').chroma); // false
```

### Chord Scales

Now, if we want to know which scales we can play over a certain chord, we just have to look for supersets of the chords chroma. Luckily, there is already a method in tonal:

```js
Chord.chordScales('^7');
/*
[
  'ionian pentatonic',
  'lydian pentatonic',
  'augmented',
  'double harmonic lydian',
  'lydian',
  'augmented heptatonic',
  'harmonic major',
  'double harmonic major',
  'major',
  'lydian #9',
  'purvi raga',
  'bebop',
  'bebop major',
  'ichikosucho',
  'kafi raga',
  "messiaen's mode #3",
  'chromatic'
]
*/
```

To understand how it works + to have more control over the output, let's reimplent it:

```js
function chordScales(chord) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return Scale.names().filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
chordScales('^7');
```

### Filtering Choices

The above scale choices are pretty overwhelming. We could limit the checked scales like that:

```js
function chordScales(chord, scales = Scale.names()) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return scales.filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
chordScales('^7', ['major', 'minor', 'lydian']);
// ['lydian', 'major']
```

As we may want all modes of a certain scale family, we can spare us some typing with this:

```js
const oneOfModes = (families) => (scale) =>
  families.map((f) => Scale.get(f).normalized).includes(Scale.get(scale).normalized);
const scaleModes = (...families) => Scale.names().filter(oneOfModes(families));
scaleModes('major');
/*
[
  'lydian',
  'locrian',
  'phrygian',
  'aeolian',
  'dorian',
  'mixolydian',
  'major'
]
*/
chordScales('^7', scaleModes('major', 'harmonic minor', 'melodic minor'));
// [ 'lydian', 'major', 'lydian #9' ]
```

</details>


</CardContent>
</Card>
<br/>


### Scale Transitions

To know which scale transition are the smoothest, we need a way to assess change.
An easy way is using the chroma difference:

```js
export const chromaDifference(a, b) => {
  let diff = 0;
  for (let i = 0; i < 12; ++i) {
    diff += a[i] === b[i] ? 0 : 1
  }
  return diff;
}
```

After checking my artificial limb (stackoverflow), I found out we can achieve the same goal [using bit operations](https://stackoverflow.com/questions/50479322/how-to-find-bit-difference-between-two-numbers-in-javascript):

```js
export const chromaDifference = (a, b) => {
  const bitStr = ((parseInt(a, 2) ^ parseInt(b, 2)) >>> 0).toString(2);
  return bitStr.split('1').length - 1;
};
```

using popcount(a^b), more ideas can be found [here](https://stackoverflow.com/questions/43122082/efficiently-count-the-number-of-bits-in-an-integer-in-javascript):

```js
// const popcount = (x) => (!x ? 0 : (x & 1) + popcount((x >>= 1)));
const popcount = (n) => n.toString(2).replace(/0/g, '').length;
const chromaDiff = (a, b) => popcount(parseInt(a, 2) ^ parseInt(b, 2));
```

TODO: test which one is faster..

This function will count how much characters of two chromas are different. Example:

```

101011010101 = C major
101011010110 = F major
^^ = 2 different bits

```

If we divide the different bits by 2, we get the difference in accidentals:

```js
const fromCtoG = chromaDifference(scaleChroma('C major'), scaleChroma('F major')); // 2
const diff = fromCtoG / 2; // 1
```

In the final algorithm, we won't divide by 2, as it does not bring anything new to the table.

## Generating Scale Graphs

To be visualize the algorithm for development, we will use [graphviz-react](https://github.com/DomParfitt/graphviz-react).

As this is also just an extra implementation, I'll put the details in a green box.

<Card elevation={3} >
<CardContent style={{backgroundColor:'#C1E585'}}>


<details>
  <summary>Show Implementation Details</summary>


To be able to use JSON instead of DOT, we will use [jgf-dot](https://github.com/jsongraph/jgf-dot):

```js
import { Graphviz } from 'graphviz-react';
import toDot from 'jgf-dot';

export default function GraphvizJSON({ json, options }) {
  if (!json) {
    return;
  }
  const dot = toDot(json);
  // console.log('dot',dot);
  return <Graphviz dot={dot} options={options} />;
}
```

We can use it like that:

```js
<GraphvizJSON
  options={{ height: 300 }}
  json={{
    graph: {
      directed: true,
      ...chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major')),
    },
  }}
/>
```

Finally, the chordScaleGraph function will output a json-graph that represents the scales of the given chords:

```js
export default (chords, allowedScales = scaleModes('major'), halfDifference = false) => {
  const scales = chords
    .map((chord) => chordScales(chord, allowedScales))
    .map((choices) => (choices.length > 0 ? choices : ['chromatic']));
  let nodes = [];
  let links = [];
  scales.forEach((choices, i) => {
    choices
      .map((choice) => `${Chord.tokenize(chords[i])[0]} ${choice}`)
      .sort(bySetNum)
      .forEach((choice, j) => {
        if (i > 0) {
          const prev = scales[i - 1];
          prev.forEach((sourceScale, k) => {
            const source = nodes.length - j - prev.length + k;
            const target = nodes.length;
            let label = chromaDifference(scaleChroma(nodes[source].label), scaleChroma(choice));
            if (halfDifference) {
              label /= 2;
            }
            links.push({ source, target, label });
          });
        }
        nodes.push({ label: choice, fillcolor: scaleColor(choice), style: 'filled' });
      });
  });
  nodes = nodes.map((node, id) => ({ ...node, id }));
  return { nodes, edges: links };
};
```

</details>


</CardContent>
</Card>
<br/>


Finally, this is what we get:

<center>
  <PathGraph
    paths={[
      { path: ['D dorian', 'G mixolydian', 'C major'] },
      { path: ['D dorian', 'G mixolydian', 'C lydian'] },
      { path: ['D aeolian', 'G mixolydian', 'C major'] },
      { path: ['D aeolian', 'G mixolydian', 'C lydian'] },
      { path: ['D phrygian', 'G mixolydian', 'C major'] },
      { path: ['D phrygian', 'G mixolydian', 'C lydian'] },
    ].map(decoratePathValues((a, b) => scaleDifference(a, b) / 2))}
    getColor={(scale) => scaleColor(scale)}
    includeStartNode={false}
    showCalculation={false}
    showDuplicates={false}
  />
</center>

<!--<center>
  <GraphvizJSON
    options={{ height: 300 }}
    json={{
      graph: {
        directed: true,
        ...chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major'), true),
      },
    }}
  />
</center>-->

<br />

## Path Finding

Now let's get down to the nitty gritty.
Before talking code, let's look at how the graph is building up, step by step.
To be able to see some interesting results, we will use a doubled 251 progression `Dm7 G7 C^7 Dm7 G7 C^7`:

export const scaleDiff = (source, target) =>
  source && target ? chromaDifference(scaleChroma(source), scaleChroma(target)) / 2 : 0;

<PathBuilder
  chords={['Dm7', 'G7', 'C^7', 'Dm7', 'G7', 'C^7']}
  scales={scaleModes('major')}
  getValue={scaleDiff}
  height={400}
  width={600}
  noScroll={true}
  keepLongerPaths={true}
  view="tree"
/>
<br />

After pressing "Next Step" 7 times, it turns into "Done", and the algorithm has found the optimal path.
In this case, we have a match before we even had to check all transitions. This works because:

- At each step, the path with the lowest value is extended
- The algorithm finishes if a the path with the lowest value reaches the end.
- If no transition is negative (which cannot be), the shortest path is found

We could savely ignore the first "C lydian" as well as the second time "D phrygian" and "D aeolian", because they were not as promising.
This saves calculation time, which might seem marginal in this instance, but it will be a life saver for bigger graphs.

## What's in a Path?

We can describe a path like this:

```ts
declare type Path = {
  value: number;
  path: string[];
};
```

In the above example, our winning path is:

```json
{
  "value": 0,
  "path": ["D dorian", "G mixolydian", "C major", "D dorian", "G mixolydian", "C major"]
}
```

### Value Function

Also, we need a function that calculates the difference / cost between two graph nodes:

```ts
declare type ValueFn = (source: string, target: string, path: Path) => number;
```

## Generating Choice Trees

Turning

## Finding the Best Path

To get this path, what we want is this:

```js
// scale graph as 2D array:
const graph = [['D aeolian', 'D dorian'], ['G mixolydian'], ['C major', 'C lydian']];
// function that tells the "distance" between two scales:
const getValue = (source, target) => {
  return chromaDifference(scaleChroma(source), scaleChroma(target));
};
expect(findBestPath(graph, getValue)).toEqual(['D dorian', 'G mixolydian', 'C major']);
```

By pulling out `getValue`, we can reuse the function for similar uses later (like finding the absolute best voice leading for a whole tune).

### Basic Algorithm

The basic algorithm looks like this:

```js
import { minIndex } from 'd3-array';

export default function findBestPath(graph: string[][], getValue: ValueFn): string[] {
  // initialize variables:
  let paths: Path[] = [];
  let isFinished = false;
  while (!isFinished) {
    // run this magic function
    const extended = extendBestPath(paths, graph, getValue);
    if (!extended) {
      // if the result is false, we are finished
      isFinished = true;
    } else {
      // replace paths with extended edition
      paths = extended;
    }
  }
  // when we are finished, find the path with the lowest value
  const best = paths[minIndex(paths, (path) => path.value)];
  // and return just the actual path array
  return best.path;
}
```

I guess that does not look that complicated. But of course, this is just a skeleton, with the real meat hiding in the extendBestPath function.

### Extending the Best Path

To really understand what the function does, let's look at the 251 again, step by step:

#### Step 0

export const graph = [['D aeolian', 'D dorian'], ['G mixolydian'], ['C major', 'C lydian']];
export const getValue = (source, target) => {
  return chromaDifference(scaleChroma(source), scaleChroma(target));
};
export let path = [];

Before we do anything, we start with:

```js
const graph = [['D aeolian', 'D dorian'], ['G mixolydian'], ['C major', 'C lydian']];
const getValue = (source, target) => {
  return chromaDifference(scaleChroma(source), scaleChroma(target));
};
let paths = [];
```

#### Step 1

export const step1 = extendBestPath([], graph, getValue);

As a first step, we start with 2 paths leading to the 2 scale choices for the first chord:

<center>
  <PathTree paths={step1} getColor={(scale) => scaleColor(scale)} />
</center>

So we can formulate our first expectation:

```js
const step1 = [
  {
    path: ['D aeolian'],
    value: 0,
  },
  {
    path: ['D dorian'],
    value: 0,
  },
];
paths = extendBestPath(paths, graph, getValue);
expect(paths).toEqual(step1);
```

This is a special case, as the paths are initially populated. In the graphic, the "start" node is just a dummy, to be able to show the start values.

#### Step 2

export const step2 = extendBestPath(step1, graph, getValue);

In the second step, we extend the (first found) best path:

<!--<PathGraph height={300} paths={step2} getColor={(scale) => scaleColor(scale)} />-->

<center>
  <PathTree paths={step2} getColor={(scale) => scaleColor(scale)} />
</center>

```js
const step2 = extendBestPath(step1, graph, getValue);
expect(step2).toEqual([
  {
    path: ['D aeolian', 'G mixolydian'],
    value: 2,
    values: [0, 2],
  },
  step1[1], // index 1 does not change so we spare some writing
]);
```

#### Step 3

export const step3 = extendBestPath(step2, graph, getValue);

Next, the second root branch seems more tempting, as it is still zero:

<!--<PathGraph height={300} paths={step3} getColor={(scale) => scaleColor(scale)} />-->

<center>
  <PathTree paths={step3} getColor={(scale) => scaleColor(scale)} />
</center>

```js
const step3 = extendBestPath(step2, graph, getValue);
expect(step3).toEqual([
  step2[0],
  {
    path: ['D dorian', 'G mixolydian'],
    value: 0,
    values: [0, 0],
  },
]);
```

#### Step 4

export const step4 = extendBestPath(step3, graph, getValue);

Now, we continue extending the right branch, as it is still zero (compared to 2):

<!-- TODO: add PathView with tree + graph + json modes and maybe a minimap -->

<center>
  <PathTree paths={step4} getColor={(scale) => scaleColor(scale)} />
</center>

```js
const step4 = extendBestPath(step3, graph, getValue);
expect(step4).toEqual([
  step2[0],
  {
    path: ['D dorian', 'G mixolydian', 'C major'],
    value: 0,
    values: [0, 0, 0],
  },
  {
    path: ['D dorian', 'G mixolydian', 'C lydian'],
    value: 2,
    values: [0, 0, 2],
  },
]);
```

Now, we're pretty much done.

#### Step 5

export const step5 = extendBestPath(step4, graph, getValue);

Now that the minimal path is done, we do not need to check the rest, as they will be longer anyway, as long as we do not allow negative values.
To satisfy our algorithm, we now expect the function to return false:

```js
const step5 = extendBestPath(step4, graph, getValue);
expect(step5).toBe(false);
```

#### The actual function

After that in depth example, the algorithm might be digestible:

```js
import { minIndex } from 'd3-array';

export default function extendBestPath(paths: Path[], graph: string[][], getValue: ValueFn): Path[] | false {
  if (!paths.length) {
    // if no paths are given, return initial paths, see step 1
    return graph[0].map((candidate) => ({ value: 0, path: [candidate] }));
  }
  // find index with lowest value
  const bestIndex = minIndex(paths, (path) => path.value);
  const best = paths[bestIndex];
  const { path, value } = best;
  if (path.length >= graph.length) {
    // we are done: see step 5
    return false;
  }
  // generate next possible steps by splitting up the best path for all possible next candidates
  // see steps 2 - 4
  const nextSteps: Path[] = graph[path.length].map((candidate) => {
    const nextValue = getValue(path[path.length - 1], candidate, best);
    return {
      value: value + nextValue,
      path: path.concat(candidate),
    };
  });
  // replace best path with nextSteps
  return [...paths.slice(0, bestIndex), ...nextSteps, ...paths.slice(bestIndex + 1)];
}
```

That's the basic trick! But we might run into some unforseen problems when throwing more complex graphs in..

## Branch Pruning

Like a diligent gardener, we might need some branch pruning to get better results..
To illustrate the problem, let's the chord progression `TODO`

export const pentatonicScales = Scale.names().filter((scale) => Scale.get(`C ${scale}`).notes.length === 5);

## Solar

export const solarChords = [
  'CmM7',
  'Gm7',
  'C7',
  'F^7',
  'Fm7',
  'Bb7',
  'Eb^7',
  'Ebm7',
  'Ab7',
  'Db^7',
  'Dm7b5',
  'G7b9',
  'CmM7',
];
export const solarScales = scaleModes('major', 'melodic minor', 'harmonic minor');
//export const solarScales = pentatonicScales;
//export const solarScales = ['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6', 'harmonic minor'];

<PathBuilder
  height={600}
  maxHeight={2000}
  noScroll={false}
  keepLongerPaths={false}
  onlyKeepWinner={true}
  view={'graph'}
  scales={solarScales}
  chords={solarChords}
/>

<details>
  <summary>show full graph</summary>


TODO: get rid of chordScaleGraph, use PathGraph instead

<Card elevation={3} >
<CardContent style={{ maxHeight: 500, overflow: 'auto'}}>
  <GraphvizJSON
    options={{ fit: true, height: 1800, width: 620 }}
    json={{
      graph: {
        directed: true,
        ...chordScaleGraph(
          solarChords,
          solarScales
        ),
      },
    }}
  />


</CardContent>
</Card>
</details>
<br />


## How High The Moon

export const hhtm = ['G^7', 'Gm7', 'C7', 'F^7', 'Fm7', 'Bb7', 'Eb^7', 'Am7b5', 'D7b9', 'Gm7', 'Am7b5', 'D7b9'];
export const hhtmScales = scaleModes('major', 'melodic minor', 'harmonic minor');
//export const hhtmScales = ['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6'];

<PathBuilder
  height={600}
  maxHeight={2000}
  noScroll={false}
  keepLongerPaths={false}
  onlyKeepWinner={true}
  view={'graph'}
  scales={hhtmScales}
  chords={hhtm}
/>

<details>
  <summary>show full graph</summary>
  <Card elevation={3}>
    <CardContent style={{ maxHeight: 500, overflow: 'auto' }}>
      <GraphvizJSON
        options={{ fit: true, height: 3000, width: 620 }}
        json={{
          graph: {
            directed: true,
            ...chordScaleGraph(hhtm, hhtmScales),
          },
        }}
      />
    </CardContent>
  </Card>
</details>
<br />

## All The Things You Are

<!-- interval={500}  -->

<!-- export const attyaScales = ['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6']; -->

export const attyaScales = scaleModes('major', 'melodic minor', 'harmonic minor');

export const attyaChords = [
  'Fm7',
  'Bbm7',
  'Eb7',
  'Ab^7',
  'Db^7',
  'Dm7',
  'G7',
  'C^7',
  'C^7',
  'Cm7',
  'Fm7',
  'Bb7',
  'Eb^7',
  'Ab^7',
  'Am7',
  'D7',
  'G^7',
  'G^7',
  'Am7',
  'D7',
  'G^7',
  'G^7',
  'F#h7',
  'B7b9',
  'E^7',
  'C7b13',
  'Fm7',
  'Bbm7',
  'Eb7',
  'Ab^7',
  'Db^7',
  'Db-^7',
  'Cm7',
  'Bo7',
  'Bbm7',
  'Eb7',
  'Ab^7',
  'Gh7',
  'C7b9',
];

<PathBuilder
  height={500}
  width={600}
  maxHeight={2000}
  noScroll={false}
  keepLongerPaths={false}
  onlyKeepWinner={true}
  view={'graph'}
  scales={attyaScales}
  chords={attyaChords}
/>
  
<details>
  <summary>show full graph</summary>


<Card elevation={3} >
<CardContent style={{ maxHeight: 500, overflow: 'auto'}}>
  <GraphvizJSON
    options={{ fit: true, height: 3000, width: 620 }}
    json={{
      graph: {
        directed: true,
        ...chordScaleGraph(
          attyaChords,
          attyaScales
        ),
      },
    }}
  />


</CardContent>
</Card>
</details>
<br />


- TBD: calculate svg height based on longest path with "heightPerLevel" to adjust the height as needed
- TBD: colorize shortest path
- TBD: autoscroll to shortest leaf

## Links

- [Search: Optimal, Branch and Bound, Astar @MIT](https://www.youtube.com/watch?v=gGQ-vAmdAOI)

## TODO

- sort branches by lowest value first https://youtu.be/gGQ-vAmdAOI?t=1014 ?
- extend only if not already extended https://youtu.be/gGQ-vAmdAOI?t=1236
  - => add "extended" list (e.g `[[0,0],[1,0]]`)
  - dead horse principle
- think more about airline distance (can this be used with 0 distances??) https://youtu.be/gGQ-vAmdAOI?t=1680
  - maybe just use graph.length - path.length as distance to goal https://youtu.be/j1H3jAAGlEA?t=1879
- the case that shorter paths are extended after longer ones is a no case https://youtu.be/gGQ-vAmdAOI?t=2642
- maybe try beam search to also keep not so good paths, could use it with [min, max] to also throw away too smooth paths ! https://youtu.be/j1H3jAAGlEA?t=1978
