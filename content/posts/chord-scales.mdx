---
title: Chord Scales
date: 2021-01-04
---

import { BlockMath, InlineMath } from 'react-katex';
import { Chord } from '@tonaljs/tonal';
import { Graph } from '../components/graphs/Graphviz.tsx';
import PathBuilder from '../components/graphs/PathBuilder.tsx';
import '../styles.css';
import scaleChroma from '../components/sets/scaleChroma';
import chromaDifference from '../components/sets/chromaDifference';
import scaleDifference from '../components/sets/scaleDifference';
import reorderChroma from '../components/sets/reorderChroma';
import scaleModes from '../components/sets/scaleModes';
import chordScales from '../components/sets/chordScales';
import bySetNum from '../components/sets/bySetNum';
import chordScaleGraph from '../components/graphs/chordScaleGraph';
import extendBestPath from '../components/graphs/extendBestPath';
import decoratePathValues from '../components/graphs/decoratePathValues';
import scaleColor from '../components/sets/scaleColor';
import { groupBy } from 'lodash';
import { Scale, Note } from '@tonaljs/tonal';
import ChromaticCircle from '../components/sets/ChromaticCircle.tsx';
import HarmonicCircle from '../components/sets/HarmonicCircle.tsx';
import Card from '@material-ui/core/Card';
import CardContent from '@material-ui/core/CardContent';

To build a hackable backing track player, we already laid the foundation of [rhythm](../rhythmical-objects/) and [harmony](../rhythmical-chords/).
What's missing: Melodies.
Even if we just want a backing track player, playing melodies is required for basslines, or any kind of melodic fill in.

So far, we were generating voicings from chord symbols. The problem: melodies will eventually use notes that are not a chord note.
Therefore, we need a way to find scales that fit to chord changes.

## Problem: Chord Scale Ambiguity

The main problem when searching for chord scales: most of the time, there are serveral scales that could be played over a single chord.
And it depends on the surrounding chords which scale choices are better than others.
Here is a video where Barry Harris talks about chords vs keys:

<iframe
  width="560"
  height="315"
  src="https://www.youtube.com/embed/3V2eNh8qWVo"
  title="YouTube video player"
  frameborder="0"
  allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
></iframe>

import NestedGrid from '../components/graphs/NestedGrid';
import { renderChordSymbols } from '../components/score/ChordSymbol';
import { mapNestedArray } from '../components/rhythmical/tree/mapNestedArray';

This is the chord they are talking about:

<NestedGrid
  rows={[1]}
  innerBorders={true}
  outerBorders={false}
  cells={mapNestedArray(
    [
      ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'],
      ['Db^7', ['Dm7', 'G7'], 'C^7', '%'],
      ['Cm7', 'Fm7', 'Bb7', 'Eb^7'],
      ['Ab^7', ['Am7', 'D7'], 'G^7', '%'],
      ['Am7', 'D7', 'G^7', '%'],
      ['F#m7b5', 'B7b9', 'E^7', 'C7b13'],
      ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'],
      ['Db^7', 'DbmM7', 'Cm7', 'Bo7'],
      ['Bbm7', 'Eb7', 'Ab^7', ['Gm7b5', 'C7b9']],
    ],
    (e, i, a) => {
      if (e === 'Cm7' && i === 2) {
        return <div style={{ backgroundColor: 'steelblue', color: 'white' }}>{e}</div>;
      }
      return e;
    }
  )}
/>
<br />

He says: "When you see a C minor in the key of Ab, it's not necessarily the C minor 7 that's in the key of Bb,
so I cannot put a D natural in it. It's the Ab major scale."

In other words: As the Cm7 appears as in the context of Ab major, it can be seen as the 3rd step chord,
which is based on the phrygian mode, which has a b9.
So you would prefer phrygian over aeolian or dorian if you want to stay in Ab major.

### A Little Sidenote

There are some people (including Barry Harris), that do not like the chord / scale approach.
One reason is that the original jazz artists most certainly did not think that way.
I still like having scale names as a means to express note material that exceeds 4 notes.
If you would want to express more than 4 notes as chord symbols, it gets ugly.

Don't take the sentence "scale X can be played over chord Y" too seriously.. It does not mean
you should be playing the scale up and down, it just means those 7 notes fit over the chord.

### Hello 251

Let's dial back a little bit, and start with the "Hello World" of jazz chord progressions, the 251 in C major: `Dm7 G7 C^7`.

When only using the 7 modes of the major scale (diatonic scales), there are 3 scales that could be played over the D minor 7 chord:

export const chordScale = (chord, scale) => {
  const smallCircle = { r: 90, nodeRadius: 16 };
  const { notes: scaleNotes, tonic: scaleTonic } = Scale.get(scale);
  const { notes: chordNotes, tonic: chordTonic } = Chord.get(chord);
  const pcChromas = (notes) => notes.map((pc) => Note.get(pc).chroma);
  const scaleSet = pcChromas(scaleNotes.concat([scaleTonic]));
  const chordSet = pcChromas(chordNotes.concat([chordTonic]));
  const circle = {
    label: `${chord} ${scale}`,
    sets: [
      { stroke: scaleColor(scale), set: scaleSet },
      { stroke: 'steelblue', set: chordSet },
    ],
    pitches: scaleNotes,
    tonic: scaleTonic,
    ...smallCircle,
  };
  return (
    <div>
      <ChromaticCircle {...circle} />
    </div>
  );
};

<div style={{ display: 'flex', justifyContent: 'center' }}>
  {chordScale('Dm7', 'D dorian')}
  {chordScale('Dm7', 'D aeolian')}
  {chordScale('Dm7', 'D phrygian')}
</div>

There is only one (diatonic) scale that can be played over a the G7 chord:

<center>
  <div>{chordScale('G7', 'G mixolydian')}</div>
</center>

There are 2 scales that could be played over a the C major 7 chord:

<div style={{ display: 'flex', justifyContent: 'center' }}>
  {chordScale('C^7', 'C lydian')}
  {chordScale('C^7', 'C major')}
</div>
<br />

### Scale Graph

We can visualize the transitions between the possible scales in a graph like this:

<Graph
  json={{
    graph: {
      directed: true,
      ...chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major'), true),
    },
  }}
/>
<br />

- Each column shows the possible scales for one chord, with the arrows representing transitions between scales.
- The numbers indicate the number of accidentals that change between scales. We can use them to evaluate how smooth the scale transition will be.
- The colorization is used like described in [this post](coloring-scales/).

Using this representation, we can turn it into a path finding problem.

### Choice Tree

Navigating the graph above, we can follow one of 6 possible paths:

<Graph
  json={{
    graph: {
      directed: true,
      nodes: [
        {
          label: 'start',
          id: '0',
        },
        {
          label: 'D dorian',
          id: '0.0:D dorian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '0.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'C major',
          id: '0.2:C major',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'C lydian',
          id: '1.2:C lydian',
          fillcolor: '#b2e580',
          style: 'filled',
        },
        {
          label: 'D aeolian',
          id: '2.0:D aeolian',
          fillcolor: '#e5b380',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '2.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'C major',
          id: '2.2:C major',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'C lydian',
          id: '3.2:C lydian',
          fillcolor: '#b2e580',
          style: 'filled',
        },
        {
          label: 'D phrygian',
          id: '4.0:D phrygian',
          fillcolor: '#f6afaf',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '4.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'C major',
          id: '4.2:C major',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'C lydian',
          id: '5.2:C lydian',
          fillcolor: '#b2e580',
          style: 'filled',
        },
      ],
      edges: [
        {
          source: '0',
          target: '0.0:D dorian',
          label: '0',
        },
        {
          source: '0.0:D dorian',
          target: '0.1:G mixolydian',
          label: '+0',
        },
        {
          source: '0.1:G mixolydian',
          target: '0.2:C major',
          label: '+0=0',
        },
        {
          source: '0',
          target: '0.0:D dorian',
          label: '0',
        },
        {
          source: '0.0:D dorian',
          target: '0.1:G mixolydian',
          label: '+0',
        },
        {
          source: '0.1:G mixolydian',
          target: '1.2:C lydian',
          label: '+1=1',
        },
        {
          source: '0',
          target: '2.0:D aeolian',
          label: '0',
        },
        {
          source: '2.0:D aeolian',
          target: '2.1:G mixolydian',
          label: '+1',
        },
        {
          source: '2.1:G mixolydian',
          target: '2.2:C major',
          label: '+0=1',
        },
        {
          source: '0',
          target: '2.0:D aeolian',
          label: '0',
        },
        {
          source: '2.0:D aeolian',
          target: '2.1:G mixolydian',
          label: '+1',
        },
        {
          source: '2.1:G mixolydian',
          target: '3.2:C lydian',
          label: '+1=2',
        },
        {
          source: '0',
          target: '4.0:D phrygian',
          label: '0',
        },
        {
          source: '4.0:D phrygian',
          target: '4.1:G mixolydian',
          label: '+2',
        },
        {
          source: '4.1:G mixolydian',
          target: '4.2:C major',
          label: '+0=2',
        },
        {
          source: '0',
          target: '4.0:D phrygian',
          label: '0',
        },
        {
          source: '4.0:D phrygian',
          target: '4.1:G mixolydian',
          label: '+2',
        },
        {
          source: '4.1:G mixolydian',
          target: '5.2:C lydian',
          label: '+1=3',
        },
      ],
    },
  }}
/>
<br />

Here, the leftmost path is the best, as its sum of values is 0. The worst path has a value of 3.

## Implementing Chord Scale Graphs

Now that we have a general idea of the problem, let's implement this!
Before we can do any path finding, we need to generate a scale graph from our chord changes.

Generally, a graph consists of nodes and edges, in our domain, those are:

- nodes: chord scales
- edges: scale transitions

### Finding chord scales

To get our graph's nodes, we need to find all possible scales for a chord progression. What we want is something like this:

```js
const chords = ['Dm7', 'G7', 'C^7'];
chords.map((chord) => chordScales(chord, scaleModes('major')));
/*
[
  [ 'phrygian', 'aeolian', 'dorian' ],
  [ 'mixolydian' ],
  [ 'lydian', 'major' ]
]
*/
```

Instead of just using [Chord.chordScales](https://github.com/tonaljs/tonal/tree/master/packages/chord#chordchordscaleschordname-string--string), I am using a custom implementation that allows to filter the scales.
As this is not really the topic of this post, I put the details in a yellow box:

<Card elevation={3} >
<CardContent style={{backgroundColor:'#E9E850'}}>

<details>
  <summary>Show Implementation Details</summary>

### Subsets and Supersets

To be able to find out which scales contain a chord, we need to understand the concept of subsets and supersets.
To fully understand this, I recommend you to read my [pitch class sets post](../pitch-class-sets/) first.

Sets can be related by being sub or supersets. For example, a C major chord is a subset of the C major scale. Also, the C major scale is a superset of a C major chord.
So, a superset contains all notes of its subset + some more, while a subset contains some of its superset (and no others!).

In tonal, we can check if chromas are subsets or supersets:

```js
const isSupersetOfChord = (chord) => PcSet.isSupersetOf(Chord.get(chord).chroma);
isSupersetOfChord('M')(Scale.get('major').chroma); // true
isSupersetOfChord('M')(Scale.get('minor').chroma); // false

const isSubsetOfScale = (chord) => PcSet.isSubsetOf(Scale.get(chord).chroma);
isSubsetOfScale('major')(Chord.get('M').chroma); // true
isSubsetOfScale('major')(Chord.get('m').chroma); // false

const isChordScale = (scale, chord) => isSupersetOfChord(chord)(Scale.get(scale).chroma);
isChordScale('major', 'M'); // true
isChordScale('major', 'm'); // false

const isScaleChord = (chord, scale) => isSubsetOfScale(scale)(Chord.get(chord).chroma);
isScaleChord('M', 'major'); // true
isScaleChord('m', 'major'); // false
```

For a better understanding, let's implement our own isSuperset function:

```js
function isSuperset(superset, subset) {
  const superDec = parseInt(superset, 2);
  const subDec = parseInt(subset, 2);
  return (superDec | subDec) === superDec;
}
isSuperset(Scale.get('major').chroma, Chord.get('M').chroma); // true
isSuperset(Scale.get('major').chroma, Chord.get('m').chroma); // false
```

Here we are using a [bitwise OR operator](<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR#:~:text=The%20bitwise%20OR%20operator%20(%20%7C%20),both%20operands%20are%201%20s.>).
As bitwise OR expects a decimal input, we have to convert our chromas to decimal beforehand.
Now, if we apply the or between superset and subset, the superset will be the result if the subset has no additional ones!

For completeness, we can now implement isSubset, using isSuperset:

```js
function isSubset(subset, superset) {
  return isSuperset(superset, subset);
}
isSubset(Chord.get('M').chroma, Scale.get('major').chroma); // true
isSubset(Chord.get('m').chroma, Scale.get('major').chroma); // false
```

### Chord Scales

Now, if we want to know which scales we can play over a certain chord, we just have to look for supersets of the chords chroma. Luckily, there is already a method in tonal:

```js
Chord.chordScales('^7');
/*
[
  'ionian pentatonic',
  'lydian pentatonic',
  'augmented',
  'double harmonic lydian',
  'lydian',
  'augmented heptatonic',
  'harmonic major',
  'double harmonic major',
  'major',
  'lydian #9',
  'purvi raga',
  'bebop',
  'bebop major',
  'ichikosucho',
  'kafi raga',
  "messiaen's mode #3",
  'chromatic'
]
*/
```

To understand how it works + to have more control over the output, let's reimplent it:

```js
function chordScales(chord) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return Scale.names().filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
chordScales('^7');
```

### Filtering Choices

The above scale choices are pretty overwhelming. We could limit the checked scales like that:

```js
function chordScales(chord, scales = Scale.names()) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return scales.filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
chordScales('^7', ['major', 'minor', 'lydian']);
// ['lydian', 'major']
```

As we may want all modes of a certain scale family, we can spare us some typing with this:

```js
const oneOfModes = (families) => (scale) =>
  families.map((f) => Scale.get(f).normalized).includes(Scale.get(scale).normalized);
const scaleModes = (...families) => Scale.names().filter(oneOfModes(families));
scaleModes('major');
/*
[
  'lydian',
  'locrian',
  'phrygian',
  'aeolian',
  'dorian',
  'mixolydian',
  'major'
]
*/
chordScales('^7', scaleModes('major', 'harmonic minor', 'melodic minor'));
// [ 'lydian', 'major', 'lydian #9' ]
```

</details>

</CardContent>
</Card>
<br/>

### Scale Transitions

For our graph's edges, we need to find way to evaluate scale transitions.

To tell how much change is happening in a scale transition, we can use the chroma difference:

```js
export const chromaDifference(a, b) => {
  let diff = 0;
  for (let i = 0; i < 12; ++i) {
    diff += a[i] === b[i] ? 0 : 1
  }
  return diff;
}
```

This function will count how much characters of two chromas are different. Example:

```

101011010101 = C major
101011010110 = F major
^^ = 2 different bits

```

If we divide the different bits by 2, we get the difference in accidentals:

```js
const fromCtoG = chromaDifference(scaleChroma('C major'), scaleChroma('F major')); // 2
const diff = fromCtoG / 2; // 1
```

In the final algorithm, we won't divide by 2, as it does not bring anything new to the table.

### Rendering Scale Graphs

Now that we have our nodes (scales) and edges (scale transitions), we can generate a graph from a set of chord changes.
To visualize the algorithm for development, we will use [graphviz](https://graphviz.org/).

As this is also just an extra implementation, I'll put the details in a green box.

<Card elevation={3} >
<CardContent style={{backgroundColor:'#C1E585'}}>

<details>
  <summary>Show Implementation Details</summary>

To be able to use JSON instead of DOT, we will use [jgf-dot](https://github.com/jsongraph/jgf-dot):

```js
import { Graphviz } from 'graphviz-react';
import toDot from 'jgf-dot';

export default function GraphvizJSON({ json, options }) {
  if (!json) {
    return;
  }
  const dot = toDot(json);
  // console.log('dot',dot);
  return <Graphviz dot={dot} options={options} />;
}
```

We can use it like that:

```js
<GraphvizJSON
  options={{ height: 300 }}
  json={{
    graph: {
      directed: true,
      ...chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major')),
    },
  }}
/>
```

Finally, the chordScaleGraph function will output a json-graph that represents the scales of the given chords:

```js
export default function chordScaleGraph(chords, allowedScales = scaleModes('major'), halfDifference = false) {
  const scales = chords
    .map((chord) => chordScales(chord, allowedScales))
    .map((choices) => (choices.length > 0 ? choices : ['chromatic']));
  let nodes = [];
  let links = [];
  scales.forEach((choices, i) => {
    choices
      .map((choice) => `${Chord.tokenize(chords[i])[0]} ${choice}`)
      .sort(bySetNum)
      .forEach((choice, j) => {
        if (i > 0) {
          const prev = scales[i - 1];
          prev.forEach((sourceScale, k) => {
            const source = nodes.length - j - prev.length + k;
            const target = nodes.length;
            let label = chromaDifference(scaleChroma(nodes[source].label), scaleChroma(choice));
            if (halfDifference) {
              label /= 2;
            }
            links.push({ source, target, label });
          });
        }
        nodes.push({ label: choice, fillcolor: scaleColor(choice), style: 'filled' });
      });
  });
  nodes = nodes.map((node, id) => ({ ...node, id }));
  return { nodes, edges: links };
}
```

UPDATE: replaced graphviz-react by [@hpcc-js/wasm](https://github.com/hpcc-systems/hpcc-js-wasm),
which is internatlly used by d3-graphviz, which is a dependency of graphviz-react.

</details>

</CardContent>
</Card>
<br/>

Finally, this is what we get:

<Graph
  json={{
    graph: {
      directed: true,
      ...chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major'), true),
    },
  }}
/>
<br />

## Path Finding

As we now have all the tools we need, let's talk about how path finding works.

### Naive Approach

A naive approach for a the algorithm would be to

1. find all possible chord scales for the given progression
2. calculate all possible transition values (accidental changes)
3. walk all possible paths and sum transition values
4. the path with the lowest transition value sum is the smoothest

### Complexity

Before implementing the algorithm above, let's think about its complexity.
To find out the total number of paths, we can multiply the number of scale choices for each chord. In the 251 example, this is:

<BlockMath>{`3 * 1 * 2 = 6`}</BlockMath>

In a common tune, there might be 32 bars of chords (and more). Event if each bar only has one chord with only 2 possible scales, we get:

<BlockMath>{`2^{32} = 4294967296`}</BlockMath>

paths, which is quite a lot.

### Smart Approach

A much more clever approach for path finding is something like [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) or the [A\* algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
The general trick is to only calculate the transitions needed, by always following the most promising path first.
We will find out what that means below..

### Step by Step Path Exploration

Before talking code, let's look at how the algorithm should behave, step by step.
To be able to see some interesting results, we will use a doubled 251 progression `Dm7 G7 C^7 Dm7 G7 C^7`:

export const scaleDiff = (source, target) =>
  source && target ? chromaDifference(scaleChroma(source), scaleChroma(target)) / 2 : 0;

<PathBuilder
  chords={['Dm7', 'G7', 'C^7', 'Dm7', 'G7', 'C^7']}
  scales={scaleModes('major')}
  getValue={scaleDiff}
  height={400}
  width={600}
  noScroll={true}
  keepLongerPaths={true}
  view="tree"
/>
<br />

After pressing "Next Step" 7 times, it turns into "Done", and the algorithm has found the optimal path.
In this case, we have a match before we even had to check all transitions. This works because:

- At each step, the path with the lowest value is extended
- The algorithm finishes if a the path with the lowest value reaches the end.
- If no transition is negative (which cannot be), the shortest path is found

We could savely ignore the first "C lydian" as well as the second time "D phrygian" and "D aeolian", because they were not as promising.
This saves calculation time, which might seem marginal in this instance, but it will be a life saver for bigger graphs.

## General Algorithm

Let's try to formulate the basic algorithm.

### Connections

To think about links between nodes, let's use this type:

```ts
declare type Connection = [source: string | null, target: string, value: number];
```

- source: the node we come from, null if it's a start connection
- target: the node we are going to
- value: the total value to get there

Inside our algorithm, we will collect 2 lists of connections:

- open: connections that we can follow next
- closed: connections that we already followed

In our 251 example, we start with the following connections:

```json
{
  "open": [
    [null, "D phrygian", 0],
    [null, "D aeolian", 0],
    [null, "D dorian", 0]
  ],
  "closed": []
}
```

<Graph
  json={{
    graph: {
      directed: true,
      nodes: [
        {
          label: 'start',
          id: '0',
        },
        {
          label: 'D phrygian',
          id: '0.0:D phrygian',
          fillcolor: '#f6afaf',
          style: 'filled',
        },
        {
          label: 'D aeolian',
          id: '1.0:D aeolian',
          fillcolor: '#e5b380',
          style: 'filled',
        },
        {
          label: 'D dorian',
          id: '2.0:D dorian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
      ],
      edges: [
        {
          source: '0',
          target: '0.0:D phrygian',
          label: '0',
        },
        {
          source: '0',
          target: '1.0:D aeolian',
          label: '0',
        },
        {
          source: '0',
          target: '2.0:D dorian',
          label: '0',
        },
      ],
    },
  }}
/>

### Algorithm Loop

Now, the basic algorithm loop works like this:

<Graph
  json={{
    graph: {
      directed: true,
      nodes: [
        { label: 'start', id: '-1' },
        {
          label: '1. find connection with minimum value',
          fillcolor: 'steelblue',
          style: 'filled',
          id: 0,
        },
        {
          label: '2. leads to goal?',
          fillcolor: 'salmon',
          style: 'filled',
          id: 1,
        },
        {
          label: 'stop',
          fillcolor: 'red',
          style: 'filled',
          id: 2,
        },
        {
          label: '3. close that connection',
          fillcolor: 'steelblue',
          style: 'filled',
          id: 3,
        },
        { label: '4. open all connections it leads to', fillcolor: 'steelblue', style: 'filled', id: 4 },
      ],
      edges: [
        {
          source: -1,
          target: 0,
        },
        {
          source: 0,
          target: 1,
        },
        {
          source: 1,
          target: 2,
          label: 'yes',
        },
        {
          source: 1,
          target: 3,
          label: 'no',
        },
        { source: 3, target: 4 },
        { source: 4, target: 0 },
      ],
    },
  }}
/>
<br />

or as text:

1. find connection with minimum value
2. stop if minimum connection leads to goal
3. close that connection
4. open all connections it leads to
5. jump to 1

Let's try that out on our example. At the start, we have 3 minimum connections with value 0, so we will just begin with the first one:

import ReactDiffViewer from 'react-diff-viewer';

<ReactDiffViewer
  oldValue={`{
      open: [
        [null, 'D phrygian', 0],
        [null, 'D aeolian', 0],
        [null, 'D dorian', 0],
      ],
      closed: [
      ],
    }`}
  newValue={`{
      open: [
        ['D phrygian', 'G mixolydian', 2],
        [null, 'D aeolian', 0],
        [null, 'D dorian', 0],
      ],
      closed: [
        [null, 'D phrygian', 0],
      ],
    }`}
  splitView={false}
  extraLinesSurroundingDiff={100}
  useDarkTheme={true}
  hideLineNumbers={true}
/>

<Graph
  json={{
    graph: {
      directed: true,
      nodes: [
        {
          label: 'start',
          id: '0',
        },
        {
          label: 'D phrygian',
          id: '0.0:D phrygian',
          fillcolor: '#f6afaf',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '0.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'D aeolian',
          id: '1.0:D aeolian',
          fillcolor: '#e5b380',
          style: 'filled',
        },
        {
          label: 'D dorian',
          id: '2.0:D dorian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
      ],
      edges: [
        {
          source: '0',
          target: '0.0:D phrygian',
          label: '0',
        },
        {
          source: '0.0:D phrygian',
          target: '0.1:G mixolydian',
          label: '+2=2',
        },
        {
          source: '0',
          target: '1.0:D aeolian',
          label: '0',
        },
        {
          source: '0',
          target: '2.0:D dorian',
          label: '0',
        },
      ],
    },
  }}
/>

Now comes the next loop. Again, we are picking the open connection with the smallest value, which is now D aeolian:

<ReactDiffViewer
  oldValue={`{
      open: [
        ['D phrygian', 'G mixolydian', 2],
        [null, 'D aeolian', 0],
        [null, 'D dorian', 0],
      ],
      closed: [
        [null, 'D phrygian', 0],
      ],
    }`}
  newValue={`{
      open: [
        ['D phrygian', 'G mixolydian', 2],
        ['D aeolian', 'G mixolydian', 1],
        [null, 'D dorian', 0],
      ],
      closed: [
        [null, 'D phrygian', 0],
        [null, 'D aeolian', 0],
      ],
    }`}
  splitView={false}
  extraLinesSurroundingDiff={100}
  useDarkTheme={true}
  hideLineNumbers={true}
/>

<Graph
  json={{
    graph: {
      directed: true,
      nodes: [
        {
          label: 'start',
          id: '0',
        },
        {
          label: 'D phrygian',
          id: '0.0:D phrygian',
          fillcolor: '#f6afaf',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '0.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'D aeolian',
          id: '1.0:D aeolian',
          fillcolor: '#e5b380',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '1.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'D dorian',
          id: '2.0:D dorian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
      ],
      edges: [
        {
          source: '0',
          target: '0.0:D phrygian',
          label: '0',
        },
        {
          source: '0.0:D phrygian',
          target: '0.1:G mixolydian',
          label: '+2=2',
        },
        {
          source: '0',
          target: '1.0:D aeolian',
          label: '0',
        },
        {
          source: '1.0:D aeolian',
          target: '1.1:G mixolydian',
          label: '+1=1',
        },
        {
          source: '0',
          target: '2.0:D dorian',
          label: '0',
        },
      ],
    },
  }}
/>

The last connection is now the minimum:

<ReactDiffViewer
  oldValue={`{
      open: [
        ['D phrygian', 'G mixolydian', 2],
        ['D aeolian', 'G mixolydian', 1],
        [null, 'D dorian', 0],
      ],
      closed: [
        [null, 'D phrygian', 0],
        [null, 'D aeolian', 0],
      ],
    }`}
  newValue={`{
      open: [
        ['D phrygian', 'G mixolydian', 2],
        ['D aeolian', 'G mixolydian', 1],
        ['D dorian', 'G mixolydian', 0],
      ],
      closed: [
        [null, 'D phrygian', 0],
        [null, 'D aeolian', 0],
        [null, 'D dorian', 0],
      ],
    }`}
  splitView={false}
  extraLinesSurroundingDiff={100}
  useDarkTheme={true}
  hideLineNumbers={true}
/>

<Graph
  json={{
    graph: {
      directed: true,
      nodes: [
        {
          label: 'start',
          id: '0',
        },
        {
          label: 'D phrygian',
          id: '0.0:D phrygian',
          fillcolor: '#f6afaf',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '0.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'D aeolian',
          id: '1.0:D aeolian',
          fillcolor: '#e5b380',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '1.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'D dorian',
          id: '2.0:D dorian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '2.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
      ],
      edges: [
        {
          source: '0',
          target: '0.0:D phrygian',
          label: '0',
        },
        {
          source: '0.0:D phrygian',
          target: '0.1:G mixolydian',
          label: '+2=2',
        },
        {
          source: '0',
          target: '1.0:D aeolian',
          label: '0',
        },
        {
          source: '1.0:D aeolian',
          target: '1.1:G mixolydian',
          label: '+1=1',
        },
        {
          source: '0',
          target: '2.0:D dorian',
          label: '0',
        },
        {
          source: '2.0:D dorian',
          target: '2.1:G mixolydian',
          label: '+0=0',
        },
      ],
    },
  }}
/>

At this state, all connection have reached "G mixolydian".
The last connection was the shortest, so we continue with that one:

<ReactDiffViewer
  oldValue={`{
      open: [
        ['D phrygian', 'G mixolydian', 2],
        ['D aeolian', 'G mixolydian', 1],
        ['D dorian', 'G mixolydian', 0],
      ],
      closed: [
        [null, 'D phrygian', 0],
        [null, 'D aeolian', 0],
        [null, 'D dorian', 0],
      ],
    }`}
  newValue={`{
      open: [
        ['D phrygian', 'G mixolydian', 2],
        ['D aeolian', 'G mixolydian', 1],
        ['G mixolydian', 'C lydian', 1],
        ['G mixolydian', 'C major', 0],
      ],
      closed: [
        [null, 'D phrygian', 0],
        [null, 'D aeolian', 0],
        [null, 'D dorian', 0],
        ['D dorian', 'G mixolydian', 0],
      ],
    }`}
  splitView={false}
  extraLinesSurroundingDiff={100}
  useDarkTheme={true}
  hideLineNumbers={true}
/>

<Graph
  json={{
    graph: {
      directed: true,
      nodes: [
        {
          label: 'start',
          id: '0',
        },
        {
          label: 'D phrygian',
          id: '0.0:D phrygian',
          fillcolor: '#f6afaf',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '0.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'D aeolian',
          id: '1.0:D aeolian',
          fillcolor: '#e5b380',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '1.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'D dorian',
          id: '2.0:D dorian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'G mixolydian',
          id: '2.1:G mixolydian',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
        {
          label: 'C lydian',
          id: '2.2:C lydian',
          fillcolor: '#b2e580',
          style: 'filled',
        },
        {
          label: 'C major',
          id: '3.2:C major',
          fillcolor: '#e9e93c',
          style: 'filled',
        },
      ],
      edges: [
        {
          source: '0',
          target: '0.0:D phrygian',
          label: '0',
        },
        {
          source: '0.0:D phrygian',
          target: '0.1:G mixolydian',
          label: '+2=2',
        },
        {
          source: '0',
          target: '1.0:D aeolian',
          label: '0',
        },
        {
          source: '1.0:D aeolian',
          target: '1.1:G mixolydian',
          label: '+1=1',
        },
        {
          source: '0',
          target: '2.0:D dorian',
          label: '0',
        },
        {
          source: '2.0:D dorian',
          target: '2.1:G mixolydian',
          label: '+0',
        },
        {
          source: '2.1:G mixolydian',
          target: '2.2:C lydian',
          label: '+1=1',
        },
        {
          source: '0',
          target: '2.0:D dorian',
          label: '0',
        },
        {
          source: '2.0:D dorian',
          target: '2.1:G mixolydian',
          label: '+0',
        },
        {
          source: '2.1:G mixolydian',
          target: '3.2:C major',
          label: '+0=0',
        },
      ],
    },
  }}
/>

Now our minimum open connection leads to the goal, which means we can stop here.
To get the actual path taken, we just need to retrace our steps by starting on the goal connection, tracing back the closed connections:

- `['G mixolydian', 'C major', 0]`
- `['D dorian', 'G mixolydian', 0]`
- `[null, 'D dorian', 0]`

we know that we are back at the start when we reach source null. In the right order, our steps were:

`D dorian -> G mixolydian -> C major`

That's the whole magic!

##

## Running On Real Tunes

Enough of the 251, let's look if this actually works on real tunes:

## Solar

export const solarChords = [
  'CmM7',
  'Gm7',
  'C7',
  'F^7',
  'Fm7',
  'Bb7',
  'Eb^7',
  'Ebm7',
  'Ab7',
  'Db^7',
  'Dm7b5',
  'G7b9',
  'CmM7',
];
export const solarScales = scaleModes('major', 'melodic minor', 'harmonic minor');
//export const solarScales = pentatonicScales;
//export const solarScales = ['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6', 'harmonic minor'];

<PathBuilder
  height={600}
  maxHeight={2000}
  noScroll={false}
  keepLongerPaths={false}
  onlyKeepWinner={true}
  view={'graph'}
  scales={solarScales}
  chords={solarChords}
/>

<details>
  <summary>show full graph</summary>

<Card elevation={3} >
<CardContent style={{ maxHeight: 500, overflow: 'auto'}}>
  <Graph
    options={{ fit: true, height: 1800, width: 620 }}
    json={{
      graph: {
        directed: true,
        ...chordScaleGraph(
          solarChords,
          solarScales
        ),
      },
    }}
  />
</CardContent>
</Card>
</details>
<br />

## How High The Moon

export const hhtm = ['G^7', 'Gm7', 'C7', 'F^7', 'Fm7', 'Bb7', 'Eb^7', 'Am7b5', 'D7b9', 'Gm7', 'Am7b5', 'D7b9'];
export const hhtmScales = scaleModes('major', 'melodic minor', 'harmonic minor');
//export const hhtmScales = ['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6'];

<PathBuilder
  height={600}
  maxHeight={2000}
  noScroll={false}
  keepLongerPaths={false}
  onlyKeepWinner={true}
  view={'graph'}
  scales={hhtmScales}
  chords={hhtm}
/>

<details>
  <summary>show full graph</summary>
  <Card elevation={3}>
    <CardContent style={{ maxHeight: 500, overflow: 'auto' }}>
      <Graph
        options={{ fit: true, height: 3000, width: 620 }}
        json={{
          graph: {
            directed: true,
            ...chordScaleGraph(hhtm, hhtmScales),
          },
        }}
      />
    </CardContent>
  </Card>
</details>
<br />

## All The Things You Are

export const attyaScales = scaleModes('major', 'melodic minor', 'harmonic minor');

export const attyaChords = [
  'Fm7',
  'Bbm7',
  'Eb7',
  'Ab^7',
  'Db^7',
  'Dm7',
  'G7',
  'C^7',
  'C^7',
  'Cm7',
  'Fm7',
  'Bb7',
  'Eb^7',
  'Ab^7',
  'Am7',
  'D7',
  'G^7',
  'G^7',
  'Am7',
  'D7',
  'G^7',
  'G^7',
  'F#h7',
  'B7b9',
  'E^7',
  'C7b13',
  'Fm7',
  'Bbm7',
  'Eb7',
  'Ab^7',
  'Db^7',
  'DbmM7',
  'Cm7',
  'Bo7',
  'Bbm7',
  'Eb7',
  'Ab^7',
  'Gh7',
  'C7b9',
];

<PathBuilder
  height={500}
  width={600}
  maxHeight={2000}
  noScroll={false}
  keepLongerPaths={false}
  onlyKeepWinner={true}
  view={'graph'}
  scales={attyaScales}
  chords={attyaChords}
/>
  
<details>
  <summary>show full graph</summary>

<Card elevation={3} >
<CardContent style={{ maxHeight: 500, overflow: 'auto'}}>
  <Graph
    options={{ fit: true, height: 3000, width: 620 }}
    json={{
      graph: {
        directed: true,
        ...chordScaleGraph(
          attyaChords,
          attyaScales
        ),
      },
    }}
  />
</CardContent>
</Card>
</details>
<br />

- TBD: calculate svg height based on longest path with "heightPerLevel" to adjust the height as needed
- TBD: colorize shortest path
- TBD: autoscroll to shortest leaf

## Links

- [Search: Optimal, Branch and Bound, Astar @MIT](https://www.youtube.com/watch?v=gGQ-vAmdAOI)
- https://github.com/dagrejs/graphlib/wiki/API-Reference

## TODO

- sort branches by lowest value first https://youtu.be/gGQ-vAmdAOI?t=1014 ?
- extend only if not already extended https://youtu.be/gGQ-vAmdAOI?t=1236
  - => add "extended" list (e.g `[[0,0],[1,0]]`)
  - dead horse principle
- think more about airline distance (can this be used with 0 distances??) https://youtu.be/gGQ-vAmdAOI?t=1680
  - maybe just use graph.length - path.length as distance to goal https://youtu.be/j1H3jAAGlEA?t=1879
- the case that shorter paths are extended after longer ones is a no case https://youtu.be/gGQ-vAmdAOI?t=2642
- maybe try beam search to also keep not so good paths, could use it with [min, max] to also throw away too smooth paths ! https://youtu.be/j1H3jAAGlEA?t=1978
