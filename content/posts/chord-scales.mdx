---
title: Chord Scales
date: 2021-01-04
---

import { Chord } from '@tonaljs/tonal';
import Tree from '../components/rhythmical/components/Tree.tsx';
import GraphvizJSON from '../components/graphs/GraphvizJSON.tsx';
import PathBuilder from '../components/graphs/PathBuilder.tsx';
import '../styles.css';
import scaleChroma from '../components/sets/scaleChroma';
import chromaDifference from '../components/sets/chromaDifference';
import reorderChroma from '../components/sets/reorderChroma';
import scaleModes from '../components/sets/scaleModes';
import chordScales from '../components/sets/chordScales';
import bySetNum from '../components/sets/bySetNum';
import chordScaleGraph from '../components/graphs/chordScaleGraph';
import scaleColor from '../components/sets/scaleColor';
import { Graphviz } from 'graphviz-react';
import { groupBy } from 'lodash';

To build a hackable backing track player, we already laid the foundation of [rhythm](../rhythmical-objects/) and [harmony](../rhythmical-chords/).
What's missing: Melodies.
Even if we just want a backing track player, playing melodies is required for basslines, or any kind of melodic fill in.

So far, we were generating voicings from chord symbols. The problem: melodies will eventually use notes that are not a chord note.
Therefore, we need a way to find scales that fit to chord changes.

TBD: show three circles with Dminor7 chord inside aeolian, dorian and phrygian

## Subsets and Supersets

To be able to find out which scales contain a chord, we need to understand the concept of subsets and supersets.
To fully understand this, I recommend you to read my [pitch class sets post](../pitch-class-sets/) first.

Sets can be related by being sub or supersets. For example, a C major chord is a subset of the C major scale. Also, the C major scale is a superset of a C major chord.
So, a superset contains all notes of its subset + some more, while a subset contains some of its superset (and no others!).

In tonal, we can check if [chromas](../pitch-class-sets/#chromas--set-numbers) are subsets or supersets:

```js
const isSupersetOfChord = (chord) => PcSet.isSupersetOf(Chord.get(chord).chroma);
isSupersetOfChord('M')(Scale.get('major').chroma); // true
isSupersetOfChord('M')(Scale.get('minor').chroma); // false

const isSubsetOfScale = (chord) => PcSet.isSubsetOf(Scale.get(chord).chroma);
isSubsetOfScale('major')(Chord.get('M').chroma); // true
isSubsetOfScale('major')(Chord.get('m').chroma); // false

const isChordScale = (scale, chord) => isSupersetOfChord(chord)(Scale.get(scale).chroma);
isChordScale('major', 'M'); // true
isChordScale('major', 'm'); // false

const isScaleChord = (chord, scale) => isSubsetOfScale(scale)(Chord.get(chord).chroma);
isScaleChord('M', 'major'); // true
isScaleChord('m', 'major'); // false
```

For a better understanding, let's implement our own isSuperset function:

```js
function isSuperset(superset, subset) {
  const superDec = parseInt(superset, 2);
  const subDec = parseInt(subset, 2);
  return (superDec | subDec) === superDec;
}
isSuperset(Scale.get('major').chroma, Chord.get('M').chroma); // true
isSuperset(Scale.get('major').chroma, Chord.get('m').chroma); // false
```

Here we are using a [bitwise OR operator](<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR#:~:text=The%20bitwise%20OR%20operator%20(%20%7C%20),both%20operands%20are%201%20s.>).
As bitwise OR expects a decimal input, we have to convert our chromas to decimal beforehand.
Now, if we apply the or between superset and subset, the superset will be the result if the subset has no additional ones!

For completeness, we can now implement isSubset, using isSuperset:

```js
function isSubset(subset, superset) {
  return isSuperset(superset, subset);
}
isSubset(Chord.get('M').chroma, Scale.get('major').chroma); // true
isSubset(Chord.get('m').chroma, Scale.get('major').chroma); // false
```

## Chord Scales

Now, if we want to know which scales we can play over a certain chord, we just have to look for supersets of the chords chroma. Luckily, there is already a method in tonal:

```js
Chord.chordScales('^7');
/*
[
  'ionian pentatonic',
  'lydian pentatonic',
  'augmented',
  'double harmonic lydian',
  'lydian',
  'augmented heptatonic',
  'harmonic major',
  'double harmonic major',
  'major',
  'lydian #9',
  'purvi raga',
  'bebop',
  'bebop major',
  'ichikosucho',
  'kafi raga',
  "messiaen's mode #3",
  'chromatic'
]
*/
```

To understand how it works, let's reimplent the above function:

```js
function getChordScales(chord) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return Scale.names().filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
getChordScales('^7');
```

### Filtering Choices

The above scale choices are pretty overwhelming. We could limit the checked scales like that:

```js
function getChordScales(chord, scales = Scale.names()) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return scales.filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
getChordScales('^7', ['major', 'minor', 'lydian']);
// ['lydian', 'major']
```

As we may want all modes of a certain scale family, we can spare us some typing with this:

```js
const oneOfModes = (families) => (scale) =>
  families.map((f) => Scale.get(f).normalized).includes(Scale.get(scale).normalized);
const scaleModes = (...families) => Scale.names().filter(oneOfModes(families));
scaleModes('major');
/*
[
  'lydian',
  'locrian',
  'phrygian',
  'aeolian',
  'dorian',
  'mixolydian',
  'major'
]
*/
getChordScales('^7', scaleModes('major', 'harmonic minor', 'melodic minor'));
// [ 'lydian', 'major', 'lydian #9' ]
```

We will look more closely at chord scales in a future post

## Hello 251

Let's start with the "Hello World" of jazz:

```js
const chords = ['Dm7', 'G7', 'C^7'];
chords.map((chord) => chordScales(chord, scaleModes('major')));
/*
[
  [ 'phrygian', 'aeolian', 'dorian' ],
  [ 'mixolydian' ],
  [ 'lydian', 'major' ]
]
*/
```

Here, we have 3 choices for Dm7, 1 choice for G7 and 2 choices for C^7.

The smoothest scale choice would be D dorian - G mixolydian - C major, because those scales share the exact same pitch classes.
How could an algorithm find this choice? And could the same chord progression potentially have multiple scale choices that fit?

### Scale Graph

We can visualize the transitions between the possible scales in a graph like this:

<!--<GraphvizJSON
  options={{ height: 800 }}
  json={{
    graph: {
      directed: true,
      ...chordScaleGraph(
        [
          'C^7',
          'F^7',
          'Bb^7',
          'Eb^7',
          'Ab^7',
          'Db^7',
          'Gb^7',
          'B^7',
          'E^7',
          'A^7',
          'D^7',
          'G^7',
          'C^7',
          'F^7',
          'Bb^7',
          'Eb^7',
        ],
        ['major']
      ),
    },
  }}
/>-->

<GraphvizJSON
  options={{ height: 300 }}
  json={{
    graph: {
      directed: true,
      ...chordScaleGraph(['Dm7', 'G7', 'C^7']),
    },
  }}
/>

The numbers are the difference of bits in the chroma of the scale.
We can use them to evaluate how smooth the scale transition will be.

### Choice Tree

Navigating the graph above, we can follow one of 6 possible paths:

export const treeNodes = [
  { label: 'start' },
  { label: 'D dorian' },
  { label: 'G mixolydian' },
  { label: 'C major' },
  { label: 'C lydian' },
  { label: 'D aeolian' },
  { label: 'G mixolydian' },
  { label: 'C major' },
  { label: 'C lydian' },
  { label: 'D phrygian' },
  { label: 'G mixolydian' },
  { label: 'C major' },
  { label: 'C lydian' },
].map((node, id) => ({ ...node, id, fillcolor: id !== 0 ? scaleColor(node.label) : 'white', style: 'filled' }));

export const edgeWithLabel = (edge) => ({
  ...edge,
  label:
    edge.source === 0
      ? ''
      : chromaDifference(scaleChroma(treeNodes[edge.source].label), scaleChroma(treeNodes[edge.target].label)),
});

<GraphvizJSON
  options={{ height: 300 }}
  json={{
    graph: {
      directed: true,
      nodes: treeNodes,
      edges: [
        { source: 0, target: 1 },
        { source: 0, target: 5 },
        { source: 0, target: 9 },
        { source: 1, target: 2 },
        { source: 2, target: 3 },
        { source: 2, target: 4 },
        { source: 5, target: 6 },
        { source: 6, target: 7 },
        { source: 6, target: 8 },
        { source: 9, target: 10 },
        { source: 10, target: 11 },
        { source: 10, target: 12 },
      ].map(edgeWithLabel),
    },
  }}
/>

Here, the leftmost path is the best, as its sum of values is 0. The worst path has a value of 6.

## Complex Example

The scale graph of "All the Things you Are" looks like this:

<div style={{ maxHeight: 500, width: 600, border: '1px solid black', borderRadius: 10, overflow: 'auto' }}>
  <GraphvizJSON
    options={{ fit: true, height: 3000, width: 600 }}
    json={{
      graph: {
        directed: true,
        ...chordScaleGraph(
          [
            'Fm7',
            'Bbm7',
            'Eb7',
            'Ab^7',
            'Db^7',
            'Dm7',
            'G7',
            'C^7',
            'C^7',
            'Cm7',
            'Fm7',
            'Bb7',
            'Eb^7',
            'Ab^7',
            'Am7',
            'D7',
            'G^7',
            'G^7',
            'Am7',
            'D7',
            'G^7',
            'G^7',
            'F#h7',
            'B7b9',
            'E^7',
            'C7b13',
            'Fm7',
            'Bbm7',
            'Eb7',
            'Ab^7',
            'Db^7',
            'Db-^7',
            'Cm7',
            'Bo7',
            'Bbm7',
            'Eb7',
            'Ab^7',
            'Gh7',
            'C7b9',
          ],
          ['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6']
        ),
      },
    }}
  />
</div>
<br />

<PathBuilder
  chords={[
    'Fm7',
    'Bbm7',
    'Eb7',
    'Ab^7',
    'Db^7',
    'Dm7',
    'G7',
    'C^7',
    'C^7',
    'Cm7',
    'Fm7',
    'Bb7',
    'Eb^7',
    'Ab^7',
    'Am7',
    'D7',
    'G^7',
    'G^7',
    'Am7',
    'D7',
    'G^7',
    'G^7',
    'F#h7',
    'B7b9',
    'E^7',
    'C7b13',
    'Fm7',
    'Bbm7',
    'Eb7',
    'Ab^7',
    'Db^7',
    'Db-^7',
    'Cm7',
    'Bo7',
    'Bbm7',
    'Eb7',
    'Ab^7',
    'Gh7',
    'C7b9',
  ]}
  scales={['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6']}
/>

[...scaleModes('major'),...scaleModes('harmonic minor')]

,...scaleModes('melodic minor')

<PathBuilder
  chords={['Dm7', 'G7', 'C^7', 'Cm7', 'F7', 'Bb^7', 'C#m7', 'F#7', 'B^7']}
  scales={['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6']}
/>

<PathBuilder
  chords={['C', 'F', 'G', 'C']}
  scales={['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6']}
/>

To have a scale for each chord, we allow the following scales:

```js
['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6'];
```

I won't render the choice tree here, as it would blow up everything..

### Chroma Difference

We can get the chroma difference like this:

```js
export const chromaDifference(a, b) => {
  let diff = 0;
  for (let i = 0; i < 12; ++i) {
    diff += a[i] === b[i] ? 0 : 1
  }
  return diff;
}
```

- [wasm graphviz](https://github.com/hpcc-systems/hpcc-js-wasm#graphviz) (used by d3-graphviz)
- [jgf-dot](https://github.com/jsongraph/jgf-dot)

### Rotations and Modes

Chromas can also be rotations of one another. Is mucial terms, we would call those modes:

```js
Scale.modeNames('C major').map(([root, scale]) => `${root} ${scale}`);
/*
[
  'C major',
  'D dorian',
  'E phrygian',
  'F lydian',
  'G mixolydian',
  'A aeolian',
  'B locrian'
]
*/
PcSet.modes(Scale.get('C major').chroma);
/*
[
  '101011010101',
  '101101010110',
  '110101011010',
  '101010110101',
  '101011010110',
  '101101011010',
  '110101101010'
]
*/
```

## Scales

Let's explore all scales, grouped by note number and shape:

<div>
  {Object.entries(groupBy(Scale.names(), (scale) => Scale.get(scale).intervals.length)).map(([l, scales], i) => (
    <React.Fragment key={i}>
      <h3>{l} notes</h3>
      <ul>
        {Object.entries(groupBy(scales.sort(bySetNum), (scale) => Scale.get(scale).normalized))
          .sort(([a], [b]) => b - a)
          .map(([setNum, scales], j) => (
            <li key={j}>
              <b>{parseInt(setNum, 2)}</b> {scales.join(', ')}
            </li>
          ))}
      </ul>
    </React.Fragment>
  ))}
</div>

```js
<div>
  {Object.entries(groupBy(Scale.names(), (scale) => Scale.get(scale).intervals.length)).map(([l, scales], i) => (
    <React.Fragment key={i}>
      <h3>{l} notes</h3>
      <ul>
        {Object.entries(groupBy(scales.sort(bySetNum), (scale) => Scale.get(scale).normalized)).map(
          ([setNum, scales], j) => (
            <li key={j}>
              <b>{parseInt(setNum, 2)}</b> {scales.join(', ')}
            </li>
          )
        )}
      </ul>
    </React.Fragment>
  ))}
</div>
```
