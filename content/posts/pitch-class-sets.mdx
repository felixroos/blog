---
title: Pitch Class Sets
date: 2020-11-26
---

import Button from '@material-ui/core/Button';
import ChromaticCircle from '../components/sets/ChromaticCircle.tsx';
import HarmonicCircle from '../components/sets/HarmonicCircle.tsx';
import ScalePicker from '../components/sets/ScalePicker.tsx';
import Grid from '@material-ui/core/Grid';
import Switch from '@material-ui/core/Switch';
import { Scale, Note, Range, PcSet, Chord } from '@tonaljs/tonal';
import { State } from 'react-powerplug';
import rotateTonic from '../components/sets/rotateTonic.ts';
import rotateMode from '../components/sets/rotateMode';
import scaleChroma from '../components/sets/scaleChroma';
import rotateScale from '../components/sets/rotateScale';
import transposeScale from '../components/sets/transposeScale.ts';
import simplifyScale from '../components/sets/simplifyScale.ts';
import bySetNum from '../components/sets/bySetNum.ts';
import { groupBy } from 'lodash';

export const oneOfModes = (families) => (scale) =>
  families.map((f) => Scale.get(f).normalized).includes(Scale.get(scale).normalized);
export const scaleModes = (...families) => Scale.names().filter(oneOfModes(families));
export const byCenter = (a, b) => Scale.get(a).setNum - Scale.get(b).setNum;
export const roots = ['C', 'C#', 'Db', 'D', 'D#', 'Eb', 'E', 'F', 'F#', 'Gb', 'G', 'G#', 'Ab', 'A', 'A#', 'Bb', 'B'];

Let's explore the world of pitch class sets.

## Harmonic & Chromatic Circles

There are (at least) two ways we can represent 12 notes in a circle:

<State initial={{ scale: 'C major', relative: false }}>
  {({ state, setState }) => {
    const tonic = state.scale.split(' ')[0];
    const scale = Scale.get(state.scale);
    const set = scale.notes.concat([tonic]).map((pc) => Note.get(pc).chroma);
    const pcset = PcSet.get(scale.notes);
    const scales = scaleModes('major', 'melodic minor').sort(byCenter);
    const setScale = (scale) => setState({ scale: simplifyScale(scale || state.scale) });
    return (
      <>
        <center>
          <Grid spacing={0} container style={{ width: '100%' }} alignItems="center">
            <Grid item xs={6}>
              <h3>Circle of Fifths</h3>
              <HarmonicCircle
                sets={[{ stroke: 'steelblue', set }]}
                pitches={scale.notes}
                tonic={scale.tonic}
                relative={state.relative}
              />
              <Button color="primary" onClick={() => setScale(rotateScale(state.scale, 5, scales))}>
                rotate scale
              </Button>
              <Button color="primary" onClick={() => setScale(rotateMode(state.scale, 5, scales))}>
                rotate mode
              </Button>
              <Button color="primary" onClick={() => setScale(transposeScale(5, state.scale))}>
                transpose
              </Button>
            </Grid>
            <Grid item xs={6}>
              <h3>Chromatic Circle</h3>
              <ChromaticCircle
                sets={[{ stroke: 'steelblue', set }]}
                pitches={scale.notes}
                tonic={scale.tonic}
                relative={state.relative}
              />
              <Button color="primary" onClick={() => setScale(rotateScale(state.scale, 1, scales))}>
                rotate scale
              </Button>
              <Button color="primary" onClick={() => setScale(rotateMode(state.scale, 1, scales))}>
                rotate mode
              </Button>
              <Button color="primary" onClick={() => setScale(transposeScale(-1, state.scale))}>
                transpose
              </Button>
            </Grid>
          </Grid>
          <ScalePicker scale={state.scale} onChange={(scale) => setState({ scale })} scales={scales} />
          <br />
          <label>
            absolute
            <Switch
              checked={state.relative}
              color="primary"
              onChange={(e) => setState({ relative: e.target.checked })}
            />
            relative
          </label>
          <br /> Chroma: {pcset.chroma} = {pcset.setNum} {/*pcset.normalized*/}
        </center>
      </>
    );
  }}
</State>

The blue line connects all pitches that are part of the selected scale. Using those representations, we can build a geometric intuition for musical phenomena.
In a nutshell, the circle of fifth helps to understand harmonic relationships, while the chromatic circle works better for melodic content.

## Chromas & Set Numbers

In the circles above, a so called chroma is displayed for each scale. A chroma is a format to represent a set of notes.
For example, the chroma of a C major scale is `101011010101`.

The idea: each digit stands for 1 of 12 possible pitches, where the first digit is C, then going chromatically up.
A 1 means that the pitch that is represented by the digit is in the set, a 0 means it is not.

A set number is just the decimal representation of a chroma:

<State initial={{ scale: 'major', root: 'C' }}>
  {({ state, setState }) => (
    <>
      <select value={state.root} onChange={(e) => setState({ root: e.target.value })}>
        {Note.names().map((note, index) => (
          <option key={index}>{note}</option>
        ))}
      </select>
      <select value={state.scale} onChange={(e) => setState({ scale: e.target.value })}>
        {['major', 'minor', 'dorian', 'mixolydian', 'harmonic minor', 'melodic minor'].map((scale, index) => (
          <option key={index}>{scale}</option>
        ))}
      </select> <pre>
        {Range.chromatic(['C3', 'B3'])
          .map((n) => Note.get(n))
          .map(({ pc, alt }) => (alt ? ' ' : pc))
          .join('')}{' '}
        = setNum
        <br />
        {PcSet.get(Scale.get(state.root + ' ' + state.scale).notes).chroma} ={' '}
        {PcSet.get(Scale.get(state.root + ' ' + state.scale).notes).setNum}
        <br />
        {Array.from({ length: Note.chroma(state.root) + 1 }).join(' ')}^
      </pre>
    </>
  )}
</State>

To find more about scale representations, be sure to check out [The Exciting Universe of Music Theory](https://ianring.com/musictheory/scales/#representing).
Unfortunately, the chromas and set numbers are reversed, which does not seem right to me. Read [these comments](https://www.youtube.com/watch?v=4MIVQqSOJU4&lc=Ugzl97yE7jsVWS9JLmd4AaABAg) to find out more.

### Chroma from Scale

To get the chroma for a given scale, we can do this:

```js
PcSet.get(Scale.get('D dorian')).chroma; // 101011010101
```

<!-- You might wonder why we do not use this:

```js
Scale.get('D dorian').chroma; // 101101010110
```

If you take a closer look at the chroma, you will notice that it represents C dorian, practially ignoring the "D", which is impractical for our purpose.
-->

<details>
  <summary>Why not Scale.get().chroma ?</summary>


Because it is always relative to C, ignoring the root of the scale:

```js
const scaleProps = Scale.get('G major');

scaleProps.chroma;
// '101011010101' => ingores G

PcSet.get(scaleProps.notes).chroma;
// '101011010101' => relative to G => correct
```

</details>
<br/>


### Scale from Chroma

As the opposite of the above, we might also want the scale for a given chroma:

```js
const chromaScale = (chroma, tonic, scaleTypes = Scale.names()) => {
  const type = scaleTypes.find((type) => scaleChroma(`${tonic} ${type}`) === chroma);
  if (type) {
    return `${tonic} ${type}`;
  }
  return '';
};
expect(chromaScale('101011010101', 'C')).toBe('C major');
expect(chromaScale('101011010101', 'D')).toBe('D dorian');
expect(chromaScale('101011010101', 'E')).toBe('E phrygian');
expect(chromaScale('101011010101', 'Eb')).toBe('');
```

### Chroma from Chord

Of course, we can also represent a chord as a chroma:

<State initial={{ chord: 'M', root: 'C' }}>
  {({ state, setState }) => (
    <>
      <select value={state.root} onChange={(e) => setState({ root: e.target.value })}>
        {Note.names().map((note, index) => (
          <option key={index}>{note}</option>
        ))}
      </select>
      <select value={state.chord} onChange={(e) => setState({ chord: e.target.value })}>
        {['M', 'm', '7', '^7', 'm7'].map((chord, index) => (
          <option key={index}>{chord}</option>
        ))}
      </select> <pre>
        {Range.chromatic(['C3', 'B3'])
          .map((n) => Note.get(n))
          .map(({ pc, alt }) => (alt ? ' ' : pc))
          .join('')}{' '}
        = setNum
        <br />
        {PcSet.get(Chord.get(state.root + ' ' + state.chord).notes).chroma} ={' '}
        {PcSet.get(Chord.get(state.root + ' ' + state.chord).notes).setNum}
        <br />
        {Array.from({ length: Note.chroma(state.root) + 1 }).join(' ')}^
      </pre>
    </>
  )}
</State>

## Set Types

Let's look at some common ways to understand sets:

export const smallCircle = { r: 80, nodeRadius: 16 };

### Modes

These are the 7 modes of C major:

export const scaleCircle = (scaleName) => {
  const scale = Scale.get(scaleName);
  const tonic = scaleName.split(' ')[0];
  const set = scale.notes.concat([tonic]).map((pc) => Note.get(pc).chroma);
  return { tonic, pitches: scale.notes, sets: [{ stroke: 'steelblue', set }], label: scaleName, ...smallCircle };
};

<ChromaticCircle {...scaleCircle('C major')} />
<ChromaticCircle {...scaleCircle('D dorian')} />
<ChromaticCircle {...scaleCircle('E phrygian')} />
<ChromaticCircle {...scaleCircle('F lydian')} />
<ChromaticCircle {...scaleCircle('G mixolydian')} />
<ChromaticCircle {...scaleCircle('A aeolian')} />
<ChromaticCircle {...scaleCircle('B locrian')} />

- All of the above resemble the same set (same pitches)
- Each set can be started at any contained pitch, which gives n modes for n pitch sets.

### Transpositions / Rotations

Transposing a set leads to rotation. These are the 12 major scales:

<ChromaticCircle {...scaleCircle('C major')} />
<ChromaticCircle {...scaleCircle('Db major')} />
<ChromaticCircle {...scaleCircle('D major')} />
<ChromaticCircle {...scaleCircle('Eb major')} />
<ChromaticCircle {...scaleCircle('E major')} />
<ChromaticCircle {...scaleCircle('F major')} />
<ChromaticCircle {...scaleCircle('F# major')} />
<ChromaticCircle {...scaleCircle('G major')} />
<ChromaticCircle {...scaleCircle('Ab major')} />
<ChromaticCircle {...scaleCircle('A major')} />
<ChromaticCircle {...scaleCircle('Bb major')} />
<ChromaticCircle {...scaleCircle('B major')} />

For some scales, there are less than 12 unique rotations, for example:

<ChromaticCircle {...scaleCircle('C whole tone')} />
<ChromaticCircle {...scaleCircle('Db whole tone')} />
<ChromaticCircle {...scaleCircle('D whole tone')} />

- The above example shows that there are just 2 whole tone scales
- After 2 rotations, we end up with D whole tone, which is a mode of C whole tone => same notes
- All symmetric scales will have less than 12 unique rotations

### Complements

A complement can be obtained by using the gaps of another set:

<ChromaticCircle {...scaleCircle('D major')} />
<ChromaticCircle {...scaleCircle('Ab pentatonic')} />

- Each set has exactly one complement

### Reflections

The reflection of a set can be generated by flipping it around:

export const relectedCircle = (scale, interval) => {
  const { sets, ...props } = scaleCircle(scale);
  const {
    sets: [{ set: intervalSet }],
  } = intervalCircle(interval);
  return {
    sets: sets.concat([{ set: intervalSet, stroke: 'black' }]),
    ...props,
  };
};


<p>reflect {scaleChroma('C major')} > {scaleChroma('Ab major')}</p>

<ChromaticCircle {...relectedCircle('C major', 'C 4A')} />
<ChromaticCircle {...relectedCircle('Ab major', 'C 4A')} />
<br />
<ChromaticCircle {...relectedCircle('Ab major', 'Ab 4A')} />
<ChromaticCircle {...relectedCircle('E major', 'Ab 4A')} />
<br />
<ChromaticCircle {...relectedCircle('E major', 'E 4A')} />
<ChromaticCircle {...relectedCircle('C major', 'E 4A')} />

Above, we are continuously reflecting around the root to get coltrane changes..
Flipping around the fifth gives us whole tone steps down:

<ChromaticCircle {...relectedCircle('C major', 'G 4A')} />
<ChromaticCircle {...relectedCircle('Bb major', 'G 4A')} />
<br />
<ChromaticCircle {...relectedCircle('Bb major', 'F 4A')} />
<ChromaticCircle {...relectedCircle('Ab major', 'F 4A')} />

Some reflections will even yield the same set:

<ChromaticCircle {...relectedCircle('C major', 'D 4A')} />
<ChromaticCircle {...relectedCircle('C major', 'D 4A')} />

Reflection by 4th:

<ChromaticCircle {...relectedCircle('C major', 'F 4A')} />
<ChromaticCircle {...relectedCircle('Gb major', 'F 4A')} />

TBD: 

- get reflection programmatically
- findSymbols(chroma) => ({scales,intervals,chords,pitches})

## How many sets are there?

In a binary number with 12 digits, we have 2^12 = 4096 different possibilities. As is this quite a lot, let's group similar sets to simplify things.

export const pitchCircle = (pitches) => {
  const tonic = pitches[0];
  const set = pitches.concat([pitches[0]]).map((pc) => Note.get(pc).chroma);
  return { tonic, pitches, sets: [{ stroke: 'steelblue', set }], label: pitches.join(' '), ...smallCircle };
};

### Single Pitch

With just one pitch, there is just one unique set:

<ChromaticCircle {...pitchCircle(['C'])} />

### Intervals

export const intervalCircle = (tonicAndinterval) => {
  const [tonic, interval] = tonicAndinterval.split(' ');
  const pitches = [tonic, Note.transpose(tonic, interval)];
  const set = pitches.map((pc) => Note.get(pc).chroma);
  return { tonic, pitches, sets: [{ stroke: 'steelblue', set }], label: tonicAndinterval, ...smallCircle };
};

Sets with 2 pitches represent intervals, with 6 unique ones:

<ChromaticCircle {...intervalCircle('C 2m')} />
<ChromaticCircle {...intervalCircle('C 2M')} />
<ChromaticCircle {...intervalCircle('C 3m')} />
<ChromaticCircle {...intervalCircle('C 3M')} />
<ChromaticCircle {...intervalCircle('C 4P')} />
<ChromaticCircle {...intervalCircle('C 4A')} />

- intervals >= perfect fifth are just the 2nd mode of the intervals inversion
- example: "C 5P" is the 2nd mode of "G 4P"

<!--
<ChromaticCircle {...intervalCircle('C 5P')} />
<ChromaticCircle {...intervalCircle('C 6m')} />
<ChromaticCircle {...intervalCircle('C 6M')} />
<ChromaticCircle {...intervalCircle('C 7m')} />
<ChromaticCircle {...intervalCircle('C 7M')} />
-->

### Triads

export const triadCircle = (triadName) => {
  const chord = Chord.get(triadName);
  const pitches = chord.notes;
  const set = pitches.concat([chord.tonic]).map((pc) => Note.get(pc).chroma);
  const r = 80;
  const nodeRadius = 16;
  return {
    tonic: chord.tonic,
    pitches,
    sets: [{ stroke: 'steelblue', set }],
    label: triadName,
    r,
    nodeRadius,
  };
};

Three pitches can represent triads:

<ChromaticCircle {...triadCircle('C')} />
<ChromaticCircle {...triadCircle('Cm')} />
<ChromaticCircle {...triadCircle('Co')} />
<ChromaticCircle {...triadCircle('Caug')} />

...and more:

<ChromaticCircle {...pitchCircle(['C', 'Db', 'D'])} />
<ChromaticCircle {...pitchCircle(['C', 'Db', 'Eb'])} />
<ChromaticCircle {...pitchCircle(['C', 'D', 'Eb'])} />
<ChromaticCircle {...pitchCircle(['C', 'Db', 'E'])} />
<ChromaticCircle {...pitchCircle(['C', 'D', 'E'])} />
<ChromaticCircle {...pitchCircle(['C', 'Eb', 'E'])} />
<ChromaticCircle {...pitchCircle(['C', 'Db', 'F'])} />
<ChromaticCircle {...pitchCircle(['C', 'D', 'F'])} />
<ChromaticCircle {...pitchCircle(['C', 'Eb', 'F'])} />
<ChromaticCircle {...pitchCircle(['C', 'E', 'F'])} />
<ChromaticCircle {...pitchCircle(['C', 'Db', 'Gb'])} />
<ChromaticCircle {...pitchCircle(['C', 'D', 'Gb'])} />
<ChromaticCircle {...pitchCircle(['C', 'Eb', 'Gb'])} />
<ChromaticCircle {...pitchCircle(['C', 'E', 'Gb'])} />
<ChromaticCircle {...pitchCircle(['C', 'F', 'Gb'])} />
<ChromaticCircle {...pitchCircle(['C', 'F', 'Gb'])} />
<ChromaticCircle {...pitchCircle(['C', 'Db', 'G'])} />
<ChromaticCircle {...pitchCircle(['C', 'D', 'G'])} />

## Subsets and Supersets

Sets can be related by being sub or supersets. For example, a C major chord is a subset of the C major scale. Also, the C major scale is a superset of a C major chord.
So, a superset contains all notes of its subset + some more, while a subset contains some of its superset (and no others!).

In tonal, we can check if chromas are subsets or supersets:

```js
const isSupersetOfChord = (chord) => PcSet.isSupersetOf(Chord.get(chord).chroma);
isSupersetOfChord('M')(Scale.get('major').chroma); // true
isSupersetOfChord('M')(Scale.get('minor').chroma); // false

const isSubsetOfScale = (chord) => PcSet.isSubsetOf(Scale.get(chord).chroma);
isSubsetOfScale('major')(Chord.get('M').chroma); // true
isSubsetOfScale('major')(Chord.get('m').chroma); // false

const isChordScale = (scale, chord) => isSupersetOfChord(chord)(Scale.get(scale).chroma);
isChordScale('major', 'M'); // true
isChordScale('major', 'm'); // false

const isScaleChord = (chord, scale) => isSubsetOfScale(scale)(Chord.get(chord).chroma);
isScaleChord('M', 'major'); // true
isScaleChord('m', 'major'); // false
```

For a better understanding, let's implement our own isSuperset function:

```js
function isSuperset(superset, subset) {
  const superDec = parseInt(superset, 2);
  const subDec = parseInt(subset, 2);
  return (superDec | subDec) === superDec;
}
isSuperset(Scale.get('major').chroma, Chord.get('M').chroma); // true
isSuperset(Scale.get('major').chroma, Chord.get('m').chroma); // false
```

Here we are using a [bitwise OR operator](<https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR#:~:text=The%20bitwise%20OR%20operator%20(%20%7C%20),both%20operands%20are%201%20s.>).
As bitwise OR expects a decimal input, we have to convert our chromas to decimal beforehand.
Now, if we apply the or between superset and subset, the superset will be the result if the subset has no additional ones!

For completeness, we can now implement isSubset, using isSuperset:

```js
function isSubset(subset, superset) {
  return isSuperset(superset, subset);
}
isSubset(Chord.get('M').chroma, Scale.get('major').chroma); // true
isSubset(Chord.get('m').chroma, Scale.get('major').chroma); // false
```

### Rotations and Modes

Chromas can also be rotations of one another. Is mucial terms, we would call those modes:

```js
Scale.modeNames('C major').map(([root, scale]) => `${root} ${scale}`);
/*
[
  'C major',
  'D dorian',
  'E phrygian',
  'F lydian',
  'G mixolydian',
  'A aeolian',
  'B locrian'
]
*/
PcSet.modes(Scale.get('C major').chroma);
/*
[
  '101011010101',
  '101101010110',
  '110101011010',
  '101010110101',
  '101011010110',
  '101101011010',
  '110101101010'
]
*/
```

## Scales

Let's explore all scales, grouped by note number and shape:

<div>
  {Object.entries(groupBy(Scale.names(), (scale) => Scale.get(scale).intervals.length)).map(([l, scales], i) => (
    <React.Fragment key={i}>
      <h3>{l} notes</h3>
      <ul>
        {Object.entries(groupBy(scales.sort(bySetNum), (scale) => Scale.get(scale).normalized))
          .sort(([a], [b]) => b - a)
          .map(([setNum, scales], j) => (
            <li key={j}>
              <b>{parseInt(setNum, 2)}</b> {scales.join(', ')}
            </li>
          ))}
      </ul>
    </React.Fragment>
  ))}
</div>

```js
<div>
  {Object.entries(groupBy(Scale.names(), (scale) => Scale.get(scale).intervals.length)).map(([l, scales], i) => (
    <React.Fragment key={i}>
      <h3>{l} notes</h3>
      <ul>
        {Object.entries(groupBy(scales.sort(bySetNum), (scale) => Scale.get(scale).normalized)).map(
          ([setNum, scales], j) => (
            <li key={j}>
              <b>{parseInt(setNum, 2)}</b> {scales.join(', ')}
            </li>
          )
        )}
      </ul>
    </React.Fragment>
  ))}
</div>
```

## Chord Scales

Now, if we want to know which scales we can play over a certain chord, we just have to look for supersets of the chords chroma. Luckily, there is already a method in tonal:

```js
Chord.chordScales('^7');
/*
[
  'ionian pentatonic',
  'lydian pentatonic',
  'augmented',
  'double harmonic lydian',
  'lydian',
  'augmented heptatonic',
  'harmonic major',
  'double harmonic major',
  'major',
  'lydian #9',
  'purvi raga',
  'bebop',
  'bebop major',
  'ichikosucho',
  'kafi raga',
  "messiaen's mode #3",
  'chromatic'
]
*/
```

To understand how it works, let's reimplent the above function:

```js
function getChordScales(chord) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return Scale.names().filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
getChordScales('^7');
```

### Filtering Choices

The above scale choices are pretty overwhelming. We could limit the checked scales like that:

```js
function getChordScales(chord, scales = Scale.names()) {
  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);
  return scales.filter((scale) => isSuperSet(Scale.get(scale).chroma));
}
getChordScales('^7', ['major', 'minor', 'lydian']);
// ['lydian', 'major']
```

As we may want all modes of a certain scale family, we can spare us some typing with this:

```js
const oneOfModes = (families) => (scale) =>
  families.map((f) => Scale.get(f).normalized).includes(Scale.get(scale).normalized);
const scaleModes = (...families) => Scale.names().filter(oneOfModes(families));
scaleModes('major');
/*
[
  'lydian',
  'locrian',
  'phrygian',
  'aeolian',
  'dorian',
  'mixolydian',
  'major'
]
*/
getChordScales('^7', scaleModes('major', 'harmonic minor', 'melodic minor'));
// [ 'lydian', 'major', 'lydian #9' ]
```

We will look more closely at chord scales in a future post

- [Combinatorial Music Theory](https://www.youtube.com/watch?v=OMDtp89Xqlw)
- [Basics of Set Theory](https://www.youtube.com/watch?v=GAWcpmLGJoA)

<!--

## todo

- [x] fix order of rotation (wrong for non diatonic scales)
- [x] add relative switch => show intervals instead of pitch class names
- [x] coherent coloring: pitch classes should always have the same color (across both circles)
- [x] two level scale sorting: sort first after number of notes, only if same number after the above
- [ ] different scale sortings: byScaleNum, byCenter, alphatbetically.
- show scale properties: chroma, scaleNum, accidentals, related scales, supersets, subsets
- show nearby scales: 1 altered note (1 added note, 1 removed note => already shown sub/supersets)
- handle unnamed scales: allow rotation into scales that do not have a name
- also allow chords + maybe intervals
- curved lines
- animation??
- add hotkeys 1-9 to play steps
-->
