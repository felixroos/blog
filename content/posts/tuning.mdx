---
title: Tuning Pitches
date: 2020-04-10
---

import { Plot } from "../components/common/Plot.tsx"
import Fab from "@material-ui/core/Fab"
import AddIcon from "@material-ui/icons/Add"
import CloseIcon from "@material-ui/icons/Close"
import Grid from "@material-ui/core/Grid"
import Button from "@material-ui/core/Button"
import IconButton from "@material-ui/core/IconButton"

import { Note } from "@tonaljs/tonal"
import { interpolateRainbow } from "d3-scale-chromatic"
import Strings from "../components/tuning/Strings.tsx"
import { PitchClasses } from "../components/tuning/PitchClasses.tsx"
import {
  stack,
  clamp,
  partials,
  frequencyColor,
  nearestPitch,
  maxFractionSize,
} from "../components/tuning/tuning"
import { gcd } from "../components/common/gcd"
import Switch from "@material-ui/core/Switch"

import { State } from "react-powerplug"
import { Slider as Sl } from "../components/common/Slider.tsx"
import Slider from "@material-ui/core/Slider"
import { Lambdoma } from "../components/tuning/Lambdoma.tsx"
import { LambdomaSettings } from "../components/tuning/LambdomaSettings.tsx"
import { Demo } from "../components/tuning/Demo.tsx"
import { LambdomaFloats } from "../components/tuning/LambdomaFloats.tsx"
import { Harmonics } from "../components/tuning/Harmonics.tsx"

import { FrequencyPlot } from "../components/tuning/FrequencyPlot.tsx"
import { FrequencyPlotSettings } from "../components/tuning/FrequencyPlotSettings.tsx"

import Typography from "@material-ui/core/Typography"

import SimplePopover from "../components/common/Popover.tsx"

import Divider from "@material-ui/core/Divider"
import List from "@material-ui/core/List"
import ListItem from "@material-ui/core/ListItem"
import ListItemIcon from "@material-ui/core/ListItemIcon"
import ListItemSecondaryAction from "@material-ui/core/ListItemSecondaryAction"
import ListItemText from "@material-ui/core/ListItemText"
import Monochord from "../components/tuning/Monochord.tsx"

<Monochord />

This post is about the fundamental questions of musical tuning:

- How to decide which pitches to use as material?
- Why are there 12 notes in (most) music? Is this arbitrary?

To teach myself d3, and play around with tunings, I did a few vizualisations.

## Physical Reasons

The fundamentals are laid in the way sound is generated by physical objects.

There are three basic units to talk about:

- **frequency**: How many vibrations per second (Hz)
- **wavelength**: How long are the oscillations (cm)
- **amplitude**: How loud is the oscillation? (dB)

[Read this](https://waitbutwhy.com/2016/03/sound.html) if you want to know more about the basics of sound.

### Theory of Strings

Lets take this string:

<FrequencyPlot
  height={150}
  frequencies={[[1, 1, 0]]}
  addSum={false}
  colors={["green"]}
  autostartAnimation={true}
  animationSpeed={1 / 500}
/>

Physically spoken, this is the point of maximal **potential energy**, and no **kinetic energy**.
It will now start accelerating down, reaching full kinetic energy here:

<FrequencyPlot
  height={50}
  frequencies={[[1, 0, 0]]}
  addSum={false}
  colors={["green"]}
/>

After this point, the kinetic energy will decrease again, and the potential energy will rise until the other end:

<FrequencyPlot
  height={150}
  frequencies={[[1, -1, 0]]}
  addSum={false}
  colors={["green"]}
/>

From there, the whole process will happen again in the other direction.

- One full cycle of string vibration is completed when the initial position (directly after plucking) is reached again.
- The sound is produced as the string pushes the air molecules around it

For the string, the basic units are:

- frequency = number of vibrations per second
- wavelength = 2\*length of string
- amplitude = distance from the initial pluck position to the rest position

#### Example

Lets say this is the string elongation (y axis) over the time period of 100 seconds (x axis):

<FrequencyPlot
  height={150}
  hideAxes={false}
  frequencies={[
    [1, 1, 0],
    [1, 0.5, 0],
    [1, 0, 0],
    [2, 1, 0],
  ]}
  colors={Array(10)
    .fill()
    .map((_, i) => interpolateRainbow(i / 10))}
  addSum={false}
/>

- green: 50Hz with amplitude of 100%
- red: 50Hz with amplitude of 50%
- blue: amplitude of 0% => frequency could be anything
- yellow: 100Hz with amplitude of 100%

### Reality of Strings

In reality, this pushing of air + dampening of the string leads to energy "loss", which will decrease the amplitude over time, eventually bringing it to rest.

Also, the string will not vibrate with a single frequency, but with multiple ones that are superimposed.
It depends on the material which frequencies are heard, but there is also a simple principle that is shared by not only strings, but all physical objects that vibrate:

## Overtones

Above the **fundamental frequency**, additional higher frequencies can occur simultaneously.
These higher frequencies are called **overtones**.
Strings and other so called standing waves (like created in air tubes) create a specific set of overtones called **the Harmonic Series**:

### The Harmonic Series

The Harmonic Series is a set of overtones that multiply the fundamental frequency by natural numbers:

<State initial={{ partials: 5, damp: 75, speed: 50 }}>
  {({ state, setState }) => <Harmonics state={state} setState={setState} />}
</State>

The x position shows the frequency while the length is the amplitude, which is dampened for higher frequencies.
This is also mostly the case on real objects.

## Harmonic Ratios

We can now look at the ratios between the harmonic partials.

### wavelength vs frequency ratio

Before we get started, a note on forming ratios:

- If we form the ratio between two partials, we can either look at the frequency or the wavelength ratio.
- To get from line 1 to line 2, we either multiply the frequency by 2 or divide the wavelength by 2.
- So for the wavelength, the ratio would be 1:2 and for the frequency 2:1
- We will proceed with frequency ratios as they relate to the change in pitch

### The octave

The lines 1 and 2 are at the ratio of 2:1, which forms the octave.
This is the most fundamental ratio, as it consists of the smallest possible unequal natural numbers.
It's so fundamental, that we perceive the pitches as having the same quality.
That's why notes which are an octave apart are named with same letter.

> So if we multiply or divide any frequency by 2, we get the same pitch quality.
> A collection of pitches that share the same quality are called pitch classes.

In mathematical terms, we could say that all frequencies produced by `m*2^n` share the same pitch class, where m is constant and n a natural number.

<State initial={{ partials: 5 }}>
  {({ state, setState }) => {
    const base = Note.freq("C2")
    const freqs = partials([1, state.partials], base)
    return (
      <>
        <PitchClasses
          base={base}
          strokeWidth={4}
          frequencies={partials([1, state.partials], base)}
        />
        <label>
          <Slider
            min={2}
            max={12}
            value={state.partials}
            onChange={(e, partials) => setState({ partials })}
          />
          {state.partials} Partials
        </label>
      </>
    )
  }}
</State>

### Colorization

Based on the fact that octaves share the same quality, the colorization works like this:

```js
function frequencyColor(frequency) {
  const fraction = Math.log(frequency / 440) / Math.log(2)
  return interpolateRainbow(fraction % 1)
}
```

### The fifth

The lines 2 and 3 form the ratio 3:2.
This interval is the fifth. While the octave (2:1) is perceived as the same pitch quality,
the fifth (3:2) is the first interval that introduces a new quality.

> It may sound esoteric, but you can imagine the first two partials as the parents, while the third is their first child.

### The fourth

The lines 3 and 4 form the ratio 3:4 (frequency), which is the fourth.
The fourth is complementary to the fifth, as you could multiply:

> 2/3 \* 3/4 = 6/12 = 1/2

> The fourth is like the dark brother of the fifth, born in the undertone series.

### Prime Numbers

If we look at all the numbers that introduce a new quality (= new color), we notice that they are prime numbers.
This is due to the fact that non prime numbers could be partitioned into ratios that already appeared before.

### The major third

The major third comes from the partial number 5, which is next prime number.
The ratio 4:5 therefor is the major third.
We can see that the major triad is manifested directly inside the harmonic series.
This major triad feels a little too low for a person that is accustomed to the equal temperament (more on that later).

### More ratios

- 3:5 = major sixth
- 5:6 = minor third
- 7:8 = major second
- 5:7 = tritone

## Old chinese tuning system

We can now construct tuning systems by stacking intervals. One of the oldest and simplest tuning systems is [the pythagorean tuning](https://en.wikipedia.org/wiki/Pythagorean_tuning).
It works by stacking fifths, which means multiplying repeatedly by 3/2:

```js
// stacks n partials by a fixed interval (factor) ontop of each other
export function stack(n, factor = 3 / 2, base = 440) {
  const f = [base]
  for (let i = 1; i < n; ++i) {
    f.push(f[f.length - 1] * factor)
  }
  return f
}
```

```js
<Strings frequencies={stack(8, 3 / 2, Note.freq("C3"))} />
```

<Strings frequencies={stack(8, 3 / 2, Note.freq("C3"))} />

This "scale" doesn't sound lovely, we should clamp the frequencies to stay in one octave:

```js
export function clamp(frequency, base) {
  if (frequency > base * 2) {
    return clamp(frequency / 2, base)
  }
  if (frequency < base) {
    return clamp(frequency * 2, base)
  }
  return frequency
}
```

This function guarantees that the outputted frequency is between base and base\*2 (which is one octave).

```js
<Strings
  frequencies={stack(5, 3 / 2, Note.freq("C3"))
    .map((f) => clamp(f, Note.freq("C3")))
    .concat(Note.freq("C4"))}
/>
```

This is what we get:

<State initial={{ partials: 5, factor: 3 / 2 }}>
  {({ state, setState }) => {
    const factors = {
      fifths: 3 / 2,
      fifthsDown: 2 / 3,
      fourths: 4 / 3,
      sixths: 5 / 3,
      thirds: 5 / 4,
      minorSevenths: 7 / 4,
      minorThirds: 6 / 5,
      augmentedFourths: 7 / 5,
      minorSevenths2: 9 / 5,
    }
    const base = Note.freq("C4")
    const fractions = stack(state.partials, factors[state.factor], 1)
      .map((f) => clamp(f, 1))
      .concat([2])
    const frequencies = fractions.map((f) => f * base)
    return (
      <>
        <Strings frequencies={frequencies} />
        <br />
        <select
          value={state.factor}
          onChange={(e) => setState({ factor: e.target.value })}
        >
          {Object.keys(factors).map((name) => (
            <option key={name} value={name}>
              {name}
            </option>
          ))}
        </select>
        <label>
          <input
            min="1"
            max="53"
            style={{ width: 400 }}
            type="range"
            value={state.partials}
            step="1"
            onChange={(e) => setState({ partials: parseInt(e.target.value) })}
          />
          {state.partials} partials
        </label>
        {/* <br />
        <LambdomaFloats floats={fractions} base={base} size={10} /> */}
      </>
    )
  }}
</State>

Those are only 5 partials. Those 5 are a major pentatonic scale. Now try ramping up the slider until the scale looks good..
We can see that it looks even at 12 partials, and above, it starts do double. The next even point is reached at 53 partials.

So this is the reason we divide the octave into 12 notes!

TBD
cent values
circle visualization
monochord with draggable lenghts
prime numbers
fraction table
2^n explanation
try tune.js
links
https://de.wikipedia.org/wiki/Pythagoreische_Stimmung
http://www.harmonik.de/harmonik/vtr_volltext.html !!
https://www.youtube.com/watch?v=IT9CPoe5LnM
https://music.stackexchange.com/questions/24/why-are-there-twelve-notes-in-an-octave
https://observablehq.com/@d3/continuous-scales
https://www.youtube.com/watch?v=XPbLYD9KFAo
https://www.youtube.com/watch?v=JDFa8TSn6vY
https://www.youtube.com/watch?v=Gt2zubHcER4 bernstein music history by overtones
https://observablehq.com/@d3/learn-d3-scales?collection=@d3/learn-d3

## The Lambdoma

A good way to look at the distribution of ratios is the Lambdoma

<State
  initial={{
    angle: 0,
    radius: 20,
    size: 8,
    hideExtensions: false,
    hideLines: false,
    hideZeroes: false,
    clamp: false,
  }}
>
  {({ state, setState }) => (
    <>
      <SimplePopover placement="left-start">
        <LambdomaSettings state={state} setState={setState} />
      </SimplePopover>
      <Lambdoma
        margin={0}
        cols={state.size}
        rows={state.size}
        angle={state.angle}
        radius={state.radius}
        base={Note.freq("C4")}
        clamp={state.clamp}
        hideExtensions={state.hideExtensions}
        hideLines={state.hideLines}
        hideZeroes={state.hideZeroes}
      />
    </>
  )}
</State>

This will give all frequencies of the same pitch class the same color.

## Clamping to one Octave

Now we want to investigate what happens

Note that the x axis is scaled by log(2) so that doubled frequencies have the same distance. This can be done easily with d3-scale:

```ts
import { scaleLinear } from "d3-scale"
const x = scaleLog()
  .base(2)
  .domain([min(frequencies), max(frequencies)])
  .range([margin.left, size.width - margin.right - strokeWidth])
  .interpolate(interpolateRound)
```

Lets clamp the overtone series to remain in one octave. We can do this by dividing frequencies by 2 until they are below the octave frequency.

<State initial={{ partials: 5 }}>
  {({ state, setState }) => (
    <>
      <Strings
        frequencies={Array.from(
          { length: state.partials },
          (_, i) => (i + 1) * Note.freq("C3")
        )
          .map((f) => clamp(f, Note.freq("C3")))
          .concat(Note.freq("C4"))}
      />
      <label>
        <Slider
          min={2}
          max={64}
          value={state.partials}
          onChange={(e, partials) => setState({ partials })}
        />
        {state.partials} Partials
      </label>
    </>
  )}
</State>

<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700&display=swap"
/>
<link
  rel="stylesheet"
  href="https://fonts.googleapis.com/icon?family=Material+Icons"
/>

<State initial={{ partials: 8, size: 20, clamp: true }}>
  {({ state, setState }) => {
    const base = Note.freq("A4")
    let fractions = partials(
      [-state.partials, state.partials],
      1
    ).map((fract) => (!state.clamp ? fract : clamp(fract, 1)))
    const freqs = fractions.map((fraction) => fraction * base)
    return (
      <>
        <SimplePopover>
          <label>
            partials: {state.partials}
            <Slider
              min={1}
              max={24}
              value={state.partials}
              onChange={(e, partials) => setState({ partials })}
            />
          </label>
          <label>
            radius: {state.size}
            <Slider
              min={1}
              max={30}
              value={state.size}
              onChange={(e, size) => setState({ size })}
            />{" "}
          </label><label>
            clamp
            <Switch
              checked={state.clamp}
              color="primary"
              onChange={(e) => setState({ clamp: e.target.checked })}
            />
          </label>
        </SimplePopover>
        <Strings frequencies={freqs} />
        <br />
        <LambdomaFloats floats={fractions} base={base} size={state.size} />
      </>
    )
}}

</State>

## Overtones vs Undertones

Lets generate the frequencies of pitches in the overtone and undertone series.
It works by taking a base frequency and either multiplying (overtones) or dividing it (undertones) by natural numbers from 1 to n.
This can be unified by multiplying with 2 to the power of n, where n can also be negative:

```js
import { Note } from "@tonaljs/tonal"

export function partials([min, max], base = 440) {
  const f = []
  for (let i = min - 1; i <= max + 1; ++i) {
    if (i !== 0) {
      f.push(base * (i < 0 ? -1 / i : i))
    }
  }
  return f.filter((f, i, a) => a.indexOf(f) === i)
}

const first5overtones = partials([1, 5], Note.freq("A4"))
// = [440, 880, 1320, 1760, 2200]
const first5undertones = partials([-5, 0], Note.freq("A4"))
// = [440, 220, 146.66666666666666, 110, 88]
```

More Links:

Fourier: https://www.youtube.com/watch?v=spUNpyF58BY
Fourier Viz + more: https://jackschaedler.github.io/circles-sines-signals/dft_introduction.html
