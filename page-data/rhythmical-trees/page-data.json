{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/rhythmical-trees/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"a5b9862e-ecf2-5460-ab4b-a9e8ed03ad1a","excerpt":"After the posts about  Rhythmical Arrays  and  Rhythmical Objects ,\nI want to investigate the actual data structure that is at play: treesâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar colors = schemeTableau10;\nvar _8 = ['hh', 'hh', 'hh'];\nvar _4 = [_8, _8];\nvar _1 = [_4, _4, _4];\nvar _b = [_1, _1];\nconsole.log(_b);\n\nvar parentTree = function parentTree(node, visited) {\n  return r2d3(bolero, function (rhythm, path, parent) {\n    var isSelected = haveSameIndices(node === null || node === void 0 ? void 0 : node.path, path);\n\n    var strPath = function strPath(p) {\n      return (p === null || p === void 0 ? void 0 : p.map(function (s) {\n        return s.join('/');\n      }).join(' ')) || '';\n    };\n\n    var color = 'darkgray';\n    var isRoot = !path.length;\n    var isVisited = visited.find(function (v) {\n      return haveSameIndices(v.path, path);\n    });\n\n    if (isVisited) {\n      color = 'lightgray';\n    }\n\n    if (isSelected) {\n      color = 'red';\n    }\n\n    var isParent = strPath(node === null || node === void 0 ? void 0 : node.path).startsWith(strPath(path));\n\n    if (isParent && !isSelected) {\n      color = isRoot ? 'darkgray' : 'red';\n    }\n\n    return _objectSpread(_objectSpread({}, toRhythmObject(rhythm)), {}, {\n      color: color,\n      name: parent ? path[path.length - 1].join('/') : '/',\n      path: _toConsumableArray(path)\n    });\n  });\n};\n\nvar _frontmatter = {\n  \"title\": \"Rhythmical Trees\",\n  \"date\": \"2021-04-30T00:00:00.000Z\",\n  \"keywords\": [\"rhythmical\", \"draft\"]\n};\nvar layoutProps = {\n  colors: colors,\n  _8: _8,\n  parentTree: parentTree,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"After the posts about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-arrays/\"\n  }, \"Rhythmical Arrays\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-objects\"\n  }, \"Rhythmical Objects\"), \",\\nI want to investigate the actual data structure that is at play: trees.\\nThis is an attempt to explain why trees are a really elegant way to represent rhythm and music.\"), mdx(\"h2\", {\n    \"id\": \"tree-basics\"\n  }, \"Tree Basics\"), mdx(\"p\", null, \"This is a tree:\"), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"706px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"88.69565217391305%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAAE6UlEQVQ4yx2TaUyUVxSGv99Nq01rY6LFGcqwjriAUAYBgWHYEWYGGGBgpsi+KgzIDloXxgUtWqumLogLIosCWqu1ttrShjBQ1ArCqEDRpvqjsYuJiWmeXvnx5H65yXnvec97Pik05yTq3DbUeW1o8k8RVtAuOIe6sIvo0m4Syo+hrzhAfFkbceUXidl0WZz9JFh60VZcQlfZh35zP0lVl0mpvoKkKTxNeJGguIPojR2i4JwQOUJKeSUZFUWYi1aRu0lJriWQTIuBwsZ8jFX7SBbFhpoBUmuvkF5/VfC14BpSdOkboQvEiQ6Si5MwbQwjvdiftFxXzAVOGDLdiNS6sD7FGVOeK9klyzAWrMPc1I+p6QamxmsUNd+g/sD3lFpvImkrOtFuvkpaZQ3GnMUkb1CgNyvIyFPOd5ZsdiEyXoF/iJy4FFd8g2REGwIpaUin4NNDZO8YJHv7TQqtt6jcdxspte4KGfWtmEuVGLLc5jvRJMgJDJMTpXPCN/hDvP1lrE9yQxXiSEiMO1F6L/I3xmC2bKSoZYiSvbep+/wnDp4eQjI2fkN6ZSaGbAdMhQGExrrh5e+A3ihsGjxQhcoI1DjirZLjvkrGch85azVKCixBZJZrKWsdpPrwPaoODVPzxTDSri+/o2zHfnQmd6L1Qky1FL9gRwJE0QofGWvVchJNzmQWK4lP8UCbtoKENA9SspToMoRwbSqWluNsPjwmuIN0YWCU1mPNJJnlhEatJk4fhDrWC1WYG8ERMmKTXAkKV4hgFGSWKMkpWy7su6MT4hFaDxLNXmRZkmk4foemkxNIlc0WcsqDyNtkQGfUkLpBQ2yyO4ZPZELECa+1jkTrXPAPdcQvVIxA7SgekGPK8WC90YuAGA2miq1sP/eYbWfsSHX7DmEqVomX16COcxRJygmJFkURzsSnOgm7rsSIQFZ9LCMkSgQW64ou3UuMSCQe6klEYiQ5lYXs77LzWe8M0oGucYqbDETol4j0nAiMVOC7TkFMojORCS5C/CMi17vhuVouECuj80QdvRJPHweUvnKS0sNpPWLl6R8v+HXqCdL1H4Ypqg4jIdVBWPYgPM4TfbrowignXAgFaN6krSBf7GR88koCQ3zwUbkSpw1ilZ+CpIxwTrQd5L/Xr3j96iVSW98lssoC0eiWExTpTYpZK5JVEha3koh4d1b7ylDHOAmbYrENy/AOcGC1nyvW3VvJykujbks5d8aG+PfvF7z85y+k++M2rl7v5ODRLVwc6KKj9zxbdzbQ2d1JaUUpxiwTMsUi8aeoSM81itUJQBW8hqaWVnpujXOi71vGHj3n/swz7HPPkSYmxph+PMHUwwnsj+1M2cfFOcXUo8n57+m5ORJT49myrZ7J6TkGh4b42WbDdm+CUfvvjD18ysSjWe7aZxmdnEUatQ0xMjKEzTbM8MgItl/uMDR6j8GRcX60jTPz5DllFgsV1TU8efYn9x7McHdyTgTwG3cnprk/Oc0D+wwPpmaZFHdSR882ui5Z6enfM09X327O91o52/2GZtovWIlK8CZWv5ZjZ3dxtH0nJ85bOdG5i1Nde2nvauFMzz66B1q5+NVBpIqdb1HZ/DZV1oVUW9+hdvfCeWp2vStYSFXzAup2L6Juz/tU71xArfVd6ve8R8PeRTTu/UCwWMxzCVv3L2Vb61L+B7cVRIBuEDpQAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"tree\",\n    \"title\": \"tree\",\n    \"src\": \"/blog/static/b788ab9992d729993e7e0e73bbc7d82e/9f21b/tree.png\",\n    \"srcSet\": [\"/blog/static/b788ab9992d729993e7e0e73bbc7d82e/e4d6b/tree.png 345w\", \"/blog/static/b788ab9992d729993e7e0e73bbc7d82e/1e043/tree.png 690w\", \"/blog/static/b788ab9992d729993e7e0e73bbc7d82e/9f21b/tree.png 706w\"],\n    \"sizes\": \"(max-width: 706px) 100vw, 706px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \")), mdx(\"p\", null, \"Now if we turn this upside down, cut of the stem and draw it like a 3 year old, we get what computer scientists call a tree:\"), mdx(TreeAnalyzer, {\n    data: {\n      name: '1',\n      children: [{\n        name: '2',\n        children: [{\n          name: '5'\n        }, {\n          name: '6'\n        }]\n      }, {\n        name: '3',\n        children: [{\n          name: '7'\n        }, {\n          name: '8'\n        }]\n      }, {\n        name: '4',\n        children: [{\n          name: '9'\n        }, {\n          name: '10'\n        }]\n      }]\n    },\n    hideJson: true,\n    mdxType: \"TreeAnalyzer\"\n  }), mdx(\"p\", null, \"You can learn the basic terminology by exploration. Just click on different nodes and watch what happens. The color coding should explain itself. If not\\u2026\"), mdx(\"details\", null, mdx(\"summary\", null, \"show explanation\"), mdx(\"h3\", null, \"Terminology\"), mdx(\"p\", null, \"Trees are commonly explained using the following terminology:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"nodes: points of data that are hierarchically linked (circles)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"links: connections between nodes (lines)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"parents: nodes that contain children\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"children: nodes that have a parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"root: the uppermost node (1 per tree), it is the only node without a parent\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"leaves: nodes without children\")), mdx(\"p\", null, \"It is common to draw the tree upside down, with the root at the top and the leaves at the bottom.\"), mdx(\"p\", null, \"I implemented the above tree using a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/d3/d3-hierarchy#cluster\"\n  }, \"d3 cluster\")), mdx(\"p\", null, \"We can represent the above tree with the following object\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"{\\n    name: '1',\\n    children: [\\n      { name: '2', children: [{ name: '5' }, { name: '6' }] },\\n      { name: '3', children: [{ name: '7' }, { name: '8' }] },\\n      { name: '4', children: [{ name: '9' }, { name: '10' }] },\\n    ],\\n  }\\n\"))), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"visual-tree-vs-score\"\n  }, \"Visual: Tree vs Score\"), mdx(\"p\", null, \"Let\\u2019s ignite a visual explosion of a score notation, using the common Bolero rhythm as an example:\"), mdx(Tree, {\n    width: 620,\n    nodeRadius: 10,\n    dx: 20,\n    columns: [12, 12],\n    data: r2d3(bolero, function (rhythm, path) {\n      return _objectSpread(_objectSpread({}, toRhythmObject(rhythm)), {}, {\n        color: path.length ? colors[path.length - 1] : 'black',\n        name: conventionalLabels[path.length]\n      });\n    }),\n    hideJson: true,\n    mdxType: \"Tree\"\n  }), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1380px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"18.84057971014493%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAIAAAABPYjBAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA80lEQVQI1w3OTVOCQACAYf7/H2g61AGmYhBI0jWn0Q40LrCJCWaOIh+mrgnaLvjRDAxuzDyn9/RyjLGiKALfQ6aRUvK9iCwDUkLin01ZllWx+yjw56fjoY+sRRRWPkeuM/zwZlMOwp47nuimfX0rdHVoDkZXN3xHh8Px1A8CdzKX6kAQFedrJqpN6bEpa60H5akiynVuhbE3QIZ6b2oSaoN3oEDlzmo13O4z3e+cDujVeKOh2i8AyoIJNKjVLE18k3jntc1V2yz/OyfrXxwVB5LTeLfy82zPTpRdysuRUBym8ZqdU4LDLMF0u8y2S4KjLNn8A3bmxdyG249QAAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"bolero\",\n    \"title\": \"bolero\",\n    \"src\": \"/blog/static/9d2640000b356a9d1a69e6439921ac36/b1001/bolero34.png\",\n    \"srcSet\": [\"/blog/static/9d2640000b356a9d1a69e6439921ac36/e4d6b/bolero34.png 345w\", \"/blog/static/9d2640000b356a9d1a69e6439921ac36/1e043/bolero34.png 690w\", \"/blog/static/9d2640000b356a9d1a69e6439921ac36/b1001/bolero34.png 1380w\", \"/blog/static/9d2640000b356a9d1a69e6439921ac36/29007/bolero34.png 1600w\"],\n    \"sizes\": \"(max-width: 1380px) 100vw, 1380px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \")), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"color\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"value\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"type\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"amount\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"visual cue\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[0],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3/4\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"bar\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2 total\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"seperated by vertical lines\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[1],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1/4\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"4ths\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3 per bar\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"separated by space\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[2],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1/8\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"8ths\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"2 per 4th\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"connected by first beam\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[3],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1/24\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"16th triplets\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3 per 8th\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"connected by second beam\")))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The tree essentially contains the same information as the score, though using less visual encoding (taking more space).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each group represents different subdivisions of time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each member of a group (color) takes the same amount of time!\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each fraction is the duration of the member, relative to the length of 4/4\")), mdx(\"h2\", {\n    \"id\": \"aural-hearing-the-layers-of-rhythm\"\n  }, \"Aural: Hearing the Layers of Rhythm\"), mdx(\"p\", null, \"As we are talking about music, let\\u2019s make the tree layers audible:\"), mdx(Player, {\n    instruments: {\n      drums: drums\n    },\n    hierarchy: true,\n    height: 25,\n    fold: false,\n    center: 0,\n    events: renderRhythm(colorize({\n      duration: 6,\n      parallel: [_b, [[['ht', 'ht'], ['ht', 'ht'], ['ht', 'ht']], [['ht', 'ht'], ['ht', 'ht'], ['ht', 'ht']]], [['mt', 'mt', 'mt'], ['mt', 'mt', 'mt']], ['lt', 'lt']]\n    }, ['black'].concat(_toConsumableArray(colors)))),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"Using the same color coding as above, we now use a different sound for each layer of the tree:\"), mdx(\"table\", null, mdx(\"thead\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"thead\"\n  }, mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"color\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"value\"), mdx(\"th\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"sound\"))), mdx(\"tbody\", {\n    parentName: \"table\"\n  }, mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[0],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"3/4\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"low tom\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[1],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1/4\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"middle tom\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[2],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1/8\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"high tom\")), mdx(\"tr\", {\n    parentName: \"tbody\"\n  }, mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, mdx(Color, {\n    color: colors[3],\n    mdxType: \"Color\"\n  })), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"1/24\"), mdx(\"td\", {\n    parentName: \"tr\",\n    \"align\": null\n  }, \"hi hat\")))), mdx(\"p\", null, \"The actual bolero rhythm just switches between different layers:\"), mdx(Player, {\n    instruments: {\n      drums: drums\n    },\n    hierarchy: true,\n    height: 25,\n    fold: true,\n    center: 0,\n    events: renderRhythm(colorize({\n      duration: 6,\n      sequential: bolero\n    }, colors)),\n    mdxType: \"Player\"\n  }), mdx(\"h2\", {\n    \"id\": \"textual-nested-vs-flat\"\n  }, \"Textual: Nested vs Flat\"), mdx(\"p\", null, \"Let\\u2019s oppose two possible textual representations of the bolero:\"), mdx(\"h3\", {\n    \"id\": \"nested\"\n  }, \"Nested\"), mdx(\"p\", null, \"As JSON, this is the most compact and readable version I can think of:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  [\\n    [\\\"sn\\\", [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"]],\\n    [\\\"sn\\\", [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"]],\\n    [\\\"sn\\\", \\\"sn\\\"],\\n  ],\\n  [\\n    [\\\"sn\\\", [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"]],\\n    [\\\"sn\\\", [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"]],\\n    [[\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"], [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"]],\\n  ],\\n];\\n\")), mdx(\"p\", null, mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"1380px\"\n    }\n  }, \"\\n      \", mdx(\"span\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"11.884057971014492%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0\",\n      \"left\": \"0\",\n      \"backgroundImage\": \"url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAIAAADXZGvcAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAaUlEQVQI1yWKTQpAERhF7X8nSjKRiaJkBaRMGAnJ7wreV2927jkXlVKcczlnay0hJMaotWaMhRBSSr13YwzGGFhKKYRQSnHOKaXg0d7be19rfe/Bdc557x1jAJxzoMIEv9aCCbK19htIH2RKZgEfo630AAAAAElFTkSuQmCC')\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  }), \"\\n  \", mdx(\"img\", {\n    parentName: \"span\",\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"bolero\",\n    \"title\": \"bolero\",\n    \"src\": \"/blog/static/d1f0b46ba14623b18acf5ea57c44f0b2/b1001/bolero.png\",\n    \"srcSet\": [\"/blog/static/d1f0b46ba14623b18acf5ea57c44f0b2/e4d6b/bolero.png 345w\", \"/blog/static/d1f0b46ba14623b18acf5ea57c44f0b2/1e043/bolero.png 690w\", \"/blog/static/d1f0b46ba14623b18acf5ea57c44f0b2/b1001/bolero.png 1380w\", \"/blog/static/d1f0b46ba14623b18acf5ea57c44f0b2/29007/bolero.png 1600w\"],\n    \"sizes\": \"(max-width: 1380px) 100vw, 1380px\",\n    \"style\": {\n      \"width\": \"100%\",\n      \"height\": \"100%\",\n      \"margin\": \"0\",\n      \"verticalAlign\": \"middle\",\n      \"position\": \"absolute\",\n      \"top\": \"0\",\n      \"left\": \"0\"\n    },\n    \"loading\": \"lazy\"\n  }), \"\\n    \")), mdx(\"p\", null, \"The nesting of the braces directly resembles the structure of the notes.\\nTo understand more about this syntax, check out my post about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-arrays\"\n  }, \"Rhythmical Arrays\"), \".\"), mdx(\"p\", null, \"We could also just ignore the outer two levels:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  \\\"sn\\\",\\n  [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"],\\n  \\\"sn\\\",\\n  [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"],\\n  \\\"sn\\\",\\n  \\\"sn\\\",\\n  \\\"sn\\\",\\n  [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"],\\n  \\\"sn\\\",\\n  [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"],\\n  [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"],\\n  [\\\"sn\\\", \\\"sn\\\", \\\"sn\\\"]\\n]\\n\")), mdx(\"p\", null, \"This piece of text also represents the bolero rhyhtm. It might not be as readable, but it still works..\\nIt depends on the use case, which representation should be chosen.\"), mdx(\"h3\", {\n    \"id\": \"flat\"\n  }, \"Flat\"), mdx(\"p\", null, \"A more machine readable version looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  [\\\"sn\\\", 0, 0.75],\\n  [\\\"sn\\\", 0.75, 0.25],\\n  [\\\"sn\\\", 1, 0.25],\\n  [\\\"sn\\\", 1.25, 0.25],\\n  [\\\"sn\\\", 1.5, 0.75],\\n  [\\\"sn\\\", 2.25, 0.25],\\n  [\\\"sn\\\", 2.5, 0.25],\\n  [\\\"sn\\\", 2.75, 0.25],\\n  [\\\"sn\\\", 3, 0.75],\\n  [\\\"sn\\\", 3.75, 0.75],\\n  [\\\"sn\\\", 4.5, 0.75],\\n  [\\\"sn\\\", 5.25, 0.25],\\n  [\\\"sn\\\", 5.5, 0.25],\\n  [\\\"sn\\\", 5.75, 0.25],\\n  [\\\"sn\\\", 6, 0.75],\\n  [\\\"sn\\\", 6.75, 0.25],\\n  [\\\"sn\\\", 7, 0.25],\\n  [\\\"sn\\\", 7.25, 0.25],\\n  [\\\"sn\\\", 7.5, 0.25],\\n  [\\\"sn\\\", 7.75, 0.25],\\n  [\\\"sn\\\", 8, 0.25],\\n  [\\\"sn\\\", 8.25, 0.25],\\n  [\\\"sn\\\", 8.5, 0.25],\\n  [\\\"sn\\\", 8.75, 0.25]\\n]\\n\")), mdx(\"p\", null, \"This is an absolute representation of the bolero at 45 bpm (quite slow, but has the nicest looking floats..).\\nThe format is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[value, time, duration]\"), \". While it is readable for machines, it is quite unpractical for humans..\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"The important question\"), \": How can we transform the first notation into the second?\\nWith it, the human interface would be the first, while the second one would be used for rendering / playback.\"), mdx(\"h2\", {\n    \"id\": \"calculating-absolute-time--duration\"\n  }, \"Calculating Absolute Time & Duration\"), mdx(\"p\", null, \"Let\\u2019s find out how to calculate the absolute time and duration for each node, based on the tree.\"), mdx(\"h3\", {\n    \"id\": \"fraction-paths\"\n  }, \"Fraction Paths\"), mdx(\"p\", null, \"Let\\u2019s identify each node by the index in its group of children:\"), mdx(State, {\n    initial: {\n      node: null\n    },\n    mdxType: \"State\"\n  }, function (_ref2) {\n    var _state$node, _state$node$path, _state$node2, _state$node2$path;\n\n    var state = _ref2.state,\n        setState = _ref2.setState;\n    return mdx(React.Fragment, null, mdx(TreeVisitor, {\n      onNode: function onNode(node) {\n        setState({\n          node: node\n        });\n      },\n      tree: function tree(node, visited) {\n        return r2d3(bolero, function (rhythm, path, parent) {\n          path = path.map(function (p) {\n            return p[0];\n          });\n          var isRoot = !path.length;\n          var color = 'darkgray';\n\n          var strPath = function strPath(p) {\n            return (p === null || p === void 0 ? void 0 : p.join(' ')) || '';\n          };\n\n          var isParent = strPath(node === null || node === void 0 ? void 0 : node.path).startsWith(strPath(path));\n          var isSelected = haveSameIndices(node === null || node === void 0 ? void 0 : node.path, path);\n          var isVisited = visited.find(function (v) {\n            return haveSameIndices(v.path, path);\n          });\n\n          if (isVisited) {\n            color = 'lightgray';\n          }\n\n          if (isParent || isSelected) {\n            color = isRoot ? 'darkgray' : 'red';\n          }\n\n          return _objectSpread(_objectSpread({}, toRhythmObject(rhythm)), {}, {\n            color: color,\n            name: parent ? path[path.length - 1] : 'bolero',\n            path: _toConsumableArray(path)\n          });\n        });\n      },\n      mdxType: \"TreeVisitor\"\n    }), !((_state$node = state.node) !== null && _state$node !== void 0 && (_state$node$path = _state$node.path) !== null && _state$node$path !== void 0 && _state$node$path.length) && mdx(\"p\", null, mdx(\"i\", null, \"Click step to walk the tree\")), !!((_state$node2 = state.node) !== null && _state$node2 !== void 0 && (_state$node2$path = _state$node2.path) !== null && _state$node2$path !== void 0 && _state$node2$path.length) && mdx(BlockMath, {\n      mdxType: \"BlockMath\"\n    }, \"path = [\".concat(state.node.path.join(', '), \"]\")));\n  }), mdx(\"br\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"When stepping into the tree, the path of indices uniquely identifies each node\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This path will help us to calculate time and duration\")), mdx(\"h3\", {\n    \"id\": \"calculating-durations\"\n  }, \"Calculating Durations\"), mdx(\"p\", null, \"Let\\u2019s divide each index by the number of children in that group:\"), mdx(State, {\n    initial: {\n      node: null,\n      calculation: null\n    },\n    mdxType: \"State\"\n  }, function (_ref3) {\n    var state = _ref3.state,\n        setState = _ref3.setState;\n    return mdx(React.Fragment, null, mdx(TreeVisitor, {\n      onNode: function onNode(node) {\n        if (!node) {\n          setState({\n            node: null,\n            calculation: null\n          });\n          return;\n        }\n\n        var pairs = node.path;\n\n        var F = function F(n, d) {\n          return new Fraction(n, d);\n        };\n\n        var duration = pairs //.concat([[1, 1]])\n        .map(function (_ref4) {\n          var _ref5 = _slicedToArray(_ref4, 2),\n              a = _ref5[0],\n              b = _ref5[1];\n\n          return \"\\\\frac{\".concat(a || 1, \"}{\").concat(b || 1, \"}\");\n        }).join('*');\n        var d = pairs.reduce(function (product, _ref6) {\n          var _ref7 = _slicedToArray(_ref6, 2),\n              a = _ref7[0],\n              b = _ref7[1];\n\n          return product.mul(F(1, b));\n        }, F(1, 1));\n        var time = pairs.map(function (_ref8, i, p) {\n          var _ref9 = _slicedToArray(_ref8, 2),\n              a = _ref9[0],\n              b = _ref9[1];\n\n          return i ? \"\\\\frac{\".concat(a, \"}{\").concat(b, \"}*(\").concat(p.slice(0, i).reverse().map(function (_ref10) {\n            var _ref11 = _slicedToArray(_ref10, 2),\n                x = _ref11[0],\n                y = _ref11[1];\n\n            return \"\\\\frac{1}{\".concat(y, \"}\");\n          }).join('*'), \")\") : \"\\\\frac{\".concat(a, \"}{\").concat(b, \"}\");\n        }).join(' + ');\n        var t = pairs.map(function (_ref12) {\n          var _ref13 = _slicedToArray(_ref12, 2),\n              a = _ref13[0],\n              b = _ref13[1];\n\n          return F(a, b);\n        }).reduce(function (sum, p, i) {\n          var div = pairs.slice(0, i).map(function (_ref14) {\n            var _ref15 = _slicedToArray(_ref14, 2),\n                _ = _ref15[0],\n                d = _ref15[1];\n\n            return d;\n          });\n          var m = div.reverse().reduce(function (product, d) {\n            return product.div(d);\n          }, p);\n          return sum.add(m);\n        }, new Fraction(0));\n        var whole = 6;\n        var ta = t.mul(6).toFraction(false);\n        var da = d.mul(6).toFraction(false);\n        var cd = F(6, 4).mul(F(d.n, d.d));\n        var ct = F(6, 4).mul(F(t.n, t.d));\n        var calculation = mdx(React.Fragment, null, mdx(\"p\", null, \"The duration relative to the complete bolero length is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"duration_{r} = \".concat(pairs.length > 1 ? duration + ' = ' : '', \"\\\\frac{\").concat(d.n, \"}{\").concat(d.d, \"}\")), mdx(\"p\", null, \"If 1 bolero takes 6s, the absolute duration of this node is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"duration_{a} = \\\\frac{\".concat(d.n, \"}{\").concat(d.d, \"} * 6s = \").concat(da, \"s\")));\n        setState({\n          node: node,\n          calculation: calculation\n        });\n      },\n      tree: parentTree,\n      mdxType: \"TreeVisitor\"\n    }), !state.node && mdx(\"p\", null, mdx(\"i\", null, \"Click step to walk the tree (prepare for math...)\")), state.node && mdx(BlockMath, {\n      mdxType: \"BlockMath\"\n    }, \"path = [\".concat(state.node.path //.concat([[1, 1]])\n    .map(function (_ref16) {\n      var _ref17 = _slicedToArray(_ref16, 2),\n          a = _ref17[0],\n          b = _ref17[1];\n\n      return \"\\\\frac{\".concat(a, \"}{\").concat(b, \"}\");\n    }).join(', '), \"]\")), state.calculation && mdx(React.Fragment, null, state.calculation));\n  }), mdx(\"br\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If we divide each node index by the total number of children (also called branching factor), we get a fraction that represents the duration of each node in its group.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"By multiplying that fraction with all the fractions of the node\\u2019s parents, we get the relative duration fraction.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can calculate the absolute duration by multiplying that relative duration by the total length of everything\")), mdx(\"h3\", {\n    \"id\": \"calculating-time\"\n  }, \"Calculating Time\"), mdx(\"p\", null, \"To get something usable, we also need the absolute time for each node.\\nThe process is similar to calculating durations, with a slightly more complicated looking calculation:\"), mdx(State, {\n    initial: {\n      node: null,\n      calculation: null\n    },\n    mdxType: \"State\"\n  }, function (_ref18) {\n    var state = _ref18.state,\n        setState = _ref18.setState;\n    return mdx(React.Fragment, null, mdx(TreeVisitor, {\n      onNode: function onNode(node) {\n        if (!node) {\n          setState({\n            node: null,\n            calculation: null\n          });\n          return;\n        }\n\n        var pairs = node.path;\n\n        var F = function F(n, d) {\n          return new Fraction(n, d);\n        };\n\n        var duration = pairs.map(function (_ref19) {\n          var _ref20 = _slicedToArray(_ref19, 2),\n              a = _ref20[0],\n              b = _ref20[1];\n\n          return \"\\\\frac{\".concat(a || 1, \"}{\").concat(b || 1, \"}\");\n        }).join('*');\n        var d = pairs.reduce(function (product, _ref21) {\n          var _ref22 = _slicedToArray(_ref21, 2),\n              a = _ref22[0],\n              b = _ref22[1];\n\n          return product.mul(F(1, b));\n        }, F(1, 1));\n        var time = pairs.map(function (_ref23, i, p) {\n          var _ref24 = _slicedToArray(_ref23, 2),\n              a = _ref24[0],\n              b = _ref24[1];\n\n          return i ? \"\\\\frac{\".concat(a, \"}{\").concat(b, \"}*(\").concat(p.slice(0, i).reverse().map(function (_ref25) {\n            var _ref26 = _slicedToArray(_ref25, 2),\n                x = _ref26[0],\n                y = _ref26[1];\n\n            return \"\\\\frac{1}{\".concat(y, \"}\");\n          }).join('*'), \")\") : \"\\\\frac{\".concat(a, \"}{\").concat(b, \"}\");\n        }).join(' + ');\n        var t = pairs.map(function (_ref27) {\n          var _ref28 = _slicedToArray(_ref27, 2),\n              a = _ref28[0],\n              b = _ref28[1];\n\n          return F(a, b);\n        }).reduce(function (sum, p, i) {\n          var div = pairs.slice(0, i).map(function (_ref29) {\n            var _ref30 = _slicedToArray(_ref29, 2),\n                _ = _ref30[0],\n                d = _ref30[1];\n\n            return d;\n          });\n          var m = div.reverse().reduce(function (product, d) {\n            return product.div(d);\n          }, p);\n          return sum.add(m);\n        }, new Fraction(0));\n        var timeSimple = t.n ? \"\\\\frac{\".concat(t.n, \"}{\").concat(t.d, \"}\") : \"0\";\n        var whole = 6;\n        var ta = t.mul(6).toFraction(false);\n        var da = d.mul(6).toFraction(false);\n        var cd = F(6, 4).mul(F(d.n, d.d));\n        var ct = F(6, 4).mul(F(t.n, t.d));\n        var calculation = mdx(React.Fragment, null, mdx(\"p\", null, \"The time relative to the complete bolero is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"time_{r} = \".concat(time, \" = \").concat(timeSimple)), mdx(\"p\", null, \"If 1 bolero take 6s, the absolute time of this node is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"time_{a} = \".concat(timeSimple, \" * 6s = \").concat(ta, \"s\")));\n        setState({\n          node: node,\n          calculation: calculation\n        });\n      },\n      tree: parentTree,\n      mdxType: \"TreeVisitor\"\n    }), !state.node && mdx(\"p\", null, mdx(\"i\", null, \"Click step to walk the tree (prepare for math...)\")), state.node && mdx(BlockMath, {\n      mdxType: \"BlockMath\"\n    }, \"path = [\".concat(state.node.path.map(function (_ref31) {\n      var _ref32 = _slicedToArray(_ref31, 2),\n          a = _ref32[0],\n          b = _ref32[1];\n\n      return \"\\\\frac{\".concat(a, \"}{\").concat(b, \"}\");\n    }).join(', '), \"]\")), state.calculation && mdx(React.Fragment, null, state.calculation));\n  }), mdx(\"br\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"to calculate the relative time fraction, we need to sum the relative times of each node in the path\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the relative time of a single node is the factor of its path and its parent\\u2019s relative durations\")), mdx(\"h2\", {\n    \"id\": \"variable-durations\"\n  }, \"Variable Durations\"), mdx(\"p\", null, \"In the bolero example, there are no duration fractions with a numerator other than 1.\\nTo be able to cover any rhythm of this world, we need to extend our paths.\"), mdx(\"p\", null, \"Take this as an example:\"), mdx(Score, {\n    width: 400,\n    height: 100,\n    staves: [[['C4', '2d'], ['D4', 'q']], [['E4', 'q'], ['D4', '2'], ['B3', 'q']]],\n    mdxType: \"Score\"\n  }), mdx(\"p\", null, \"Using our current textual representation, this is impossible to express. We need a way to declare durations, for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  [\\\"C4*3\\\", \\\"D4\\\"],\\n  [\\\"E4\\\", \\\"D4*2\\\", \\\"B3\\\"]\\n]\\n\")), mdx(\"p\", null, \"If we just represent the durations as a tree, it looks like this:\"), mdx(Tree, {\n    width: 620,\n    nodeRadius: 10,\n    dx: 20,\n    columns: [12, 12],\n    data: ro2d3([[{\n      value: 'C4',\n      duration: 3\n    }, 'D4'], ['E4', {\n      value: 'D4',\n      duration: 2\n    }, 'B3']], function (rhythm, path) {\n      return _objectSpread(_objectSpread({}, toRhythmObject(rhythm)), {}, {\n        color: path.length ? colors[path.length - 1] : 'black',\n        name: path.length ? \"\".concat(path[path.length - 1][2]) : '1',\n        path: _toConsumableArray(path)\n      });\n    }),\n    hideJson: true,\n    mdxType: \"Tree\"\n  }), mdx(\"h3\", {\n    \"id\": \"calculating-variable-durations\"\n  }, \"Calculating Variable Durations\"), mdx(\"p\", null, \"Now, to get the correct fractions, we cannot just use the indices like before.\\nInstead, we can use the duration as the numerator and the sum of all durations for the denominator:\"), mdx(State, {\n    initial: {\n      node: null\n    },\n    mdxType: \"State\"\n  }, function (_ref33) {\n    var state = _ref33.state,\n        setState = _ref33.setState;\n    return mdx(React.Fragment, null, mdx(TreeVisitor, {\n      onNode: function onNode(node) {\n        if (!node) {\n          setState({\n            node: null,\n            calculation: null\n          });\n          return;\n        }\n\n        var pairs = node.path;\n\n        var F = function F(n, d) {\n          return new Fraction(n, d);\n        };\n\n        var duration = pairs //.concat([[1, 1]])\n        .map(function (_ref34) {\n          var _ref35 = _slicedToArray(_ref34, 3),\n              _ = _ref35[0],\n              b = _ref35[1],\n              a = _ref35[2];\n\n          return \"\\\\frac{\".concat(a || 1, \"}{\").concat(b || 1, \"}\");\n        }).join('*');\n        var d = pairs.reduce(function (product, _ref36) {\n          var _ref37 = _slicedToArray(_ref36, 3),\n              _ = _ref37[0],\n              b = _ref37[1],\n              a = _ref37[2];\n\n          return product.mul(F(a || 1, b));\n        }, F(1, 1));\n        var whole = 8;\n        var da = d.mul(whole).toFraction(false);\n        var cd = F(whole, 4).mul(F(d.n, d.d));\n        var calculation = mdx(React.Fragment, null, mdx(\"p\", null, \"The duration relative to the length is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"duration_{r} = \".concat(pairs.length > 1 ? duration + ' = ' : '', \"\\\\frac{\").concat(d.n, \"}{\").concat(d.d, \"}\")), mdx(\"p\", null, \"If the whole takes 8s, the absolute duration of this node is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"duration_{a} = \\\\frac{\".concat(d.n, \"}{\").concat(d.d, \"} * 8s = \").concat(da, \"s\")));\n        setState({\n          node: node,\n          calculation: calculation\n        });\n      },\n      tree: function tree(node, visited) {\n        return ro2d3([[{\n          value: 'C4',\n          duration: 3\n        }, 'D4'], ['E4', {\n          value: 'D4',\n          duration: 2\n        }, 'B3']], function (rhythm, path) {\n          var isRoot = !path.length;\n          var color = 'darkgray';\n\n          var strPath = function strPath(p) {\n            return (p === null || p === void 0 ? void 0 : p.map(function (s) {\n              return s.join('/');\n            }).join(' ')) || '';\n          };\n\n          var isParent = strPath(node === null || node === void 0 ? void 0 : node.path).startsWith(strPath(path));\n          var isSelected = haveSameIndices(node === null || node === void 0 ? void 0 : node.path, path);\n          var isVisited = visited.find(function (v) {\n            return haveSameIndices(v.path, path);\n          });\n\n          if (isVisited) {\n            color = 'lightgray';\n          }\n\n          if (isSelected || isParent && !isRoot) {\n            color = 'red';\n          }\n\n          return _objectSpread(_objectSpread({}, toRhythmObject(rhythm)), {}, {\n            color: color,\n            name: path.length ? \"\".concat(path[path.length - 1][2], \"/\").concat(path[path.length - 1][1]) : '1',\n            path: _toConsumableArray(path)\n          });\n        });\n      },\n      hideJson: true,\n      mdxType: \"TreeVisitor\"\n    }), state.calculation);\n  }), mdx(\"h3\", {\n    \"id\": \"calculating-time-with-variable-durations\"\n  }, \"Calculating Time With Variable Durations\"), mdx(\"p\", null, \"To know the time fraction, our numerator must be the sum of all durations that came before the node in question:\"), mdx(State, {\n    initial: {\n      node: null\n    },\n    mdxType: \"State\"\n  }, function (_ref38) {\n    var state = _ref38.state,\n        setState = _ref38.setState;\n    return mdx(React.Fragment, null, mdx(TreeVisitor, {\n      onNode: function onNode(node) {\n        if (!node) {\n          setState({\n            node: null,\n            calculation: null\n          });\n          return;\n        }\n\n        var pairs = node.path;\n\n        var F = function F(n, d) {\n          return new Fraction(n, d);\n        };\n\n        var duration = pairs.map(function (_ref39) {\n          var _ref40 = _slicedToArray(_ref39, 2),\n              a = _ref40[0],\n              b = _ref40[1];\n\n          return \"\\\\frac{\".concat(a || 1, \"}{\").concat(b || 1, \"}\");\n        }).join('*');\n        var d = pairs.reduce(function (product, _ref41) {\n          var _ref42 = _slicedToArray(_ref41, 2),\n              a = _ref42[0],\n              b = _ref42[1];\n\n          return product.mul(F(a || 1, b));\n        }, F(1, 1));\n        var time = pairs.map(function (_ref43, i, p) {\n          var _ref44 = _slicedToArray(_ref43, 2),\n              a = _ref44[0],\n              b = _ref44[1];\n\n          return i ? \"\\\\frac{\".concat(a || 0, \"}{\").concat(b, \"}*(\").concat(p.slice(0, i).reverse().map(function (_ref45) {\n            var _ref46 = _slicedToArray(_ref45, 2),\n                x = _ref46[0],\n                y = _ref46[1];\n\n            return \"\\\\frac{\".concat(x || 1, \"}{\").concat(y, \"}\");\n          }).join('*'), \")\") : \"\\\\frac{\".concat(a || 0, \"}{\").concat(b, \"}\");\n        }).join(' + ');\n        var t = pairs.map(function (_ref47) {\n          var _ref48 = _slicedToArray(_ref47, 2),\n              a = _ref48[0],\n              b = _ref48[1];\n\n          return F(a, b);\n        }).reduce(function (sum, p, i) {\n          var div = pairs.slice(0, i).map(function (_ref49) {\n            var _ref50 = _slicedToArray(_ref49, 2),\n                _ = _ref50[0],\n                d = _ref50[1];\n\n            return d;\n          });\n          var m = div.reverse().reduce(function (product, d) {\n            return product.div(d);\n          }, p);\n          return sum.add(m);\n        }, new Fraction(0));\n        var timeSimple = t.n ? \"\\\\frac{\".concat(t.n, \"}{\").concat(t.d, \"}\") : \"0\";\n        var whole = 8;\n        var ta = t.mul(whole).toFraction(false);\n        var da = d.mul(whole).toFraction(false);\n        var cd = F(whole, 4).mul(F(d.n, d.d));\n        var ct = F(whole, 4).mul(F(t.n, t.d));\n        var calculation = mdx(React.Fragment, null, mdx(\"p\", null, \"The time relative to the whole is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"time_{r} = \".concat(time, \" = \").concat(timeSimple)), mdx(\"p\", null, \"If the whole takes 8s, the absolute time of this node is:\"), mdx(BlockMath, {\n          mdxType: \"BlockMath\"\n        }, \"time_{a} = \".concat(timeSimple, \" * 8s = \").concat(ta, \"s\")));\n        setState({\n          node: node,\n          calculation: calculation\n        });\n      },\n      tree: function tree(node, visited) {\n        return ro2d3([[{\n          value: 'C4',\n          duration: 3\n        }, 'D4'], ['E4', {\n          value: 'D4',\n          duration: 2\n        }, 'B3']], function (rhythm, path) {\n          var isRoot = !path.length;\n          var color = 'darkgray';\n\n          var strPath = function strPath(p) {\n            return (p === null || p === void 0 ? void 0 : p.map(function (s) {\n              return s.join('/');\n            }).join(' ')) || '';\n          };\n\n          var isParent = strPath(node === null || node === void 0 ? void 0 : node.path).startsWith(strPath(path));\n          var isSelected = haveSameIndices(node === null || node === void 0 ? void 0 : node.path, path);\n          var isVisited = visited.find(function (v) {\n            return haveSameIndices(v.path, path);\n          });\n\n          if (isVisited) {\n            color = 'lightgray';\n          }\n\n          if (isSelected || isParent && !isRoot) {\n            color = 'red';\n          }\n\n          return _objectSpread(_objectSpread({}, toRhythmObject(rhythm)), {}, {\n            color: color,\n            name: path.length ? \"\".concat(path[path.length - 1][0], \"/\").concat(path[path.length - 1][1]) : '1',\n            path: _toConsumableArray(path)\n          });\n        });\n      },\n      hideJson: true,\n      mdxType: \"TreeVisitor\"\n    }), state.calculation);\n  }), mdx(\"h3\", {\n    \"id\": \"flat-representation\"\n  }, \"Flat representation\"), mdx(\"p\", null, \"Using the calculated values above, we get this flat representation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  [\\\"C4\\\", 0, 3],\\n  [\\\"D4\\\", 3, 1],\\n  [\\\"E4\\\", 4, 1],\\n  [\\\"D4\\\", 5, 2],\\n  [\\\"B3\\\", 7, 1]\\n]\\n\")), mdx(\"p\", null, \"Nice! Now chewed through all the theory that is needed to calculate any rhythm.\"), mdx(\"h2\", {\n    \"id\": \"implementation\"\n  }, \"Implementation\"), mdx(\"p\", null, \"Let\\u2019s transfer the above ideas into code. In general, we need to\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Visit every node of the tree\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Calculate time and duration of every node\")), mdx(\"h3\", {\n    \"id\": \"1-visiting-every-node-of-a-tree\"\n  }, \"1. Visiting every node of a tree\"), mdx(\"h4\", {\n    \"id\": \"simple-walker\"\n  }, \"Simple Walker\"), mdx(\"p\", null, \"This recursive \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators\"\n  }, \"generator function\"), \" visits every tree node, while being agnostic about the tree structure:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function* walk(getChildren, tree) {\\n  yield tree;\\n  const children = getChildren(tree) || [];\\n  for (let i = 0; i < children.length; ++i) {\\n    yield* walk(getChildren, children[i]);\\n  }\\n}\\n\")), mdx(\"p\", null, \"Using the getChildren accessor function, we can stay agnostic about the tree structure. This is inspired by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/d3/d3-hierarchy#hierarchy\"\n  }, \"d3-hierarchy\"), \".\"), mdx(\"p\", null, \"Walking over a simple nested array is pretty straightforward:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const nestedWalker = (tree) => walk((node) => Array.isArray(node) && node, tree);\\nconst tree = ['A', ['B', 'C'], 'D'];\\n\\nfor (let node of nestedWalker(tree)) {\\n  console.log(node);\\n}\\n\")), mdx(\"p\", null, \"Output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-log\"\n  }, \"['A', ['B', 'C'], 'D']\\n'A'\\n['B', 'C']\\n'B'\\n'C'\\n'D'\\n\")), mdx(\"h4\", {\n    \"id\": \"walking-rhythmical-objects\"\n  }, \"Walking rhythmical objects\"), mdx(\"p\", null, \"To be able to walk over a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./rhythmical-objects\"\n  }, \"rhythmical object\"), \", we just have to implement a different getChildren accessor:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function getRhythmChildren(node) {\\n  return Array.isArray(node) ? node : node?.parallel || node?.sequential;\\n}\\nconst rhythmWalker = (tree) => walk(getRhythmChildren, tree);\\n\\nconst rhythm = {\\n  duration: 4,\\n  sequential: [\\n    [{ value: 'C3', duration: 3 }, 'D3'],\\n    ['E3', { value: 'D3', duration: 2 }, 'B2'],\\n  ],\\n};\\n\\nfor (let node of rhythmWalker(rhythm)) {\\n  console.log(node);\\n}\\n\")), mdx(\"p\", null, \"Output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-log\"\n  }, \"{\\n  duration: 4,\\n  sequential: [ [ [Object], 'D3' ], [ 'E3', [Object], 'B2' ] ]\\n}\\n[ { value: 'C3', duration: 3 }, 'D3' ]\\n{ value: 'C3', duration: 3 }\\nD3\\n[ 'E3', { value: 'D3', duration: 2 }, 'B2' ]\\nE3\\n{ value: 'D3', duration: 2 }\\nB2\\n\")), mdx(\"p\", null, \"Now we are able to look at nodes one after the other. This is still too primitive to be usable.\"), mdx(\"h4\", {\n    \"id\": \"exposing-more-data\"\n  }, \"Exposing More Data\"), mdx(\"p\", null, \"The problem: We have no information about the current index or the siblings. So, instead of just yielding the node, let\\u2019s enrich the data:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function* visit(getChildren, tree, index?, siblings?, parent?) {\\n  const children = getChildren(tree) || [];\\n  const isRoot = parent === undefined;\\n  const isLeaf = !children?.length;\\n  yield { node: tree, index, siblings, children, isBefore: true, isRoot, isLeaf, parent };\\n  for (let i = 0; i < children.length; ++i) {\\n    yield* visit(getChildren, children[i], i, children, tree);\\n  }\\n  yield { node: tree, index, siblings, children, isBefore: false, isRoot, isLeaf, parent };\\n}\\n\")), mdx(\"p\", null, \"What\\u2019s new:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the current index + siblings is fed back into the function\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we are now yielding an object with more information on the state of the iteration\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we are yielding again after the children have been processed, passing an isBefore flag\")), mdx(\"h4\", {\n    \"id\": \"generating-index-paths\"\n  }, \"Generating Index Paths\"), mdx(\"p\", null, \"Using that, we can build an index path like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const nestedWalker = (tree) => visit((node) => Array.isArray(node) && node, tree);\\n\\nconst tree = ['A', ['B', 'C'], 'D'];\\n\\nconst path = []; // stack of indices\\nconst events = []; // collection of path states\\n\\nfor (let { index, isBefore, isLeaf, isRoot } of nestedWalker(tree)) {\\n  if (isBefore) {\\n    // before children have been visited\\n    !isRoot && path.push(index);\\n    isLeaf && events.push([...path]); // we only care for leaves\\n  } else {\\n    // after children have been visited\\n    !isRoot && path.pop();\\n  }\\n}\\nexpect(events).toEqual([[0], [1, 0], [1, 1], [2]]); // leaf index paths\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the path array acts as a stack of indices, where we add the index before and remove it after visiting the children\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for each leaf, we add the current path to the events array\")), mdx(\"h3\", {\n    \"id\": \"2-calculate-time-and-duration-of-every-node\"\n  }, \"2. Calculate time and duration of every node\"), mdx(\"p\", null, \"Now let\\u2019s find out how we can perform the calculations in code.\"), mdx(\"h4\", {\n    \"id\": \"division-paths\"\n  }, \"Division Paths\"), mdx(\"p\", null, \"Before we can calculate the time & duration, we need to keep track of the relative times and durations.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function divisionPaths(tree) {\\n  const path = [];\\n  const events = [];\\n  for (let { node, index, isBefore, isLeaf, siblings } of nestedWalker(tree)) {\\n    if (isBefore) {\\n      siblings && path.push([index, siblings.length]);\\n      isLeaf && events.push({ node, path: path.join(' ') });\\n    } else {\\n      siblings && path.pop();\\n    }\\n  }\\n  return events;\\n}\\n\\nexpect(getPaths(['A', ['B', 'C'], 'D'])).toEqual([\\n  { node: 'A', path: '0,3' },\\n  { node: 'B', path: '1,3 0,2' },\\n  { node: 'C', path: '1,3 1,2' },\\n  { node: 'D', path: '2,3' },\\n]);\\n\")), mdx(\"p\", null, \"Like in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"#calculating-durations\"\n  }, \"Calculating Durations\"), \", we represent the position of a node as a number pair of index and number of siblings.\"), mdx(\"h4\", {\n    \"id\": \"calculating-absolute-times\"\n  }, \"Calculating absolute times\"), mdx(\"p\", null, \"To turn those paths into concrete numbers we can run the following logic:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function pathTimeDurationSimple(path, whole = 1) {\\n  let time = 0;\\n  let duration = whole;\\n  for (let i = 0; i < path.length; i++) {\\n    time = time + (path[i][0] / path[i][1]) * duration;\\n    duration /= path[i][1];\\n  }\\n  return { time, duration };\\n}\\n\\nconst renderEvents = (tree, duration) =>\\n  divisionPaths(tree).map(({ node, path }) => ({ node, ...pathTimeDurationSimple(path, duration) }));\\n\\nexpect(renderEvents(['A', ['B', 'C'], 'D'], 6)).toEqual([\\n  { node: 'A', time: 0, duration: 2 },\\n  { node: 'B', time: 2, duration: 1 },\\n  { node: 'C', time: 3, duration: 1 },\\n  { node: 'D', time: 4, duration: 2 },\\n]);\\n\")), mdx(\"p\", null, \"Et voir-la! This is it for rendering without variable durations.\"), mdx(\"h4\", {\n    \"id\": \"with-variable-durations\"\n  }, \"With variable durations\"), mdx(\"p\", null, \"To add variable durations, we can just add a third number to our path:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function timeDurationPaths(walker, getDuration) {\\n  const path = [];\\n  const events = [];\\n  const sumDurations = (nodes) => nodes.reduce((sum, current) => sum + getDuration(current), 0);\\n  for (let { node, index, isBefore, isRoot, isLeaf, siblings } of walker) {\\n    if (!isRoot && isBefore) {\\n      siblings = siblings || [];\\n      const time = sumDurations(siblings.slice(0, index));\\n      const duration = getDuration(node);\\n      const total = time + sumDurations(siblings.slice(index));\\n      path.push([time, duration, total]);\\n      isLeaf && events.push({ node, path: [...path] });\\n    } else if (!isRoot) {\\n      path.pop();\\n    }\\n  }\\n  return events;\\n}\\n\")), mdx(\"p\", null, \"Now we are using the sum of all preceding durations as time and the sum of all siblings durations as total duration.\\nTo stay agnostic of the node format, we just pass a function that should resolve the duration of a node.\"), mdx(\"p\", null, \"Before we test this, let\\u2019s fix our calculation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function pathTimeDuration(path, whole = 1) {\\n  let time = 0;\\n  let duration = whole;\\n  for (let i = 0; i < path.length; i++) {\\n    time = time + (path[i][0] / path[i][2]) * duration;\\n    duration *= path[i][1] / path[i][2];\\n  }\\n  return { time, duration };\\n}\\n\")), mdx(\"p\", null, \"Running this on our variable duration example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const renderEvents = (tree, duration, getDuration) =>\\n  timeDurationPaths(nestedWalker(tree), getDuration).map(({ node, path }) => ({\\n    node,\\n    ...pathTimeDuration(path, duration),\\n  }));\\n\\nexpect(\\n  renderEvents(\\n    [\\n      ['C4*3', 'D4'],\\n      ['E4', 'D4*2', 'B3'],\\n    ],\\n    8,\\n    (node) => (typeof node === 'string' ? +node.split('*')[1] || 1 : 1)\\n  )\\n).toEqual([\\n  { node: 'C4*3', time: 0, duration: 3 },\\n  { node: 'D4', time: 3, duration: 1 },\\n  { node: 'E4', time: 4, duration: 1 },\\n  { node: 'D4*2', time: 5, duration: 2 },\\n  { node: 'B3', time: 7, duration: 1 },\\n]);\\n\")), mdx(\"p\", null, \"And that\\u2019s it!\"), mdx(\"h4\", {\n    \"id\": \"rendering-rhythmical-objects\"\n  }, \"Rendering Rhythmical Objects\"), mdx(\"p\", null, \"Rendering a rhythmical object works like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export default function renderRhythmTree(rhythm) {\\n  const rhythmDuration = (node) => toRhythmObject(node).duration || 1;\\n  const totalDuration = rhythmDuration(rhythm);\\n  const path = [];\\n  const events = [];\\n  for (let { node, index, isBefore, isRoot, isLeaf, siblings, parent } of visit(getRhythmChildren, rhythm)) {\\n    if (!isRoot && isBefore) {\\n      path.push(rhythmFraction(node, index, siblings, parent));\\n      isLeaf && events.push({ ...toRhythmObject(node), ...pathTimeDuration(path, totalDuration) });\\n    } else if (!isRoot) {\\n      path.pop();\\n    }\\n  }\\n  return events;\\n}\\n\")), mdx(\"p\", null, \"Here, the duration of the root node is interpreted as seconds. The path fraction can be calculated using sibling and parent information:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function rhythmFraction<T>(\\n  node: RhythmNode<T>,\\n  index?: number,\\n  siblings?: RhythmNode<T>[],\\n  parent?: RhythmNode<T>\\n): Fraction {\\n  const duration = (node as RhythmObject<T>).duration ?? 1;\\n  if (!parent) {\\n    // root node\\n    return [0, duration, 1]\\n  }\\n  const durations = siblings.map((sibling: RhythmObject<T>) => sibling.duration ?? 1);\\n  const total = sum(durations);\\n  if ((parent as RhythmObject<T>)?.parallel) {\\n    // parallel path\\n    return [0, duration, max(durations)];\\n  }\\n  const time = sum(durations.slice(0, index));\\n  // sequential path\\n  return [time, duration, total]\\n}\\n\")), mdx(\"p\", null, \"Now we can test the variable duration example from above:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('renderRhythmTree', () => {\\n  expect(\\n    renderRhythmTree({\\n      duration: 8,\\n      sequential: [\\n        [{ value: 'C4', duration: 3 }, 'D4'],\\n        ['E4', { value: 'D4', duration: 2 }, 'B3'],\\n      ],\\n    }).map(({ value, time, duration }) => [value, time, duration])\\n  ).toEqual([\\n    ['C4', 0, 3],\\n    ['D4', 3, 1],\\n    ['E4', 4, 1],\\n    ['D4', 5, 2],\\n    ['B3', 7, 1],\\n  ]);\\n});\\n\")), mdx(\"p\", null, \"And it works! Now we worked out a complete reimplementation of rendering \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./rhythmical-objects\"\n  }, \"rhythmical objects\"), \".\\nThe complexity of the implementation is much lower, using less clutter.\"), mdx(\"p\", null, \"But enough of that cheap test sequence, let\\u2019s render a much more complex tune:\"), mdx(Player, {\n    fold: true,\n    hierarchy: false,\n    instruments: {\n      piano: piano\n    },\n    events: renderRhythmTree(swimming),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"p\", null, \"I generated the tree json of this tune using some shorthand functions:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const d = (e) => {\\n  // duration short notation\\n  const [value, duration] = e.split('*');\\n  if (duration) {\\n    return { sequential: [value], duration: parseInt(duration) };\\n  }\\n  return value;\\n};\\nconst s = (str, duration = 1) => ({ sequential: str.split(' ').map(d), duration }); // sequential short notation\\nconst p = (str, duration = 1) => ({ parallel: str.split(' ').map(d), duration }); // parallel short notation\\nconst w = (str) => ['r', p(str), p(str)]; // waltz chord comping\\n\\nconst swimming = {\\n  name: 'Swimming',\\n  composer: 'Koji Kondo',\\n  duration: 51,\\n  parallel: [\\n    {\\n      description: 'melody',\\n      velocity: 1,\\n      sequential: [\\n        d('r*3'),\\n        ['A5', s('F5*2 C5'), s('D5*2 F5'), 'F5'],\\n        [s('C5*2 F5'), s('F5*2 C6'), 'A5', 'G5'],\\n        ['A5', s('F5*2 C5'), s('D5*2 F5'), 'F5'],\\n        [s('C5*2 F5'), ['Bb5', 'A5', 'G5'], d('F5*2')],\\n        ['A5', s('F5*2 C5'), s('D5*2 F5'), 'F5'],\\n        [s('C5*2 F5'), s('F5*2 C6'), 'A5', 'G5'],\\n        ['A5', s('F5*2 C5'), s('D5*2 F5'), 'F5'],\\n        [s('C5*2 F5'), ['Bb5', 'A5', 'G5'], d('F5*2')],\\n        ['A5', s('F5*2 C5'), 'A5', 'F5'],\\n        ['Ab5', s('F5*2 Ab5'), d('G5*2')],\\n        ['A5', s('F5*2 C5'), 'A5', 'F5'],\\n        ['Ab5', s('F5*2 C5'), d('C6*2')],\\n        ['A5', s('F5*2 C5'), s('D5*2 F5'), 'F5'],\\n        [s('C5*2 F5'), ['Bb5', 'A5', 'G5'], d('F5*2')],\\n      ],\\n    },\\n    {\\n      description: 'chords',\\n      velocity: 0.6,\\n      sequential: [\\n        [\\n          p('F4 Bb4 D5'),\\n          [p('D4 G4 Bb4', 2), p('Bb3 D4 F4')],\\n          [p('G3 C4 E4', 2), [p('Ab3 F4'), p('A3 Gb4')]],\\n          p('Bb3 E4 G4'),\\n        ],\\n        [w('F3 A3 C3'), w('F3 A3 C3'), w('F3 Bb3 D3'), w('F3 Bb3 Db3')],\\n        [w('F3 A3 C3'), w('F3 A3 C3'), w('F3 Bb3 D3'), w('F3 B3 D3')],\\n        [w('F3 A3 C3'), w('F3 A3 C3'), w('F3 Bb3 D3'), w('F3 B3 D3')],\\n        [w('A3 C4 E4'), w('Ab3 C4 Eb4'), w('F3 Bb3 D3'), w('G3 C4 E4')],\\n        [w('F3 A3 C4'), w('F3 A3 C4'), w('F3 Bb3 D3'), w('F3 B3 D3')],\\n        [w('F3 Bb3 D4'), w('F3 Bb3 C4'), w('F3 A3 C4'), w('F3 A3 C4')],\\n        [w('F3 A3 C3'), w('F3 A3 C3'), w('F3 Bb3 D3'), w('F3 B3 D3')],\\n        [w('A3 C4 E4'), w('Ab3 C4 Eb4'), w('F3 Bb3 D3'), w('G3 C4 E4')],\\n        [w('F3 A3 C3'), w('F3 A3 C3'), w('F3 Bb3 D3'), w('F3 B3 D3')],\\n        [w('F3 Bb3 D4'), w('F3 Bb3 C4'), w('F3 A3 C4'), w('F3 A3 C4')],\\n        [w('Bb3 D3 F4'), w('Bb3 D3 F4'), w('A3 C4 F4'), w('A3 C4 F4')],\\n        [w('Ab3 B3 F4'), w('Ab3 B3 F4'), w('G3 Bb3 F4'), w('G3 Bb3 E4')],\\n        [w('Bb3 D3 F4'), w('Bb3 D3 F4'), w('A3 C4 F4'), w('A3 C4 F4')],\\n        [w('Ab3 B3 F4'), w('Ab3 B3 F4'), w('G3 Bb3 F4'), w('G3 Bb3 E4')],\\n        [w('F3 A3 C3'), w('F3 A3 C3'), w('F3 Bb3 D3'), w('F3 B3 D3')],\\n        [w('F3 Bb3 D4'), w('F3 Bb3 C4'), w('F3 A3 C4'), w('F3 A3 C4')],\\n      ],\\n    },\\n    {\\n      description: 'bass',\\n      sequential: [\\n        ['G3', 'G3', 'C3', 'E3'],\\n        ['F2', 'D2', 'G2', 'C2'],\\n        ['F2', 'D2', 'G2', 'C2'],\\n        ['F2', 'A2', 'Bb2', 'B2'],\\n        ['A2', 'Ab2', 'G2', 'C2'],\\n        ['F2', 'A2', 'Bb2', 'B2'],\\n        ['G2', 'C2', 'F2', 'F2'],\\n        ['F2', 'A2', 'Bb2', 'B2'],\\n        ['A2', 'Ab2', 'G2', 'C2'],\\n        ['F2', 'A2', 'Bb2', 'B2'],\\n        ['G2', 'C2', 'F2', 'F2'],\\n        ['Bb2', 'Bb2', 'A2', 'A2'],\\n        ['Ab2', 'Ab2', 'G2', ['C2', 'D2', 'E2']],\\n        ['Bb2', 'Bb2', 'A2', 'A2'],\\n        ['Ab2', 'Ab2', 'G2', ['C2', 'D2', 'E2']],\\n        ['F2', 'A2', 'Bb2', 'B2'],\\n        ['G2', 'C2', 'F2', 'F2'],\\n      ],\\n    },\\n  ],\\n};\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player fold={true} hierarchy={false} instruments={{ piano }} events={renderRhythmTree(swimming)} />\\n\"))), mdx(\"p\", null, \"That\\u2019s it for today! In a future post, I want to implement plugins by tree mutation.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/rhythmical-trees/","title":"Rhythmical Trees","tags":[],"keywords":["rhythmical","draft"],"date":"April 30, 2021","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"3ec70d92-3605-5364-bf05-f00d32dd021f","excerpt":"To build a hackable backing track player, we already laid the foundation of  rhythm  and  harmony .\nWhat's missing: Melodies.\nEven if weâ€¦","slug":"/chord-scales/","title":"Chord Scales","date":"April 11, 2021"},"next":{"__typename":"MdxBlogPost","id":"9aca094e-1832-569f-bf94-257817489215","excerpt":"Lately, I've been learning about analog synthesis. In this post, I want to document what I've learned so far and how I approached the topicâ€¦","slug":"/analog-synthesis/","title":"A Macro View on Analog Synthesis","date":"May 14, 2021"}},"pageContext":{"id":"a5b9862e-ecf2-5460-ab4b-a9e8ed03ad1a","previousId":"3ec70d92-3605-5364-bf05-f00d32dd021f","nextId":"9aca094e-1832-569f-bf94-257817489215"}},"staticQueryHashes":["386998304","4198970465","764694655"]}