{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/rhythmical-reducers/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"35bc9fc8-9385-5688-a480-3383b7827fb8","excerpt":"So far, rhythmical knows two ways of data transformation/mutation: plugins  as preprocessors reducers  as postprocessors In this post, Iâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rhythmical Mutations\",\n  \"date\": \"2020-08-02T00:00:00.000Z\",\n  \"image\": \"./img/pianoroll-color.png\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So far, rhythmical knows two ways of data transformation/mutation:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"../rhythmical-objects/#feature-encapsulation\"\n  }, \"plugins\"), \" as preprocessors\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"../rhythmical-ties\"\n  }, \"reducers\"), \" as postprocessors\")), mdx(\"p\", null, \"In this post, I want to develop the idea of mutation to allow more flexibility.\"), mdx(\"h2\", {\n    \"id\": \"reducers\"\n  }, \"Reducers\"), mdx(\"p\", null, \"With reducers, flat rhythmical events can be mutated after rendering:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"renderRhythmObject({\\n  duration: 8,\\n  sequential: [['d4', 'eb4', 'e4', 'f4'], '_']\\n}).reduce(tieReducer(), []); // appends \\\"_\\\" event to \\\"f4\\\" event\\n\")), mdx(\"p\", null, \"or\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"renderRhythmObject({\\n  duration: 8,\\n  sequential: [['F', 'G'], 'C']\\n}).reduce(voicings(triads, ['C3', 'A4']), []);\\n// generates notes in range for each chord symbol (implemented in last post)\\n\")), mdx(\"p\", null, \"As a reducer runs, the previous state of the events is lost, for example, the chord symbols will be vanished after the voicing reducer.\"), mdx(\"h3\", {\n    \"id\": \"bass-reducer\"\n  }, \"Bass Reducer\"), mdx(\"p\", null, \"As another example, I want to introduce this simple reducer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// reduces events to bass notes\\nexport const bassNotes: EventReducer = (events, event, index, array) => {\\n  if (typeof event.value !== 'string') {\\n    return events;\\n  }\\n  const bassNote = getBassNote(event.value);\\n  return events.concat([{ ...event, value: bassNote + '2' }]);\\n};\\n// returns bass note of given chord\\nfunction getBassNote(chord: string, ignoreSlash = false) {\\n  if (!chord) {\\n    return null;\\n  }\\n  if (!ignoreSlash && chord.includes('/')) {\\n    return chord.split('/')[1];\\n  }\\n  const match = chord.match(/^([A-G][b|#]?)/);\\n  if (!match || !match.length) {\\n    return '';\\n  }\\n  return match[0];\\n}\\n\")), mdx(\"p\", null, \"It takes chord symbols and returns only the bass note in a fixed octave:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythmObject({\n      duration: 8,\n      sequential: [['F', 'G'], 'C']\n    }).reduce(bassNotes, []),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythmObject({\\n    duration: 8,\\n    sequential: [['F', 'G'], 'C']\\n  }).reduce(bassNotes, [])}\\n/>\\n\"))), mdx(\"p\", null, \"I will improve this later, adding a range option + error handling..\"), mdx(\"h3\", {\n    \"id\": \"voicing-reducer\"\n  }, \"Voicing Reducer\"), mdx(\"p\", null, \"Another reducer that works with chord symbols is the voicing reducer introduced \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-chords\"\n  }, \"in the last post\"), \".\\nI now removed the hard coded bass note from it.\"), mdx(\"p\", null, \"If we run the voicings reducer on the same rhythm object, we get:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythmObject({\n      duration: 8,\n      sequential: [['F', 'G'], 'C']\n    }).reduce(voicings(triads, ['C3', 'A4']), []),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythmObject({\\n    duration: 8,\\n    sequential: [['F', 'G'], 'C']\\n  }).reduce(voicings(triads, ['C3', 'A4']), [])}\\n/>\\n\"))), mdx(\"h3\", {\n    \"id\": \"running-two-reducers-on-the-same-array\"\n  }, \"Running two reducers on the same array\"), mdx(\"p\", null, \"To get chords + bassline, we could combine both reducers like this:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: function () {\n      var events = renderRhythmObject({\n        duration: 8,\n        sequential: [['F', 'G'], 'C']\n      });\n      return [].concat(_toConsumableArray(events.reduce(voicings(triads, ['C3', 'A4']), [])), _toConsumableArray(events.reduce(bassNotes, [])));\n    }(),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={(() => {\\n    const events = renderRhythmObject({\\n      duration: 8,\\n      sequential: [['F', 'G'], 'C']\\n    });\\n    return [\\n      ...events.reduce(voicings(triads, ['C3', 'A4']), []),\\n      ...events.reduce(bassNotes, [])\\n    ];\\n  })()}\\n/>\\n\"))), mdx(\"p\", null, \"But this is kind of ugly if we want to use a single function call (like needed for MDX), which requires wrapping it in an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://flaviocopes.com/javascript-iife/\"\n  }, \"IIFE\"), \".. It would be nice to have something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythmObject({\\n    duration: 8,\\n    sequential: [['F', 'G'], 'C']\\n  }).reduce(parallel([voicings(triads, ['C3', 'A4']), bassNotes]), [])}\\n/>\\n\")), mdx(\"p\", null, \"The parallel reducer will run both reducers on the same events in parallel.\"), mdx(\"h3\", {\n    \"id\": \"parallel-reducer\"\n  }, \"parallel reducer\"), mdx(\"p\", null, \"The implementation is pretty straightforward:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export const parallel: (reducers: EventReducer[]) => EventReducer = (\\n  reducers\\n) => {\\n  return (events, event, index, array) => {\\n    reducers.forEach((r) => {\\n      events = r(events, event, index, array);\\n    });\\n    return events;\\n  };\\n};\\n\")), mdx(\"p\", null, \"That\\u2019s it!\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythmObject({\n      duration: 8,\n      sequential: [['F', 'G'], 'C']\n    }).reduce(parallel([voicings(triads, ['C3', 'A4']), bassNotes]), []),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythmObject({\\n    duration: 8,\\n    sequential: [['F', 'G'], 'C']\\n  }).reduce(parallel([voicings(triads, ['C3', 'A4']), bassNotes]), [])}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"Let\\u2019s try a more sophisticated example:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythmObject({\n      duration: 64,\n      sequential: [['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', ['Dm7', 'G7'], 'C^7', '_'], ['Cm7', 'Fm7', 'Bb7', 'Eb^7'], ['Ab^7', ['Am7', 'D7'], 'G^7', '_'], ['Am7', 'D7', 'G^7', '_'], ['F#m7b5', 'B7b9', 'E^7', 'C7b13'], ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', 'DbmM7', 'Cm7', 'Bo7'], ['Bbm7', 'Eb7', 'Ab^7', ['Gm7b5', 'C7b9']]]\n    }).reduce(tieReducer(), []).reduce(parallel([voicings(lefthand, ['G3', 'G5']), bassNotes]), []),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythmObject({\\n    duration: 64,\\n    sequential: [\\n      ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'],\\n      ['Db^7', ['Dm7', 'G7'], 'C^7', '_'],\\n      ['Cm7', 'Fm7', 'Bb7', 'Eb^7'],\\n      ['Ab^7', ['Am7', 'D7'], 'G^7', '_'],\\n      ['Am7', 'D7', 'G^7', '_'],\\n      ['F#m7b5', 'B7b9', 'E^7', 'C7b13'],\\n      ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'],\\n      ['Db^7', 'DbmM7', 'Cm7', 'Bo7'],\\n      ['Bbm7', 'Eb7', 'Ab^7', ['Gm7b5', 'C7b9']]\\n    ]\\n  })\\n    .reduce(tieReducer(), [])\\n    .reduce(parallel([voicings(lefthand, ['G3', 'G5']), bassNotes]), [])}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"To make the parallel reducer work with voicings, I had to adjust the voicings reducer (see comments):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export const voicings = (dictionary, range, sorter = topNoteSort) => (events, event) => {\\n  if (typeof event.value !== 'string') {\\n    return events\\n  }\\n  let voicings = voicingsInRange(event.value, dictionary, range);\\n  const { tonic, aliases } = Chord.get(event.value);\\n  const symbol = Object.keys(dictionary).find(_symbol => aliases.includes(_symbol));\\n  if (!symbol) {\\n    console.log(`no voicings found for chord \\\"${event.value}\\\"`);\\n    return events;\\n  }\\n  let notes;\\n  // here we filter the events for having a chord set (skips bass notes)\\n  const lastVoiced = events.filter(e => !!e.chord);\\n  if (!lastVoiced.length) {\\n    notes = voicings[Math.ceil(voicings.length / 2)];\\n  } else {\\n    notes = voicings.sort(sorter(lastVoiced))[0];\\n  }\\n  // here we pass the chord symbol that generated the note\\n  return events.concat(notes.map((note) => ({ ...event, value: note, chord: event.value })));\\n\")), mdx(\"p\", null, \"In general, to make a reducer work in parallel, we need to add some filterable property (like chord property above).\\nWithout filtering, other events from parallel reducers will pollute the array (like bass notes in a voicing reducer).\"), mdx(\"h3\", {\n    \"id\": \"track-reducer\"\n  }, \"track reducer\"), mdx(\"p\", null, \"What if we want to run reducers only on a certain set of events? For example, if we add a melody, we want the voicing reducer to ignore that part. For this case, I wrote this track reducer:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export const track = (track, reducer = idleReducer) => {\\n  const trackFilter = ({ track: t }) => t === track;\\n  return (events, event, ...args) => {\\n    return trackFilter(event as any) ? reducer(events, event, ...args) : events;\\n  };\\n};\\n// if no reducer passed to track, all events are used as is\\nexport const idleReducer = (events, event) => events.concat([event]);\\n\")), mdx(\"p\", null, \"In Action:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythmObject({\n      duration: 8,\n      parallel: [{\n        track: 'melody',\n        sequential: [['A4', ['C5', 'A4'], 'B4', 'D5'], 'E5']\n      }, {\n        track: 'chords',\n        sequential: [['F', 'G'], 'C']\n      }]\n    }, [inheritProperty('track')]).reduce(parallel([track('melody'), track('chords', bassNotes), track('chords', voicings(triads, ['C3', 'G4']))]), []),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythmObject(\\n    {\\n      duration: 8,\\n      parallel: [\\n        {\\n          track: 'melody',\\n          sequential: [['A4', ['C5', 'A4'], 'B4', 'D5'], 'E5']\\n        },\\n        {\\n          track: 'chords',\\n          sequential: [['F', 'G'], 'C']\\n        }\\n      ]\\n    },\\n    [inheritProperty('track')]\\n  ).reduce(\\n    parallel([\\n      track('melody'),\\n      track('chords', bassNotes),\\n      track('chords', voicings(triads, ['C3', 'G4']))\\n    ]),\\n    []\\n  )}\\n/>\\n\"))), mdx(\"p\", null, \"Now the bassNotes and voicings reducers only run on events on the chords track, while the melody track stays as it is.\"), mdx(\"h3\", {\n    \"id\": \"mutation-inheritance\"\n  }, \"Mutation Inheritance\"), mdx(\"p\", null, \"We could also inherit mutation functions:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythmObject({\n      duration: 8,\n      parallel: [[['A4', ['C5', 'A4'], 'B4', 'D5'], 'E5'], {\n        sequential: [['F', 'G'], 'C'],\n        reducer: parallel([voicings(triads, ['C3', 'G4']), bassNotes])\n      }]\n    }, [inheritProperty('reducer')]).reduce(applyReducers(true), []).filter(function (e) {\n      return !!Note.midi(e.value);\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythmObject(\\n    {\\n      duration: 8,\\n      parallel: [\\n        [['A4', ['C5', 'A4'], 'B4', 'D5'], 'E5'],\\n        {\\n          sequential: [['F', 'G'], 'C'],\\n          reducer: parallel([voicings(triads, ['C3', 'G4']), bassNotes])\\n        }\\n      ]\\n    },\\n    [inheritProperty('reducer')]\\n  )\\n    .reduce(applyReducers(true), [])\\n    .filter((e) => !!Note.midi(e.value))} // filter out chords\\n/>\\n\"))), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export const applyReducers: (\\n  keepEventsWithoutReducer: boolean\\n) => EventReducer = (keepEventsWithoutReducer = true) => (\\n  events,\\n  event,\\n  ...args\\n) => {\\n  if (event.reducer) {\\n    events = event.reducer(events, event, ...args);\\n  }\\n  if (keepEventsWithoutReducer) {\\n    return events.concat([event]);\\n  }\\n  return events;\\n};\\n\")), mdx(\"p\", null, \"Pro\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no track reducer filter magic needed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"much shorter\")), mdx(\"p\", null, \"Contra\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"JS in JSON => not serializable\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"chords pollute final event array => need to filter non usable events\")), mdx(\"h3\", {\n    \"id\": \"thoughts-on-reducers\"\n  }, \"Thoughts on Reducers\"), mdx(\"p\", null, \"Reducers are a handy way of postprocessing events. On the other hand, it starts to get a little bit magical and untransparent when having different purpose tracks and nesting\\u2026\\nAlso, it seems kind of odd that there are now two hierarchial structures: the rhythmical object and the postprocessing tree.\"), mdx(\"h2\", {\n    \"id\": \"plugins\"\n  }, \"Plugins\"), mdx(\"p\", null, \"As opposed to reducers, plugins (previously called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-objects/#feature-encapsulation\"\n  }, \"features\"), \") are applied while the rhythmical tree is processed.\\nIt would be nice if some of the above reducer functionality could be added as plugins, for example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  events={renderRhythmObject(\\n    {\\n      duration: 8,\\n      parallel: [\\n        {\\n          sequential: [['A4', ['C5', 'A4'], 'B4', 'D5'], 'E5']\\n        },\\n        {\\n          plugin: 'chords',\\n          sequential: [['F', 'G'], 'C']\\n        }\\n      ]\\n    },\\n    [inherit('plugin'), chords({ dictionary: triads })]\\n  )}\\n/>\\n\")), mdx(\"p\", null, \"The above snippet would produce the same output as this notation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  events={renderRhythmObject({\\n    duration: 8,\\n    parallel: [\\n      {\\n        sequential: [['A4', ['C5', 'A4'], 'B4', 'D5'], 'E5']\\n      },\\n      {\\n        sequential: [\\n          [{ parallel: ['C3', 'F3', 'A3'] }, { parallel: ['D3', 'G3', 'B3'] }],\\n          { parallel: ['E3', 'G3', 'C4'] }\\n        ]\\n      }\\n    ]\\n  })}\\n/>\\n\")), mdx(\"p\", null, \"which can be rendered normally:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    events: renderRhythm({\n      duration: 8,\n      parallel: [{\n        sequential: [['A4', ['C5', 'A4'], 'B4', 'D5'], 'E5']\n      }, {\n        plugin: 'chords',\n        sequential: [[{\n          parallel: ['C3', 'F3', 'A3']\n        }, {\n          parallel: ['D3', 'G3', 'B3']\n        }], {\n          parallel: ['E3', 'G3', 'C4']\n        }]\n      }]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"h3\", {\n    \"id\": \"back-to-the-basics\"\n  }, \"back to the basics\"), mdx(\"p\", null, \"For the above ideas to work, I first needed to add more flexibility to the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://felixroos.github.io/blog/rhythmical-objects/#flattening-nested-objects\"\n  }, \"flatObject\"), \" method:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function flatObject<T>(\\n  agnostic: AgnosticChild<T>,\\n  props: FlatObjectProps<T> = {}\\n): ValueChild<T>[] {\\n  const getChildren: ChildrenResolver<T> =\\n    props.getChildren || getChildrenWithPath;\\n  // this function decides if the given child should be flattened or not\\n  const isDeep: (child: ValueChild<T>) => boolean =\\n    props.isDeep || ((child) => child.value && typeof child.value === 'object');\\n  let flat: ValueChild<T>[] = [];\\n  const children = getChildren(agnostic, props);\\n  children.forEach((child, index) => {\\n    if (typeof props.mapChild === 'function') {\\n      // this function will mutate the child\\n      child = props.mapChild({\\n        child,\\n        isLeaf: !isDeep(child),\\n        index,\\n        props,\\n        siblings: children,\\n        parent: agnostic\\n      });\\n    }\\n    if (isDeep(child)) {\\n      flat = flat.concat(flatObject(child, props));\\n    } else {\\n      flat.push(child);\\n    }\\n  });\\n  return flat;\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"isDeep can now be passed as a function to override the exit condition of the recursion\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"mapChild can be used to manipulate children before the exit condition runs\")), mdx(\"h3\", {\n    \"id\": \"new-renderrhythm-method\"\n  }, \"new renderRhythm method\"), mdx(\"p\", null, \"renderRhythmObject is now replaced by renderRhythm, which uses isDeep and mapChild:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function renderRhythm<T>(\\n  agnostic: AgnosticChild<T>,\\n  rhythmPlugins = []\\n) {\\n  const root = toObject(agnostic);\\n  const totalDuration = (root.duration || 1); // outer duration\\n  return flatObject(agnostic, {\\n    getChildren: rhythmChildren,\\n    // dont stop recursion if child has parallel or sequential props\\n    isDeep: (child) =>\\n      ['value', 'parallel', 'sequential'] // this spares the sequential child mess from earlier\\n        .reduce(\\n          (deep, prop) =>\\n            deep || (child[prop] && typeof child[prop] === 'object'),\\n          false\\n        ),\\n    // apply features to children\\n    mapChild: renderRhythmPlugins(rhythmPlugins)\\n  }).map((event) => {\\n    let { path } = event;\\n    const [time, duration] = getTimeDuration(path, totalDuration);\\n    return { ...event, time, duration, path };\\n  });\\n}\\nfunction renderRhythmPlugins(rhythmPlugins = []) {\\n  return (props) => {\\n    rhythmPlugins.forEach((plugin) => {\\n      props.child = plugin(props);\\n    });\\n    return props.child;\\n  };\\n}\\nfunction rhythmChildren<T>(agnostic: AgnosticChild<T>) {\\n  const parent = toObject(\\n    applyFeatures(agnostic, [sequentialParent, parallelParent])\\n  );\\n  const children = toArray(parent.value) || [];\\n  return children;\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"inherit-plugin\"\n  }, \"inherit plugin\"), mdx(\"p\", null, \"Now, plugins look much sexier than the old features. The \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://felixroos.github.io/blog/rhythmical-objects/#inheritance\"\n  }, \"inherit\"), \" plugin can be implemented like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function inherit(property) {\\n  return ({ child, parent }) => {\\n    return { ...child, [property]: child[property] ?? parent[property] };\\n  };\\n}\\n\")), mdx(\"details\", null, mdx(\"summary\", null, \"compare this to the old inheritProperty feature\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function inheritProperty(property) {\\n  return (_parent) => {\\n    const parent = toObject(_parent);\\n    if (!parent[property] || !parent.value) {\\n      return parent;\\n    }\\n    return {\\n      ...parent,\\n      value: toArray(parent.value).map((child) => {\\n        const childObj = toObject(child);\\n        return {\\n          ...childObj,\\n          [property]: childObj[property] || parent[property]\\n        };\\n      })\\n    };\\n  };\\n}\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"chords-plugin\"\n  }, \"chords plugin\"), mdx(\"p\", null, \"Chord voicings can be resolved like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export const chords = ({ dictionary, range }) => ({\\n  child,\\n  isLeaf,\\n  props,\\n  parent\\n}) => {\\n  if (!isLeaf || parent.chord || child.plugin !== 'chords') {\\n    // prevent infinite loop\\n    return child;\\n  }\\n  let options = voicingsInRange(\\n    child.value,\\n    child.dictionary || dictionary,\\n    child.range || range\\n  );\\n  if (props.lastVoicing) {\\n    // if not the first => voice leading\\n    const diff = (\\n      voicing // returns distance between top notes\\n    ) =>\\n      Math.abs(\\n        Note.midi(props.lastVoicing[props.lastVoicing.length - 1]) -\\n          Note.midi(voicing[voicing.length - 1])\\n      );\\n    options = options.sort((a, b) => diff(a) - diff(b)); // sort by min top note distance\\n  }\\n  props.lastVoicing = options[0]; // pick best voicing\\n  return {\\n    ...child,\\n    chord: child.value, // this is needed to stop the plugin from running again on its children\\n    value: options[0],\\n    type: 'parallel'\\n  };\\n};\\n\")), mdx(\"p\", null, \"In action:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythm({\n      duration: 8,\n      parallel: [{\n        sequential: [['A4', 'C5', 'Ab4', 'C5'], 'G4'],\n        color: 'darksalmon'\n      }, {\n        sequential: [['F', 'Fm'], 'C'],\n        plugin: 'chords',\n        velocity: 0.6\n      }]\n    }, [inherit('plugin'), inherit('color'), inherit('velocity'), chords({\n      dictionary: triads\n    })]),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythm(\\n    {\\n      duration: 8,\\n      parallel: [\\n        {\\n          sequential: [['A4', 'C5', 'Ab4', 'C5'], 'G4'],\\n          color: 'darksalmon'\\n        },\\n        {\\n          sequential: [['F', 'Fm'], 'C'],\\n          plugin: 'chords',\\n          velocity: 0.6\\n        }\\n      ]\\n    },\\n    [\\n      inherit('plugin'),\\n      inherit('color'),\\n      inherit('velocity'),\\n      chords({ dictionary: triads })\\n    ]\\n  )}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"thoughts-on-plugins\"\n  }, \"Thoughts on Plugins\"), mdx(\"p\", null, \"Comparing the above snippet with the reducer version, I like it much more.\\nThe good thing about plugins is that the structural information of the object is not yet lost.\\nBeing able to add a plugin anywhere in the tree spares all the indirect track selection stuff from earlier.\"), mdx(\"p\", null, \"The only thing that is not yet solved is running two plugins on the same source, like voicings and bass notes.\"), mdx(\"h2\", {\n    \"id\": \"multiple-mutation-data-flow\"\n  }, \"Multiple Mutation Data Flow\"), mdx(\"p\", null, \"There are different scenarios how data can flow through multiple mutations:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"sequential: data flows out of one plugin into the nexxt\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"parallel: data flows from the source into each plugin\")), mdx(\"p\", null, \"So this is basically polyphony for mutation functions!\"), mdx(\"h3\", {\n    \"id\": \"sequential-mutation\"\n  }, \"sequential mutation\"), mdx(\"p\", null, \"This applies one mutation after the other.\\nFor example, we could first apply a voicing plugin and then use the generated notes as an input of a pattern plugin:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  events={renderRhythm(\\n    {\\n      duration: 12,\\n      sequential: ['E-', 'E-', 'G', 'G', 'B-', 'B-', 'D', 'D'],\\n      mutate: [\\n        // those mutations are applied sequentially\\n        'chords',\\n        { pattern: [{ parallel: [0, 3] }, 2, { parallel: [1, 3] }, 2] }\\n      ]\\n    },\\n    [chords({ dictionary: triads }), patternPlugin]\\n  )}\\n/>\\n\")), mdx(\"p\", null, \"After only the chord mutation, it could sound like this:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    events: renderRhythm({\n      duration: 12,\n      sequential: [{\n        parallel: ['E3', 'G3', 'B3', 'E4']\n      }, {\n        parallel: ['E3', 'G3', 'B3', 'E4']\n      }, {\n        parallel: ['D3', 'G3', 'B3', 'D4']\n      }, {\n        parallel: ['D3', 'G3', 'B3', 'D4']\n      }, {\n        parallel: ['D3', 'F#3', 'B3', 'D4']\n      }, {\n        parallel: ['D3', 'F#3', 'B3', 'D4']\n      }, {\n        parallel: ['D3', 'F#3', 'A3', 'D4']\n      }, {\n        parallel: ['D3', 'F#3', 'A3', 'D4']\n      }]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"Now only the pattern mutation is left:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  events={renderRhythm({\\n    duration: 12,\\n    sequential: [\\n      { parallel: ['E3', 'G3', 'B3', 'E4'] },\\n      { parallel: ['E3', 'G3', 'B3', 'E4'] },\\n      { parallel: ['D3', 'G3', 'B3', 'D4'] },\\n      { parallel: ['D3', 'G3', 'B3', 'D4'] },\\n      { parallel: ['D3', 'F#3', 'B3', 'D4'] },\\n      { parallel: ['D3', 'F#3', 'B3', 'D4'] },\\n      { parallel: ['D3', 'F#3', 'A3', 'D4'] },\\n      { parallel: ['D3', 'F#3', 'A3', 'D4'] }\\n    ],\\n    mutate: [{ pattern: [{ parallel: [0, 3] }, 2, { parallel: [1, 3] }, 2] }]\\n  })}\\n/>\\n\")), mdx(\"p\", null, \"After the pattern mutation:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    events: renderRhythm({\n      duration: 12,\n      sequential: [[{\n        parallel: ['E3', 'E4']\n      }, 'B3', {\n        parallel: ['G3', 'E4']\n      }, 'B3'], [{\n        parallel: ['E3', 'E4']\n      }, 'B3', {\n        parallel: ['G3', 'E4']\n      }, 'B3'], [{\n        parallel: ['D3', 'D4']\n      }, 'B3', {\n        parallel: ['G3', 'D4']\n      }, 'B3'], [{\n        parallel: ['D3', 'D4']\n      }, 'B3', {\n        parallel: ['G3', 'D4']\n      }, 'B3'], [{\n        parallel: ['D3', 'D4']\n      }, 'B3', {\n        parallel: ['F#3', 'D4']\n      }, 'B3'], [{\n        parallel: ['D3', 'D4']\n      }, 'B3', {\n        parallel: ['F#3', 'D4']\n      }, 'B3'], [{\n        parallel: ['D3', 'D4']\n      }, 'A3', {\n        parallel: ['F#3', 'D4']\n      }, 'A3'], [{\n        parallel: ['D3', 'D4']\n      }, 'A3', {\n        parallel: ['F#3', 'D4']\n      }, 'A3']]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  events={renderRhythm({\\n    duration: 12,\\n    sequential: [\\n      [{ parallel: ['E3', 'E4'] }, 'B3', { parallel: ['G3', 'E4'] }, 'B3'],\\n      [{ parallel: ['E3', 'E4'] }, 'B3', { parallel: ['G3', 'E4'] }, 'B3'],\\n      [{ parallel: ['D3', 'D4'] }, 'B3', { parallel: ['G3', 'D4'] }, 'B3'],\\n      [{ parallel: ['D3', 'D4'] }, 'B3', { parallel: ['G3', 'D4'] }, 'B3'],\\n      [{ parallel: ['D3', 'D4'] }, 'B3', { parallel: ['F#3', 'D4'] }, 'B3'],\\n      [{ parallel: ['D3', 'D4'] }, 'B3', { parallel: ['F#3', 'D4'] }, 'B3'],\\n      [{ parallel: ['D3', 'D4'] }, 'A3', { parallel: ['F#3', 'D4'] }, 'A3'],\\n      [{ parallel: ['D3', 'D4'] }, 'A3', { parallel: ['F#3', 'D4'] }, 'A3']\\n    ]\\n  })}\\n/>\\n\")), mdx(\"h4\", {\n    \"id\": \"how-musicians-think\"\n  }, \"How musicians think\"), mdx(\"p\", null, \"If we look again at the notation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  events={renderRhythm(\\n    {\\n      duration: 8,\\n      sequential: ['E-', 'E-', 'G', 'G', 'B-', 'B-', 'D', 'D'],\\n      mutate: [\\n        // those mutations are applied sequentially\\n        'chords',\\n        { pattern: [{ parallel: [0, 3] }, 2, { parallel: [1, 3] }, 2] }\\n      ]\\n    },\\n    [chords({ dictionary: triads }), patternPlugin]\\n  )}\\n/>\\n\")), mdx(\"p\", null, \"This is structurally similar to how a musician would remember a piece of music by creating \\u201Cchunks\\u201D:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the info needed to play (render) the piece are abtract chunks of information (chord symbols)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"each abstract chunk has a recipe (mutation) that is applied to get to the notes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"by using mutations in a certain order, interesting results could be achieved quickly, which is good for algorithmic composition\")), mdx(\"h3\", {\n    \"id\": \"parallel-mutation\"\n  }, \"Parallel Mutation\"), mdx(\"p\", null, \"Parallel mutation will pass the same data to each plugin. For example to render chords and bass notes for a set of chord symbols:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythm(\\n    {\\n      duration: 8,\\n      sequential: [['F', 'Fm'], 'C'],\\n      mutate: { parallel: ['chords', 'bass'] }\\n    },\\n    [chords({ dictionary: triads }), bass({ octave: 2 })]\\n  )}\\n/>\\n\")), mdx(\"p\", null, \"after mutation:\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythm({\n      duration: 8,\n      parallel: [[[{\n        parallel: ['F3', 'A3', 'C3']\n      }, {\n        parallel: ['F3', 'Ab3', 'C3']\n      }], {\n        parallel: ['E3', 'G3', 'C3']\n      }], [['F2', 'F2'], 'C2']]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythm({\\n    duration: 8,\\n    parallel: [\\n      [\\n        [{ parallel: ['F3', 'A3', 'C3'] }, { parallel: ['F3', 'Ab3', 'C3'] }],\\n        { parallel: ['E3', 'G3', 'C3'] }\\n      ],\\n      [['F2', 'F2'], 'C2']\\n    ]\\n  })}\\n/>\\n\")), mdx(\"p\", null, \"As this post now exceeds the limit of 1000 lines, I will stop here and implement polyphonic mutation in another post.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"With reducers and plugins, many musical abstractions can be achieved.\\nSome are more practical using reducers (like micro time adjustems e.g. swing), others are easier implemented using plugins (anything that needs structural info).\"), mdx(\"p\", null, \"I cannot wait to finish the mutation data flow and play around with it!\\nWhen it\\u2019s done, many possibilities are open, like grooves, arpeggios, patterns, melodies etc..\"), mdx(Player, {\n    instruments: {\n      tinypiano: tinypiano\n    },\n    fold: false,\n    events: renderRhythm({\n      duration: 64,\n      plugin: 'chords',\n      sequential: [['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', ['Dm7', 'G7'], 'C^7', 'C^7'], ['Cm7', 'Fm7', 'Bb7', 'Eb^7'], ['Ab^7', ['Am7', 'D7'], 'G^7', 'G^7'], ['Am7', 'D7', 'G^7', 'G^7'], ['F#m7b5', 'B7b9', 'E^7', 'C7b13'], ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', 'DbmM7', 'Cm7', 'Bo7'], ['Bbm7', 'Eb7', 'Ab^7', ['Gm7b5', 'C7b9']]]\n    }, [inherit('plugin'), chords({\n      dictionary: lefthand,\n      range: ['G3', 'G5']\n    })]),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  instruments={{ tinypiano }}\\n  fold={false}\\n  events={renderRhythm(\\n    {\\n      duration: 64,\\n      plugin: 'chords',\\n      sequential: [\\n        ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'],\\n        ['Db^7', ['Dm7', 'G7'], 'C^7', 'C^7'],\\n        ['Cm7', 'Fm7', 'Bb7', 'Eb^7'],\\n        ['Ab^7', ['Am7', 'D7'], 'G^7', 'G^7'],\\n        ['Am7', 'D7', 'G^7', 'G^7'],\\n        ['F#m7b5', 'B7b9', 'E^7', 'C7b13'],\\n        ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'],\\n        ['Db^7', 'DbmM7', 'Cm7', 'Bo7'],\\n        ['Bbm7', 'Eb7', 'Ab^7', ['Gm7b5', 'C7b9']]\\n      ]\\n    },\\n    [inherit('plugin'), chords({ dictionary: lefthand, range: ['G3', 'G5'] })]\\n  )}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"tbd\"\n  }, \"TBD\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"find way to implement tieReducer as plugin (cannot use ties in above)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"implement polyphonic mutations\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/rhythmical-reducers/","title":"Rhythmical Mutations","tags":[],"keywords":[],"date":"August 02, 2020","image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAACQklEQVQozwE3Asj9AGIwhQJhMokCAJrrADBYvAAJi6IAAJKsAACqhgAAyXYAAMl6ACtXKAFxcicDjKs0E3ypNBXUbTA0328sPMw3TELUIFVIwx9qSscViFrBGIE5AGEwhABhMYgAGIDWA0dMtAccgpoQGoKlFQWqfycAzHpFAMNsQgDISUQHwklDpKMvQ7GkLUOmcS8rrl8qJ4hhZiGJX4keNWqhJQB7yzEAdb8fAGAxhTtjLoJHKVikRBVlukUAhalCAKmyRAGdlDY+oFQjPZ9VJGKkMiRMpzkmAMlONADHSzUAx3RNANB5VACdkVsAlaJjEHefXilYrWcmXKhCAGo0kSFoNpImjCiDJpYjiyXNHl0v+QxQNt0/PUPoZSlbzXItWaKrMGGUqTNfDsFHWwPER1sHuWdJAr5uRQajmUgAp7pMEYOoQSNYrT0iXqgoAGMxhlBfMoZgoyOHYcMbkGa4KG5dxyteXLo9T0+6YCZBrW4uQp+uMkeOqzRGCsNIRQDGSEQDt2dGALxtSAWbjUIAlqdDEX2kOSZguzQjY7IiAFstezZXLXtAmiOBPbcbjD29KGpF1ClhTsRATUjHZChEuG8vQpqqMUGSpzI9D7xGKADCRyYFvWYXAMZ5FQyYAAMA5uoAFY7GACRdtAAjYrIAAGUyiUJiMolOmySFQr4cjEOuJHEruCROHMA7Thj5hTQQ/m83CqamMACLpjIADL9HAADDRwAEvGYAAMN3ABKHAAAA2uECE5PHASVdtwEkZLQBL3/IMtJsNf8AAAAASUVORK5CYII=","aspectRatio":2.816901408450704,"src":"/blog/static/2d12fc78e621c58d7e7bc4dc7bbf0f4c/ee604/pianoroll-color.png","srcSet":"/blog/static/2d12fc78e621c58d7e7bc4dc7bbf0f4c/69585/pianoroll-color.png 200w,\n/blog/static/2d12fc78e621c58d7e7bc4dc7bbf0f4c/497c6/pianoroll-color.png 400w,\n/blog/static/2d12fc78e621c58d7e7bc4dc7bbf0f4c/ee604/pianoroll-color.png 800w,\n/blog/static/2d12fc78e621c58d7e7bc4dc7bbf0f4c/f3583/pianoroll-color.png 1200w,\n/blog/static/2d12fc78e621c58d7e7bc4dc7bbf0f4c/58d86/pianoroll-color.png 1218w","sizes":"(max-width: 800px) 100vw, 800px"}}},"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"2b49a6a1-d665-5745-b2b9-71579ed46c30","excerpt":"To bring rhythmical one step closer to being a hackable backing track player, I want to implement one of the most important things: chordâ€¦","slug":"/rhythmical-chords/","title":"Rhythmical Chords","date":"July 30, 2020"},"next":{"__typename":"MdxBlogPost","id":"e4b24033-4328-5d37-86d0-53a94a1f1495","excerpt":"In the  rhythmical chords post \nI talked about two possible methods to generate chord voicings and implemented the first of them: voicingâ€¦","slug":"/voicing-permutation/","title":"Voicing Permutation","date":"August 11, 2020"}},"pageContext":{"id":"35bc9fc8-9385-5688-a480-3383b7827fb8","previousId":"2b49a6a1-d665-5745-b2b9-71579ed46c30","nextId":"e4b24033-4328-5d37-86d0-53a94a1f1495"}},"staticQueryHashes":["386998304","4198970465","764694655"]}