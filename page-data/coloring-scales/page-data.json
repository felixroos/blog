{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/coloring-scales/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"741b6b01-5d98-5094-b22b-3a1406e358fc","excerpt":"After we found a basic way of  coloring pitches , let's now look at a way to color scales. Chroma Center This is the C major scale in aâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar chromaticCircle = Array.from({\n  length: 12\n}, function (_, i) {\n  return Note.get(Note.fromMidi(i)).pc;\n});\n\nvar mirrorAxis = function mirrorAxis(scale) {\n  var center = chromaCenter(scaleChroma(scale));\n  return {\n    source: center * 2,\n    target: (center + 6) * 2\n  };\n};\n\nvar numberedCircle = function numberedCircle(scale) {\n  return mdx(ConnectedCircle, {\n    margin: 3,\n    nodes: Array.from({\n      length: 24\n    }, function (_, id) {\n      return _objectSpread({\n        id: id,\n        value: Math.floor(id / 2) / 12\n      }, id % 2 === 0 ? {\n        stroke: 'black',\n        fill: 'white',\n        color: 'black',\n        label: id / 2,\n        distance: 120\n      } : {\n        fill: Scale.get(scale).notes.includes(chromaticCircle[(id - 1) / 2]) ? 'steelblue' : 'gray',\n        color: 'white',\n        label: chromaticCircle[(id - 1) / 2],\n        distance: 80\n      });\n    }),\n    links: [mirrorAxis(scale)],\n    r: 80,\n    nodeRadius: 16,\n    mdxType: \"ConnectedCircle\"\n  });\n};\n\nvar circleOfFifths = Array.from({\n  length: 12\n}, function (_, i) {\n  return Note.get(Note.fromMidi(60 + i * 7 % 12)).pc;\n});\n\nvar scaleColor = function scaleColor(scale) {\n  return chromaColor(scaleChroma(scale));\n};\n\nvar familyScales = function familyScales(family) {\n  return mdx(\"ul\", {\n    style: {\n      margin: 0\n    }\n  }, circleOfFifths.map(function (tonic) {\n    return mdx(\"li\", {\n      style: {\n        marginBottom: 2,\n        listStyle: 'none',\n        display: 'flex'\n      },\n      key: tonic\n    }, Scale.modeNames(\"\".concat(tonic, \" \").concat(family)).map(function (_ref, i) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          root = _ref2[0],\n          scale = _ref2[1];\n\n      return mdx(\"span\", {\n        style: {\n          backgroundColor: scaleColor(\"\".concat(root, \" \").concat(scale)),\n          marginRight: 2,\n          padding: 2\n        },\n        key: i\n      }, root, \" \", scale);\n    }));\n  }));\n};\n\nvar _frontmatter = {\n  \"title\": \"Coloring Musical Scales\",\n  \"date\": \"2021-01-02T00:00:00.000Z\",\n  \"keywords\": [\"tools\", \"music theory\"]\n};\nvar layoutProps = {\n  chromaticCircle: chromaticCircle,\n  mirrorAxis: mirrorAxis,\n  numberedCircle: numberedCircle,\n  circleOfFifths: circleOfFifths,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref3) {\n  var components = _ref3.components,\n      props = _objectWithoutProperties(_ref3, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"After we found a basic way of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../coloring-pitches\"\n  }, \"coloring pitches\"), \", let\\u2019s now look at a way to color scales.\"), mdx(\"h2\", {\n    \"id\": \"chroma-center\"\n  }, \"Chroma Center\"), mdx(\"p\", null, \"This is the C major scale in a chromatic circle, indexed from 0 to 11:\"), mdx(\"div\", null, numberedCircle('C major')), mdx(\"p\", null, \"If we now add all indices of active notes inside modulo 12, we get:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(0 + 2 + 4 + 5 + 7 + 9 + 11) % 12 = 2\\n\")), mdx(\"p\", null, \"\\u2026 which is the index of D. Interestingly, D is the only place we can put a mirroring axis that won\\u2019t change the notes after reflection.\\nLet\\u2019s call this the chroma center. We can calculate it for any chroma like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export default function chromaCenter(chroma: string) {\\n  const digits = chroma.split('');\\n  const ones = digits.map((d, i) => d === '1' ? i : -1).filter(i => i !== -1);\\n  return ones.reduce((sum, i) => i + sum, 0) % 12;\\n}\\n\")), mdx(\"p\", null, \"Here, we are summing all indices that contain \\u201C1\\u201D inside mod 12.\"), mdx(\"details\", null, mdx(\"summary\", null, \"What is a chroma?\"), mdx(\"p\", null, \"A chroma is a string with 12 characters that represent a set of pitches with a combination of 1s and 0s.\\nA 1 means that the note is in the set, a zero means not.\\nThe 12 characters represent all chromatic notes going from C to B.\\nFor example, the chroma of C major is 101011010101:\"), mdx(\"pre\", null, \"101011010101 \\nC D EF G A B\")), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"scale-colors\"\n  }, \"Scale Colors\"), mdx(\"p\", null, \"Now, we can use the chroma center for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/d3/d3-scale-chromatic#cyclical\"\n  }, \"cyclical color interpolation\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import { interpolateSinebow } from 'd3-scale-chromatic';\\nimport chromaCenter from './chromaCenter';\\n\\nexport default function chromaColor(chroma) {\\n  return interpolateSinebow(chromaCenter(chroma) / 12);\\n}\\n\")), mdx(\"p\", null, \"\\u2026 and run it on all diatonic scales:\"), mdx(\"div\", null, familyScales('major')), mdx(\"br\", null), \"Here, we can see that scales that contain the same notes have the same color.\", mdx(\"details\", null, mdx(\"summary\", null, \"Show Source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export const circleOfFifths = Array.from({ length: 12 }, (_, i) => Note.get(Note.fromMidi(60 + ((i * 7) % 12))).pc);\\nexport const scaleColor = (scale) => chromaColor(scaleChroma(scale));\\nexport const familyScales = (family) => (\\n  <ul style={{ margin: 0 }}>\\n    {circleOfFifths.map((tonic) => (\\n      <li style={{ marginBottom: 2, listStyle: 'none', display: 'flex' }} key={tonic}>\\n        {Scale.modeNames(`${tonic} ${family}`).map(([root, scale], i) => (\\n          <span style={{ backgroundColor: scaleColor(`${root} ${scale}`), marginRight: 2, padding: 2 }} key={i}>\\n            {root} {scale}\\n          </span>\\n        ))}\\n      </li>\\n    ))}\\n  </ul>\\n);\\n\\n<div>{familyScales('major')}</div>;\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"more-scales\"\n  }, \"More Scales\"), mdx(\"p\", null, \"Modes of Harmonic Minor:\"), mdx(\"div\", null, familyScales('harmonic minor')), mdx(\"p\", null, \"Modes of Melodic Minor:\"), mdx(\"div\", null, familyScales('melodic minor')), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"issue-same-color-for-different-scales\"\n  }, \"Issue: Same Color for Different Scales\"), mdx(\"p\", null, \"While the coloring inside one scale family works, we can see that some scales across families have the same color, for example C melodic minor and C mixoldian.\"), mdx(\"p\", null, \"This is because the center is the same for both:\"), mdx(\"div\", {\n    style: {\n      display: 'flex'\n    }\n  }, mdx(\"div\", null, mdx(\"center\", null, \"C melodic minor\"), numberedCircle('C melodic minor')), mdx(\"div\", null, mdx(\"center\", null, \"C mixolydian\"), numberedCircle('C mixolydian'))), mdx(\"p\", null, \"We can also double check this by calculating the chroma center:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"(0 + 2 + 3 + 5 + 7 + 9 + 11) % 12 = 1 // C melodic minor\\n(0 + 2 + 4 + 5 + 7 + 9 + 10) % 12 = 1 // C mixolydian\\n\")), mdx(\"p\", null, \"Still, this way of coloring chromas is very helpful to differentiate different tonal centers inside the same scale family.\"), mdx(\"p\", null, \"That\\u2019s it for today, the next color post will be about scale light and darkness to diversify the colors.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/coloring-scales/","title":"Coloring Musical Scales","tags":[],"keywords":["tools","music theory"],"date":"January 02, 2021","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"ac2b32d3-ca18-596f-89a7-db1f04563617","excerpt":"With the Web MIDI API, we can send and receive MIDI events from javascript.\nThis allows us to trigger notes on any instrument! Turning MIDIâ€¦","slug":"/webmidi/","title":"Using MIDI with JavaScript","date":"December 30, 2020"},"next":{"__typename":"MdxBlogPost","id":"ce7d60f2-ecd4-51b0-9f20-f3c29a05b10b","excerpt":"Let's explore the world of pitch class sets. Harmonic & Chromatic Circles There are (at least) two ways we can represent 12 notes in aâ€¦","slug":"/pitch-class-sets/","title":"Pitch Class Sets","date":"January 03, 2021"}},"pageContext":{"id":"741b6b01-5d98-5094-b22b-3a1406e358fc","previousId":"ac2b32d3-ca18-596f-89a7-db1f04563617","nextId":"ce7d60f2-ecd4-51b0-9f20-f3c29a05b10b"}},"staticQueryHashes":["386998304","4198970465","764694655"]}