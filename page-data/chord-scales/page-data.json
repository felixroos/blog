{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/chord-scales/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"3ec70d92-3605-5364-bf05-f00d32dd021f","excerpt":"To build a hackable backing track player, we already laid the foundation of  rhythm  and  harmony .\nWhat's missing: Melodies.\nEven if weâ€¦","body":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar chordScale = function chordScale(chord, scale, harmonic) {\n  var smallCircle = {\n    r: 90,\n    nodeRadius: 16\n  };\n\n  var _Scale$get = Scale.get(scale),\n      scaleNotes = _Scale$get.notes,\n      scaleTonic = _Scale$get.tonic;\n\n  var _Chord$get = Chord.get(chord),\n      chordNotes = _Chord$get.notes,\n      chordTonic = _Chord$get.tonic;\n\n  var pcChromas = function pcChromas(notes) {\n    return notes.map(function (pc) {\n      return Note.get(pc).chroma;\n    });\n  };\n\n  var scaleSet = pcChromas(scaleNotes.concat([scaleTonic]));\n  var chordSet = pcChromas(chordNotes.concat([chordTonic]));\n\n  var circle = _objectSpread({\n    label: \"\".concat(chord, \" \").concat(scale),\n    sets: [{\n      stroke: scaleColor(scale),\n      set: scaleSet\n    }, {\n      stroke: 'steelblue',\n      set: chordSet\n    }],\n    pitches: scaleNotes,\n    tonic: scaleTonic\n  }, smallCircle);\n\n  return mdx(\"div\", null, harmonic ? mdx(HarmonicCircle, _extends({}, circle, {\n    mdxType: \"HarmonicCircle\"\n  })) : mdx(ChromaticCircle, _extends({}, circle, {\n    mdxType: \"ChromaticCircle\"\n  })));\n};\n\nvar solarChords = ['CmM7', 'Gm7', 'C7', 'F^7', 'Fm7', 'Bb7', 'Eb^7', 'Ebm7', 'Ab7', 'Db^7', 'Dm7b5', 'G7b9', 'CmM7'];\nvar solarScales = scaleModes('major', 'melodic minor', 'harmonic minor'); //export const solarScales = pentatonicScales;\n//export const solarScales = ['major', 'dorian', 'lydian', 'mixolydian', 'aeolian', 'phrygian dominant', 'locrian 6', 'harmonic minor'];\n\nvar attyaScales = scaleModes('major', 'melodic minor', 'harmonic minor');\nvar attyaChords = ['Fm7', 'Bbm7', 'Eb7', 'Ab^7', 'Db^7', 'Dm7', 'G7', 'C^7', 'C^7', 'Cm7', 'Fm7', 'Bb7', 'Eb^7', 'Ab^7', 'Am7', 'D7', 'G^7', 'G^7', 'Am7', 'D7', 'G^7', 'G^7', 'F#h7', 'B7b9', 'E^7', 'C7b13', 'Fm7', 'Bbm7', 'Eb7', 'Ab^7', 'Db^7', 'DbmM7', 'Cm7', 'Bo7', 'Bbm7', 'Eb7', 'Ab^7', 'Gh7', 'C7b9'];\nvar _frontmatter = {\n  \"title\": \"Chord Scales\",\n  \"date\": \"2021-04-11T00:00:00.000Z\",\n  \"image\": \"./img/chord-scales-scrot.png\"\n};\nvar layoutProps = {\n  chordScale: chordScale,\n  solarChords: solarChords,\n  attyaScales: attyaScales,\n  attyaChords: attyaChords,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"To build a hackable backing track player, we already laid the foundation of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-objects/\"\n  }, \"rhythm\"), \" and \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-chords/\"\n  }, \"harmony\"), \".\\nWhat\\u2019s missing: Melodies.\\nEven if we just want a backing track player, playing melodies is required for basslines, or any kind of melodic fill in.\"), mdx(\"p\", null, \"So far, we were generating voicings from chord symbols. The problem: melodies will eventually use notes that are not a chord note.\\nTherefore, we need a way to find scales that fit to chord changes.\"), mdx(\"h2\", {\n    \"id\": \"problem-chord-scale-ambiguity\"\n  }, \"Problem: Chord Scale Ambiguity\"), mdx(\"p\", null, \"The main problem when searching for chord scales: most of the time, there are serveral scales that could be played over a single chord.\\nAnd it depends on the surrounding chords which scale choices are better than others.\\nHere is a video where Barry Harris talks about chords vs keys:\"), mdx(\"iframe\", {\n    width: \"560\",\n    height: \"315\",\n    src: \"https://www.youtube.com/embed/3V2eNh8qWVo\",\n    title: \"YouTube video player\",\n    frameBorder: \"0\",\n    allow: \"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\",\n    allowFullScreen: true\n  }), mdx(\"p\", null, \"This is the chord they are talking about:\"), mdx(NestedGrid, {\n    rows: [1],\n    innerBorders: true,\n    outerBorders: false,\n    cells: mapNestedArray([['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', ['Dm7', 'G7'], 'C^7', '%'], ['Cm7', 'Fm7', 'Bb7', 'Eb^7'], ['Ab^7', ['Am7', 'D7'], 'G^7', '%'], ['Am7', 'D7', 'G^7', '%'], ['F#m7b5', 'B7b9', 'E^7', 'C7b13'], ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', 'DbmM7', 'Cm7', 'Bo7'], ['Bbm7', 'Eb7', 'Ab^7', ['Gm7b5', 'C7b9']]], function (e, i, a) {\n      if (e === 'Cm7' && i === 2) {\n        return mdx(\"div\", {\n          style: {\n            backgroundColor: 'steelblue',\n            color: 'white'\n          }\n        }, e);\n      }\n\n      return e;\n    }),\n    mdxType: \"NestedGrid\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"He says: \\u201CWhen you see a C minor in the key of Ab, it\\u2019s not necessarily the C minor 7 that\\u2019s in the key of Bb,\\nso I cannot put a D natural in it. It\\u2019s the Ab major scale.\\u201D\"), mdx(\"p\", null, \"In other words: As the Cm7 appears as in the context of Ab major, it can be seen as the 3rd step chord,\\nwhich is based on the phrygian mode, which has a b9.\\nSo you would prefer phrygian over aeolian or dorian if you want to stay in Ab major.\"), mdx(\"h3\", {\n    \"id\": \"a-little-sidenote\"\n  }, \"A Little Sidenote\"), mdx(\"p\", null, \"There are some people (including Barry Harris), that do not like the chord / scale approach.\\nOne reason is that the original jazz artists most certainly did not think that way.\\nI still like having scale names as a means to express note material that exceeds 4 notes.\\nIf you would want to express more than 4 notes as chord symbols, it gets ugly.\"), mdx(\"p\", null, \"Don\\u2019t take the sentence \\u201Cscale X can be played over chord Y\\u201D too seriously.. It does not mean\\nyou should be playing the scale up and down, it just means those 7 notes fit over the chord.\"), mdx(\"h3\", {\n    \"id\": \"hello-251\"\n  }, \"Hello 251\"), mdx(\"p\", null, \"Let\\u2019s dial back a little bit, and start with the \\u201CHello World\\u201D of jazz chord progressions, the 251 in C major: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dm7 G7 C^7\"), \".\"), mdx(\"p\", null, \"When only using the 7 modes of the major scale (diatonic scales), there are 3 scales that could be played over the D minor 7 chord:\"), mdx(State, {\n    initial: {\n      harmonic: true\n    },\n    mdxType: \"State\"\n  }, function (_ref2) {\n    var state = _ref2.state,\n        setState = _ref2.setState;\n    return mdx(React.Fragment, null, mdx(\"label\", null, \"chromatic\", mdx(Switch, {\n      checked: state.harmonic,\n      color: \"default\",\n      onChange: function onChange(e) {\n        return setState({\n          harmonic: e.target.checked\n        });\n      },\n      mdxType: \"Switch\"\n    }), \"harmonic\"), mdx(\"div\", {\n      style: {\n        display: 'flex',\n        justifyContent: 'center'\n      }\n    }, chordScale('Dm7', 'D dorian', state.harmonic), chordScale('Dm7', 'D aeolian', state.harmonic), chordScale('Dm7', 'D phrygian', state.harmonic)), mdx(\"p\", null, \"There is only one (diatonic) scale that can be played over a the G7 chord:\"), mdx(\"center\", null, mdx(\"div\", null, chordScale('G7', 'G mixolydian', state.harmonic))), mdx(\"p\", null, \"There are 2 scales that could be played over a the C major 7 chord:\"), mdx(\"div\", {\n      style: {\n        display: 'flex',\n        justifyContent: 'center'\n      }\n    }, chordScale('C^7', 'C lydian', state.harmonic), chordScale('C^7', 'C major', state.harmonic)));\n  }), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"scale-graph\"\n  }, \"Scale Graph\"), mdx(\"p\", null, \"We can visualize the transitions between the possible scales in a graph like this:\"), mdx(Graph, {\n    json: {\n      graph: _objectSpread({\n        directed: true\n      }, chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major'), true))\n    },\n    mdxType: \"Graph\"\n  }), mdx(\"br\", null), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each column shows the possible scales for one chord, with the arrows representing transitions between scales.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The numbers indicate the number of accidentals that change between scales. We can use them to evaluate how smooth the scale transition will be.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The colorization is used like described in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"coloring-scales/\"\n  }, \"this post\"), \".\")), mdx(\"p\", null, \"Using this representation, we can turn it into a path finding problem.\"), mdx(\"h3\", {\n    \"id\": \"choice-tree\"\n  }, \"Choice Tree\"), mdx(\"p\", null, \"Navigating the graph above, we can follow one of 6 possible paths:\"), mdx(Graph, {\n    json: {\n      graph: {\n        directed: true,\n        nodes: [{\n          label: 'start',\n          id: '0'\n        }, {\n          label: 'D dorian',\n          id: '0.0:D dorian',\n          fillcolor: '#e9e93c',\n          style: 'filled'\n        }, {\n          label: 'G mixolydian',\n          id: '0.1:G mixolydian',\n          fillcolor: '#e9e93c',\n          style: 'filled'\n        }, {\n          label: 'C major',\n          id: '0.2:C major',\n          fillcolor: '#e9e93c',\n          style: 'filled'\n        }, {\n          label: 'C lydian',\n          id: '1.2:C lydian',\n          fillcolor: '#b2e580',\n          style: 'filled'\n        }, {\n          label: 'D aeolian',\n          id: '2.0:D aeolian',\n          fillcolor: '#e5b380',\n          style: 'filled'\n        }, {\n          label: 'G mixolydian',\n          id: '2.1:G mixolydian',\n          fillcolor: '#e9e93c',\n          style: 'filled'\n        }, {\n          label: 'C major',\n          id: '2.2:C major',\n          fillcolor: '#e9e93c',\n          style: 'filled'\n        }, {\n          label: 'C lydian',\n          id: '3.2:C lydian',\n          fillcolor: '#b2e580',\n          style: 'filled'\n        }, {\n          label: 'D phrygian',\n          id: '4.0:D phrygian',\n          fillcolor: '#f6afaf',\n          style: 'filled'\n        }, {\n          label: 'G mixolydian',\n          id: '4.1:G mixolydian',\n          fillcolor: '#e9e93c',\n          style: 'filled'\n        }, {\n          label: 'C major',\n          id: '4.2:C major',\n          fillcolor: '#e9e93c',\n          style: 'filled'\n        }, {\n          label: 'C lydian',\n          id: '5.2:C lydian',\n          fillcolor: '#b2e580',\n          style: 'filled'\n        }],\n        edges: [{\n          source: '0',\n          target: '0.0:D dorian',\n          label: '0'\n        }, {\n          source: '0.0:D dorian',\n          target: '0.1:G mixolydian',\n          label: '+0'\n        }, {\n          source: '0.1:G mixolydian',\n          target: '0.2:C major',\n          label: '+0=0'\n        }, {\n          source: '0',\n          target: '0.0:D dorian',\n          label: '0'\n        }, {\n          source: '0.0:D dorian',\n          target: '0.1:G mixolydian',\n          label: '+0'\n        }, {\n          source: '0.1:G mixolydian',\n          target: '1.2:C lydian',\n          label: '+1=1'\n        }, {\n          source: '0',\n          target: '2.0:D aeolian',\n          label: '0'\n        }, {\n          source: '2.0:D aeolian',\n          target: '2.1:G mixolydian',\n          label: '+1'\n        }, {\n          source: '2.1:G mixolydian',\n          target: '2.2:C major',\n          label: '+0=1'\n        }, {\n          source: '0',\n          target: '2.0:D aeolian',\n          label: '0'\n        }, {\n          source: '2.0:D aeolian',\n          target: '2.1:G mixolydian',\n          label: '+1'\n        }, {\n          source: '2.1:G mixolydian',\n          target: '3.2:C lydian',\n          label: '+1=2'\n        }, {\n          source: '0',\n          target: '4.0:D phrygian',\n          label: '0'\n        }, {\n          source: '4.0:D phrygian',\n          target: '4.1:G mixolydian',\n          label: '+2'\n        }, {\n          source: '4.1:G mixolydian',\n          target: '4.2:C major',\n          label: '+0=2'\n        }, {\n          source: '0',\n          target: '4.0:D phrygian',\n          label: '0'\n        }, {\n          source: '4.0:D phrygian',\n          target: '4.1:G mixolydian',\n          label: '+2'\n        }, {\n          source: '4.1:G mixolydian',\n          target: '5.2:C lydian',\n          label: '+1=3'\n        }]\n      }\n    },\n    mdxType: \"Graph\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"Here, the leftmost path is the optimal one, as its sum of values is 0. The worst path has a value of 3.\"), mdx(\"p\", null, \"Now we arrived at the problem for this post: How do we find the optimal path through a graph of chord scales?\"), mdx(\"h2\", {\n    \"id\": \"implementing-chord-scale-graphs\"\n  }, \"Implementing Chord Scale Graphs\"), mdx(\"p\", null, \"As we have a general idea of the problem, let\\u2019s implement this!\\nBefore we can do any path finding, we need to generate a scale graph from our chord changes.\"), mdx(\"p\", null, \"Generally, a graph consists of nodes and edges, in our domain, those are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"nodes: chord scales\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"edges: scale transitions\")), mdx(\"h3\", {\n    \"id\": \"finding-chord-scales\"\n  }, \"Finding chord scales\"), mdx(\"p\", null, \"To get our graph\\u2019s nodes, we need to find all possible scales for a chord progression. What we want is something like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const chords = ['Dm7', 'G7', 'C^7'];\\nchords.map((chord) => chordScales(chord, scaleModes('major')));\\n/*\\n[\\n  [ 'phrygian', 'aeolian', 'dorian' ],\\n  [ 'mixolydian' ],\\n  [ 'lydian', 'major' ]\\n]\\n*/\\n\")), mdx(\"p\", null, \"Instead of just using \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/tonaljs/tonal/tree/master/packages/chord#chordchordscaleschordname-string--string\"\n  }, \"Chord.chordScales\"), \", I am using a custom implementation that allows to filter the scales.\\nAs the core topic of this post should be the actual path finding, I put the details in a yellow box:\"), mdx(Card, {\n    elevation: 3,\n    mdxType: \"Card\"\n  }, mdx(CardContent, {\n    style: {\n      backgroundColor: '#E9E850'\n    },\n    mdxType: \"CardContent\"\n  }, mdx(\"details\", null, mdx(\"summary\", null, \"Show Implementation Details\"), mdx(\"h3\", {\n    \"id\": \"subsets-and-supersets\"\n  }, \"Subsets and Supersets\"), mdx(\"p\", null, \"To be able to find out which scales contain a chord, we need to understand the concept of subsets and supersets.\\nTo fully understand this, I recommend you to read my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../pitch-class-sets/\"\n  }, \"pitch class sets post\"), \" first.\"), mdx(\"p\", null, \"Sets can be related by being sub or supersets. For example, a C major chord is a subset of the C major scale. Also, the C major scale is a superset of a C major chord.\\nSo, a superset contains all notes of its subset + some more, while a subset contains some of its superset (and no others!).\"), mdx(\"p\", null, \"In tonal, we can check if chromas are subsets or supersets:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const isSupersetOfChord = (chord) => PcSet.isSupersetOf(Chord.get(chord).chroma);\\nisSupersetOfChord('M')(Scale.get('major').chroma); // true\\nisSupersetOfChord('M')(Scale.get('minor').chroma); // false\\n\\nconst isSubsetOfScale = (chord) => PcSet.isSubsetOf(Scale.get(chord).chroma);\\nisSubsetOfScale('major')(Chord.get('M').chroma); // true\\nisSubsetOfScale('major')(Chord.get('m').chroma); // false\\n\\nconst isChordScale = (scale, chord) => isSupersetOfChord(chord)(Scale.get(scale).chroma);\\nisChordScale('major', 'M'); // true\\nisChordScale('major', 'm'); // false\\n\\nconst isScaleChord = (chord, scale) => isSubsetOfScale(scale)(Chord.get(chord).chroma);\\nisScaleChord('M', 'major'); // true\\nisScaleChord('m', 'major'); // false\\n\")), mdx(\"p\", null, \"For a better understanding, let\\u2019s implement our own isSuperset function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function isSuperset(superset, subset) {\\n  const superDec = parseInt(superset, 2);\\n  const subDec = parseInt(subset, 2);\\n  return (superDec | subDec) === superDec;\\n}\\nisSuperset(Scale.get('major').chroma, Chord.get('M').chroma); // true\\nisSuperset(Scale.get('major').chroma, Chord.get('m').chroma); // false\\n\")), mdx(\"p\", null, \"Here we are using a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_OR#:~:text=The%20bitwise%20OR%20operator%20(%20%7C%20),both%20operands%20are%201%20s.\"\n  }, \"bitwise OR operator\"), \".\\nAs bitwise OR expects a decimal input, we have to convert our chromas to decimal beforehand.\\nNow, if we apply the or between superset and subset, the superset will be the result if the subset has no additional ones!\"), mdx(\"p\", null, \"For completeness, we can now implement isSubset, using isSuperset:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function isSubset(subset, superset) {\\n  return isSuperset(superset, subset);\\n}\\nisSubset(Chord.get('M').chroma, Scale.get('major').chroma); // true\\nisSubset(Chord.get('m').chroma, Scale.get('major').chroma); // false\\n\")), mdx(\"h3\", {\n    \"id\": \"chord-scales\"\n  }, \"Chord Scales\"), mdx(\"p\", null, \"Now, if we want to know which scales we can play over a certain chord, we just have to look for supersets of the chords chroma. Luckily, there is already a method in tonal:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"Chord.chordScales('^7');\\n/*\\n[\\n  'ionian pentatonic',\\n  'lydian pentatonic',\\n  'augmented',\\n  'double harmonic lydian',\\n  'lydian',\\n  'augmented heptatonic',\\n  'harmonic major',\\n  'double harmonic major',\\n  'major',\\n  'lydian #9',\\n  'purvi raga',\\n  'bebop',\\n  'bebop major',\\n  'ichikosucho',\\n  'kafi raga',\\n  \\\"messiaen's mode #3\\\",\\n  'chromatic'\\n]\\n*/\\n\")), mdx(\"p\", null, \"To understand how it works + to have more control over the output, let\\u2019s reimplent it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function chordScales(chord) {\\n  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);\\n  return Scale.names().filter((scale) => isSuperSet(Scale.get(scale).chroma));\\n}\\nchordScales('^7');\\n\")), mdx(\"h3\", {\n    \"id\": \"filtering-choices\"\n  }, \"Filtering Choices\"), mdx(\"p\", null, \"The scale above choices are pretty overwhelming. We could limit the checked scales like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function chordScales(chord, scales = Scale.names()) {\\n  const isSuperSet = PcSet.isSupersetOf(Chord.get(chord).chroma);\\n  return scales.filter((scale) => isSuperSet(Scale.get(scale).chroma));\\n}\\nchordScales('^7', ['major', 'minor', 'lydian']);\\n// ['lydian', 'major']\\n\")), mdx(\"p\", null, \"As we may want all modes of a certain scale family, we can spare us some typing with this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const oneOfModes = (families) => (scale) =>\\n  families.map((f) => Scale.get(f).normalized).includes(Scale.get(scale).normalized);\\nconst scaleModes = (...families) => Scale.names().filter(oneOfModes(families));\\nscaleModes('major');\\n/*\\n[\\n  'lydian',\\n  'locrian',\\n  'phrygian',\\n  'aeolian',\\n  'dorian',\\n  'mixolydian',\\n  'major'\\n]\\n*/\\nchordScales('^7', scaleModes('major', 'harmonic minor', 'melodic minor'));\\n// [ 'lydian', 'major', 'lydian #9' ]\\n\"))))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"scale-transitions\"\n  }, \"Scale Transitions\"), mdx(\"p\", null, \"For our graph\\u2019s edges, we need to find a way to evaluate scale transitions.\"), mdx(\"p\", null, \"To tell how much change is happening in a scale transition, we can use the chroma difference:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export const chromaDifference(a, b) => {\\n  let diff = 0;\\n  for (let i = 0; i < 12; ++i) {\\n    diff += a[i] === b[i] ? 0 : 1\\n  }\\n  return diff;\\n}\\n\")), mdx(\"p\", null, \"This function will count how much characters of two chromas are different. Example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"\\n101011010101 = C major\\n101011010110 = F major\\n__________^^ = 2 different bits\\n\\n\")), mdx(\"p\", null, \"If we divide the different bits by 2, we get the difference in accidentals:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const fromCtoG = chromaDifference(scaleChroma('C major'), scaleChroma('F major')); // 2\\nconst diff = fromCtoG / 2; // 1\\n\")), mdx(\"p\", null, \"In the final algorithm, we won\\u2019t divide by 2, as it does not bring anything new to the table.\"), mdx(\"h3\", {\n    \"id\": \"rendering-scale-graphs\"\n  }, \"Rendering Scale Graphs\"), mdx(\"p\", null, \"Now that we have our nodes (scales) and edges (scale transitions), we can generate a graph from a set of chord changes.\\nTo visualize the algorithm for development, we will use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://graphviz.org/\"\n  }, \"graphviz\"), \".\"), mdx(\"p\", null, \"As this is also just an extra implementation, I\\u2019ll put the details in a green box.\"), mdx(Card, {\n    elevation: 3,\n    mdxType: \"Card\"\n  }, mdx(CardContent, {\n    style: {\n      backgroundColor: '#C1E585'\n    },\n    mdxType: \"CardContent\"\n  }, mdx(\"details\", null, mdx(\"summary\", null, \"Show Implementation Details\"), mdx(\"p\", null, \"To be able to use JSON instead of DOT, we will use \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/jsongraph/jgf-dot\"\n  }, \"jgf-dot\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import { Graphviz } from 'graphviz-react';\\nimport toDot from 'jgf-dot';\\n\\nexport default function GraphvizJSON({ json, options }) {\\n  if (!json) {\\n    return;\\n  }\\n  const dot = toDot(json);\\n  // console.log('dot',dot);\\n  return <Graphviz dot={dot} options={options} />;\\n}\\n\")), mdx(\"p\", null, \"We can use it like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<GraphvizJSON\\n  options={{ height: 300 }}\\n  json={{\\n    graph: {\\n      directed: true,\\n      ...chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major')),\\n    },\\n  }}\\n/>\\n\")), mdx(\"p\", null, \"Finally, the chordScaleGraph function will output a json-graph that represents the scales of the given chords:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export default function chordScaleGraph(chords, allowedScales = scaleModes('major'), halfDifference = false) {\\n  const scales = chords\\n    .map((chord) => chordScales(chord, allowedScales))\\n    .map((choices) => (choices.length > 0 ? choices : ['chromatic']));\\n  let nodes = [];\\n  let links = [];\\n  scales.forEach((choices, i) => {\\n    choices\\n      .map((choice) => `${Chord.tokenize(chords[i])[0]} ${choice}`)\\n      .sort(bySetNum)\\n      .forEach((choice, j) => {\\n        if (i > 0) {\\n          const prev = scales[i - 1];\\n          prev.forEach((sourceScale, k) => {\\n            const source = nodes.length - j - prev.length + k;\\n            const target = nodes.length;\\n            let label = chromaDifference(scaleChroma(nodes[source].label), scaleChroma(choice));\\n            if (halfDifference) {\\n              label /= 2;\\n            }\\n            links.push({ source, target, label });\\n          });\\n        }\\n        nodes.push({ label: choice, fillcolor: scaleColor(choice), style: 'filled' });\\n      });\\n  });\\n  nodes = nodes.map((node, id) => ({ ...node, id }));\\n  return { nodes, edges: links };\\n}\\n\")), mdx(\"p\", null, \"UPDATE: replaced graphviz-react by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/hpcc-systems/hpcc-js-wasm\"\n  }, \"@hpcc-js/wasm\"), \",\\nwhich is internatlly used by d3-graphviz, which is a dependency of graphviz-react.\")))), mdx(\"br\", null), mdx(\"p\", null, \"Finally, this is what we get:\"), mdx(Graph, {\n    json: {\n      graph: _objectSpread({\n        directed: true\n      }, chordScaleGraph(['Dm7', 'G7', 'C^7'], scaleModes('major'), true))\n    },\n    mdxType: \"Graph\"\n  }), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"path-finding\"\n  }, \"Path Finding\"), mdx(\"p\", null, \"As we now have all the tools we need, let\\u2019s talk about how path finding works.\"), mdx(\"h3\", {\n    \"id\": \"naive-approach\"\n  }, \"Naive Approach\"), mdx(\"p\", null, \"A naive approach for a the algorithm would be to\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"find all possible chord scales for the given progression\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"calculate all possible transition values (accidental changes)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"walk all possible paths and sum transition values\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"the path with the lowest transition value sum is the smoothest\")), mdx(\"h3\", {\n    \"id\": \"complexity\"\n  }, \"Complexity\"), mdx(\"p\", null, \"Before implementing the algorithm above, let\\u2019s think about its complexity.\\nTo find out the total number of paths, we can multiply the number of scale choices for each chord. In the 251 example, this is:\"), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"3 * 1 * 2 = 6\"), mdx(\"p\", null, \"In a common tune, there might be 32 bars of chords (and more). Even if each bar only has one chord with only 2 possible scales, we get:\"), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"2^{32} = 4294967296\"), mdx(\"p\", null, \"paths, which is quite a lot.\"), mdx(\"h3\", {\n    \"id\": \"smart-approach\"\n  }, \"Smart Approach\"), mdx(\"p\", null, \"A much more clever approach for path finding is something like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm\"\n  }, \"Dijkstra\\u2019s algorithm\"), \" or the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/A*_search_algorithm\"\n  }, \"A\", \"*\", \" algorithm\"), \".\\nThe general trick is to only calculate the transitions needed, by always following the most promising path first.\\nWe will find out what that means below..\"), mdx(\"h3\", {\n    \"id\": \"step-by-step-path-exploration\"\n  }, \"Step by Step Path Exploration\"), mdx(\"p\", null, \"Before talking code, let\\u2019s look at how the algorithm should behave, step by step.\\nTo be able to see some interesting results, we will use the progression \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Dm7 G7 C^7 Cm7 F7 Bb^7\"), \":\"), mdx(AstarChordScaleFinder, {\n    chords: ['Dm7', 'G7', 'C^7', 'Cm7', 'F7', 'Bb^7'],\n    scales: scaleModes('major'),\n    showJson: false,\n    mdxType: \"AstarChordScaleFinder\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"After pressing \\u201CStep\\u201D 9 times, it turns into \\u201CDone\\u201D, and the algorithm has found the optimal path.\\nIn this case, we have a match before we even had to check all transitions. This works because:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"At each step, the path with the lowest value is extended\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"when a path is extended, all other paths leading to its source will be ignored (as they are longer)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The algorithm finishes if the path with the lowest value reaches the end.\")), mdx(\"p\", null, \"This saves calculation time, which might seem marginal in this instance, but it will be a life saver for bigger graphs.\"), mdx(\"h2\", {\n    \"id\": \"general-algorithm\"\n  }, \"General Algorithm\"), mdx(\"p\", null, \"Let\\u2019s try to formulate the basic algorithm.\"), mdx(\"h3\", {\n    \"id\": \"connections\"\n  }, \"Connections\"), mdx(\"p\", null, \"To think about links between nodes, let\\u2019s use this type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"declare type Connection = [source: string | null, target: string, value: number];\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"source: the node we come from, null if it\\u2019s a start connection\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"target: the node we are going to\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"value: the total value to get there\")), mdx(\"p\", null, \"Inside our algorithm, we will collect the following data:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"open: connections that we can follow next\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"closed: connections that we already followed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"winner: contains the winning path when the algorithm is done\")), mdx(\"p\", null, \"Let\\u2019s again step through our example with the actual data:\"), mdx(AstarChordScaleFinder, {\n    chords: ['Dm7', 'G7', 'C^7', 'Cm7', 'F7', 'Bb^7'],\n    scales: scaleModes('major'),\n    showJson: true,\n    mdxType: \"AstarChordScaleFinder\"\n  }), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"algorithm-loop\"\n  }, \"Algorithm Loop\"), mdx(\"p\", null, \"Now, the basic algorithm loop works like this:\"), mdx(Graph, {\n    json: {\n      graph: {\n        directed: true,\n        nodes: [{\n          label: 'start',\n          id: '-1'\n        }, {\n          label: '1. find connection with minimum value',\n          fillcolor: 'steelblue',\n          style: 'filled',\n          id: 0\n        }, {\n          label: '2. leads to goal?',\n          fillcolor: 'salmon',\n          style: 'filled',\n          id: 1\n        }, {\n          label: 'stop',\n          fillcolor: 'red',\n          style: 'filled',\n          id: 2\n        }, {\n          label: '3. close that connection',\n          fillcolor: 'steelblue',\n          style: 'filled',\n          id: 3\n        }, {\n          label: '4. open all connections it leads to',\n          fillcolor: 'steelblue',\n          style: 'filled',\n          id: 4\n        }],\n        edges: [{\n          source: -1,\n          target: 0\n        }, {\n          source: 0,\n          target: 1\n        }, {\n          source: 1,\n          target: 2,\n          label: 'yes'\n        }, {\n          source: 1,\n          target: 3,\n          label: 'no'\n        }, {\n          source: 3,\n          target: 4\n        }, {\n          source: 4,\n          target: 0\n        }]\n      }\n    },\n    mdxType: \"Graph\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"or as text:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"find connection with minimum value\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"stop if minimum connection leads to goal\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"close that connection and all connections with the same target\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"open all connections it leads to\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"jump to 1\")), mdx(\"h3\", {\n    \"id\": \"implementation\"\n  }, \"Implementation\"), mdx(\"p\", null, \"After all the talking, here is the code I came up with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"import { minIndex } from 'd3-array';\\n\\nexport declare type NodeID = string;\\nexport declare type Target = [target: NodeID, value: number];\\n\\nexport function openNext(\\n  startNodes: NodeID[],\\n  endNodes: NodeID[],\\n  getTargets: (source: NodeID) => Target[],\\n  state: ConnectionState = {\\n    open: startNodes.map((node) => [null, node, 0]),\\n    closed: [],\\n    winner: false,\\n  }\\n): ConnectionState {\\n  let { open, closed } = state;\\n  const getValue = (o) => o[2];\\n  // 1. find connection with minimum value\\n  const bestIndex = minIndex(open, getValue);\\n  const best = open[bestIndex];\\n  // 2. stop if minimum connection leads to goal\\n  if (endNodes.includes(best[1])) {\\n    return { open, closed, winner: traceWinner(best) };\\n  }\\n  // 3a. close that connection\\n  closed = closed.concat([best]);\\n  const [_, newSource, distance] = best;\\n\\n  // 4. open all connections it leads to\\n  const connections: Connection[] = getTargets(newSource).map(\\n    ([target, value]): Connection => [newSource, target, distance + value]\\n  );\\n\\n  open = [...open.slice(0, bestIndex), ...connections, ...open.slice(bestIndex + 1)];\\n\\n  // 3b. close all connections that lead to already closed targets\\n  open = open.filter((c) => !closed.find(([_, target, v]) => target === c[1] && v <= getValue(c)));\\n\\n  return { open, closed, winner: false };\\n\\n  // trace back winner from closed paths\\n  function traceWinner(winner) {\\n    const path = [winner[0], winner[1]];\\n    if (!path[0]) {\\n      return [path[1]];\\n    }\\n    while (!startNodes.includes(path[0])) {\\n      const prev = closed.find((c) => c[1] === path[0]);\\n      path.unshift(prev[0]);\\n    }\\n    return path;\\n  }\\n}\\n\")), mdx(\"p\", null, \"We can run it like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export default function bestPath(\\n  startNodes: NodeID[],\\n  endNodes: NodeID[],\\n  getTargets: (source: NodeID) => Target[]\\n): any[] {\\n  let state: ConnectionState;\\n  while (true) {\\n    state = openNext(startNodes, endNodes, getTargets, state);\\n    if (state.winner) {\\n      return state.winner;\\n    }\\n  }\\n}\\n\")), mdx(\"p\", null, \"I did this seperation to be able to run openNext as a generator function for the step by step explorations.\"), mdx(\"h3\", {\n    \"id\": \"running-the-algorithm-on-chord-scales\"\n  }, \"Running the algorithm on chord scales\"), mdx(\"p\", null, \"The implementation above is a general purpose path finding algorithm.\\nWe can use it for the chord scale problem like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const getNodeID = (level, scale) => `${level}.${scale}`;\\nconst colorDiff = (source, target) => {\\n  return source && scaleChroma(source) !== scaleChroma(target) ? 1 : 0;\\n};\\nconst scaleTargets = (graph) => (nodeID) => {\\n  const [lvl, source] = nodeID.split('.');\\n  const level = parseInt(lvl);\\n  if (level >= graph.length - 1) {\\n    return [];\\n  }\\n  return graph[level + 1].map((target): Target => [\\n    getNodeID(level + 1, target),\\n    scaleDifference(source, target) + colorDiff(source, target),\\n  ]);\\n};\\n\\nexport default function bestChordScales(chords, scales = scaleModes('major', 'harmonic minor', 'melodic minor')) {\\n  const choices = chords.map((chord) => chordScales(chord, scales, true));\\n  return bestPath(\\n    choices[0].map((scale) => getNodeID(0, scale)),\\n    choices[choices.length - 1].map((scale) => getNodeID(choices.length - 1, scale)),\\n    scaleTargets(choices)\\n  ).map((node) => node.split('.')[1]);\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"running-on-real-tunes\"\n  }, \"Running On Real Tunes\"), mdx(\"p\", null, \"Now comes the fun part: let\\u2019s look if this actually works on real tunes:\"), mdx(\"h3\", {\n    \"id\": \"solar\"\n  }, \"Solar\"), mdx(\"p\", null, \"This Tune is not that long, but it has a few modulations:\"), mdx(SheetGrid, {\n    rows: [1],\n    measures: [['CmM7', 'CmM7', 'Gm7', 'C7'], ['F^7', 'F^7', 'Fm7', 'Bb7'], ['Eb^7', ['Ebm7', 'Ab7'], 'Db^7', ['Dm7b5', 'G7b9']]],\n    rawText: true,\n    noColors: true,\n    mdxType: \"SheetGrid\"\n  }), mdx(\"br\", null), mdx(AstarChordScaleFinder, {\n    chords: solarChords,\n    scales: solarScales,\n    mdxType: \"AstarChordScaleFinder\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"If we compare the finished graph above with a graph that includes every possible connection, we see how much work we could save:\"), mdx(Card, {\n    elevation: 3,\n    mdxType: \"Card\"\n  }, mdx(CardContent, {\n    style: {\n      maxHeight: 500,\n      overflow: 'auto'\n    },\n    mdxType: \"CardContent\"\n  }, mdx(Graph, {\n    options: {\n      fit: true,\n      height: 700,\n      width: 600\n    },\n    json: {\n      graph: _objectSpread({\n        directed: true\n      }, chordScaleGraph(solarChords, solarScales))\n    },\n    mdxType: \"Graph\"\n  }))), mdx(\"br\", null), mdx(\"p\", null, \"Using the result of the algorithm, here is a colored version of the sheet:\"), mdx(SheetGrid, {\n    rows: [1],\n    measures: [['CmM7', 'CmM7', 'Gm7', 'C7'], ['F^7', 'F^7', 'Fm7', 'Bb7'], ['Eb^7', ['Ebm7', 'Ab7'], 'Db^7', ['Dm7b5', 'G7b9']]],\n    rawText: true,\n    noColors: false,\n    innerBorders: false,\n    mdxType: \"SheetGrid\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"Problem: A set of changes is mostly played in a loop, but the result has a break between the end and the beginning.\\nInstead of C melodic minor, we could play harmonic minor at the beginning to better fit the ending.\"), mdx(\"p\", null, \"Possible Solution: We could put the sheet 3 times in sequence:\"), mdx(SheetGrid, {\n    rows: [1],\n    measures: [['CmM7', 'CmM7', 'Gm7', 'C7'], ['F^7', 'F^7', 'Fm7', 'Bb7'], ['Eb^7', ['Ebm7', 'Ab7'], 'Db^7', ['Dm7b5', 'G7b9']], ['CmM7', 'CmM7', 'Gm7', 'C7'], ['F^7', 'F^7', 'Fm7', 'Bb7'], ['Eb^7', ['Ebm7', 'Ab7'], 'Db^7', ['Dm7b5', 'G7b9']], ['CmM7', 'CmM7', 'Gm7', 'C7'], ['F^7', 'F^7', 'Fm7', 'Bb7'], ['Eb^7', ['Ebm7', 'Ab7'], 'Db^7', ['Dm7b5', 'G7b9']]],\n    rawText: true,\n    noColors: false,\n    innerBorders: false,\n    mdxType: \"SheetGrid\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"\\u2026 and cut out the middle:\"), mdx(SheetGrid, {\n    rows: [1],\n    measures: [['CmM7', 'CmM7', 'Gm7', 'C7'], ['F^7', 'F^7', 'Fm7', 'Bb7'], ['Eb^7', ['Ebm7', 'Ab7'], 'Db^7', ['Dm7b5', 'G7b9']]],\n    rawText: true,\n    noColors: false,\n    innerBorders: false,\n    loop: true,\n    mdxType: \"SheetGrid\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"With this, we have a loopable version of the chord scales.. Of course, in practice, we can decide when to switch colors.\"), mdx(\"h3\", {\n    \"id\": \"all-the-things-you-are\"\n  }, \"All The Things You Are\"), mdx(\"p\", null, \"As a last example, we can go full circle and run this on All The Things You Are\"), mdx(AstarChordScaleFinder, {\n    chords: attyaChords,\n    scales: attyaScales,\n    mdxType: \"AstarChordScaleFinder\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"full graph:\"), mdx(Card, {\n    elevation: 3,\n    mdxType: \"Card\"\n  }, mdx(CardContent, {\n    style: {\n      maxHeight: 500,\n      overflow: 'auto'\n    },\n    mdxType: \"CardContent\"\n  }, mdx(Graph, {\n    options: {\n      fit: true,\n      height: 1200,\n      width: 600\n    },\n    json: {\n      graph: _objectSpread({\n        directed: true\n      }, chordScaleGraph(attyaChords, attyaScales))\n    },\n    mdxType: \"Graph\"\n  }))), mdx(\"br\", null), mdx(\"p\", null, \"And finally, this is how the colored version of this sheet looks like:\"), mdx(SheetGrid, {\n    rows: [1],\n    measures: [['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', ['Dm7', 'G7'], 'C^7', 'C^7'], ['Cm7', 'Fm7', 'Bb7', 'Eb^7'], ['Ab^7', ['Am7', 'D7'], 'G^7', 'G^7'], ['Am7', 'D7', 'G^7', 'G^7'], ['F#m7b5', 'B7b9', 'E^7', 'C7b13'], ['Fm7', 'Bbm7', 'Eb7', 'Ab^7'], ['Db^7', 'DbmM7', 'Cm7', 'Bo7'], ['Bbm7', 'Eb7', 'Ab^7', ['Gm7b5', 'C7b9']]],\n    rawText: true,\n    noColors: false,\n    innerBorders: false,\n    mdxType: \"SheetGrid\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"Looking at the Cm7 chord we talked about at the beginning of this post, we see that it is correctly\\nrecognized as part of Ab major! So Barry Harris would be proud\\u2026 \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=iDozKWsGTSM\"\n  }, \"Maybe not\"), \".\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"Now we can automatically detect how chords go together in a tune. This opens a wide field of possibilities, for example:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Generating chord substitutions from scales, using 9ths 11ths and 13ths\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"\\u201CYou should know the rules to know how to break them\\u201D: The scales we get can be seen as a zero point of tension. We can gradually add tension by altering the scales.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Generating Melodies / Basslines\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Roman Numeral Analysis\")), mdx(\"h2\", {\n    \"id\": \"links\"\n  }, \"Links\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=gGQ-vAmdAOI\"\n  }, \"Search: Optimal, Branch and Bound, Astar @MIT\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=GazC3A4OQTE\"\n  }, \"Computerphile: Dijkstra\\u2019s Algorithm\"))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/chord-scales/","title":"Chord Scales","tags":[],"keywords":[],"date":"April 11, 2021","image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABzElEQVQozz2RW28SYRCG+ZVeeOeN114ZE/+AiTVpTI3ihamJQSG0Vavd1lKUymkXWPbb8wFktxDANhQKNdoUeFxq4mQyySQzb955JsFyuUqufv+i9T2DvP2UlqZgZjKI3CHKa4nqWhqnUKe4nkZLHWFWD5Gz61TSa/jqAe1Uh+BewKQ8IbFYLJheTImiiI5nEnoCxzJRyxVMrYnT0BEFGa2u4igCQ1aRlQo/LJUontVUBU/1GdaGTM+mJIhjOpvx+ZXKx414weryoFbldqnMfd/j2LFR02/R0+/oWTqPdMGtYhEpOuFiPGLf3GTPesHPWX8lRWI8GhPZIaHfRZPt2ImB8H1Khk3+OHYpDALbRi/LGIqK8DxydQ2h2bSDFrot8Noe4/Mxq2sTo8oI867B4Euf/LZB5kmVVj3AeSNReZxCS34iqAqU5HvExg5+UbCbrLH33IrxnJP/GrKzFTAYzP45XJXryzlt+4RGycIxAlzTo7kf8ytYBK6P2jSRSxp6w8WJ+8ANaBZqdHSX096QP1fXN2LL+Ls3gmfdS3KbHrsxQ73Ypy/1ke8o2A+tmNspR99CslkLSQpx/Qk9xaL57APWS4negcpyPv8v+Bf+veKaEX/WIwAAAABJRU5ErkJggg==","aspectRatio":2.7027027027027026,"src":"/blog/static/473e845a6e0b9e053f90ba3a890f3942/ee604/chord-scales-scrot.png","srcSet":"/blog/static/473e845a6e0b9e053f90ba3a890f3942/69585/chord-scales-scrot.png 200w,\n/blog/static/473e845a6e0b9e053f90ba3a890f3942/497c6/chord-scales-scrot.png 400w,\n/blog/static/473e845a6e0b9e053f90ba3a890f3942/ee604/chord-scales-scrot.png 800w,\n/blog/static/473e845a6e0b9e053f90ba3a890f3942/f3583/chord-scales-scrot.png 1200w,\n/blog/static/473e845a6e0b9e053f90ba3a890f3942/5707d/chord-scales-scrot.png 1600w,\n/blog/static/473e845a6e0b9e053f90ba3a890f3942/40052/chord-scales-scrot.png 1948w","sizes":"(max-width: 800px) 100vw, 800px"}}},"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"838bc234-c66e-5108-9181-ac79cd3583bb","excerpt":"Let's talk about building synth modules..\nI am still a noob in the area of eurorack and modular synthesis, but I try to learn how to buildâ€¦","slug":"/diy-module/","title":"DIY Potentiometer Module","date":"March 10, 2021"},"next":null},"pageContext":{"id":"3ec70d92-3605-5364-bf05-f00d32dd021f","previousId":"838bc234-c66e-5108-9181-ac79cd3583bb"}},"staticQueryHashes":["386998304","4198970465","764694655"]}