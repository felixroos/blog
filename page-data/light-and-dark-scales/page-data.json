{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/light-and-dark-scales/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"70724d89-4437-5ebe-8e74-3bda0a7c5524","excerpt":"In music school, I learned about the lightness of the modes, from light to dark: In general, a scale gets darker with more flats The binary…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Light & Dark Scales\",\n  \"date\": \"2020-03-31T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In music school, I learned about the lightness of the modes, from light to dark:\"), mdx(\"div\", null, ['lydian', 'ionian', 'mixolydian', 'dorian', 'aeolian', 'phrygian', 'locrian'].map(function (scale, index, scales) {\n    return mdx(React.Fragment, {\n      key: scale\n    }, mdx(Grid, {\n      spacing: 0,\n      container: true,\n      style: {\n        width: '100%'\n      },\n      alignItems: \"center\",\n      mdxType: \"Grid\"\n    }, mdx(Grid, {\n      item: true,\n      xs: 10,\n      mdxType: \"Grid\"\n    }, mdx(Score, {\n      width: 500,\n      height: 100,\n      staves: rhythmicalScore(Rhythm.group(Scale.get(\"C4 \".concat(scale)).notes.concat(['C5']), 4)),\n      mdxType: \"Score\"\n    })), mdx(Grid, {\n      item: true,\n      xs: 2,\n      mdxType: \"Grid\"\n    }, scale, mdx(\"br\", null), Scale.get(\"C4 \".concat(scale)).chroma, mdx(\"br\", null), \"= \", parseInt(Scale.get(\"C4 \".concat(scale)).chroma, 2))));\n  })), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"<div>\\n  {['lydian', 'ionian', 'mixolydian', 'dorian', 'aeolian', 'phrygian', 'locrian'].map((scale, index, scales) => (\\n    <React.Fragment key={scale}>\\n      <Grid spacing={0} container style={{ width: '100%' }} alignItems=\\\"center\\\">\\n        <Grid item xs={10}>\\n          <Score\\n            width={500}\\n            height={100}\\n            staves={rhythmicalScore(Rhythm.group(Scale.get(`C4 ${scale}`).notes.concat(['C5']), 4))}\\n          />\\n        </Grid>\\n        <Grid item xs={2}>\\n          {scale}\\n          <br />\\n          {Scale.get(`C4 ${scale}`).chroma}\\n        </Grid>\\n      </Grid>\\n    </React.Fragment>\\n  ))}\\n</div>\\n\"))), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"In general, a scale gets darker with more flats\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The binary number describes which chromatic notes are in the scale (ones) and which not (zeroes). This binary number is called chroma.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"As the flats increase, more and more ones gravitate to the left\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"So the scale darkness will be reflected directly by the chroma value\")), mdx(\"h2\", {\n    \"id\": \"light-and-dark-chords\"\n  }, \"Light and Dark Chords\"), mdx(\"p\", null, \"If we transfer the same concept to chords, we can also calculate a darkness:\"), mdx(\"div\", null, ['M7', '7', 'mM7', 'm7', 'm6', 'm7b5', 'o7'].map(function (chord, index, chords) {\n    return mdx(React.Fragment, {\n      key: chord\n    }, mdx(Grid, {\n      spacing: 0,\n      container: true,\n      style: {\n        width: '100%'\n      },\n      alignItems: \"center\",\n      mdxType: \"Grid\"\n    }, mdx(Grid, {\n      item: true,\n      xs: 10,\n      mdxType: \"Grid\"\n    }, mdx(Score, {\n      width: 500,\n      height: 100,\n      staves: rhythmicalScore([Chord.getChord(chord, 'C4').notes]),\n      mdxType: \"Score\"\n    })), mdx(Grid, {\n      item: true,\n      xs: 2,\n      mdxType: \"Grid\"\n    }, chord, mdx(\"br\", null), Chord.getChord(chord, 'C4').chroma, mdx(\"br\", null), \"= \", parseInt(Chord.getChord(chord, 'C4').chroma, 2))));\n  })), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"<div>\\n  {['M7', '7', 'mM7', 'm7', 'm6', 'm7b5', 'o7'].map((chord, index, chords) => (\\n    <React.Fragment key={chord}>\\n      <Grid spacing={0} container style={{ width: '100%' }} alignItems=\\\"center\\\">\\n        <Grid item xs={10}>\\n          <Score width={500} height={100} staves={rhythmicalScore([Chord.getChord(chord, 'C4').notes])} />\\n        </Grid>\\n        <Grid item xs={2}>\\n          {chord}\\n          <br />\\n          {Chord.getChord(chord, 'C4').chroma}\\n          <br />= {parseInt(Chord.getChord(chord, 'C4').chroma, 2)}\\n        </Grid>\\n      </Grid>\\n    </React.Fragment>\\n  ))}\\n</div>\\n\"))), mdx(\"p\", null, \"One could now argue that for example a mM7 chord is darker than a m6 chord, but let\\u2019s just use this as a guiding number and not an absolute truth\"), mdx(\"h3\", {\n    \"id\": \"relative-darkness\"\n  }, \"Relative Darkness\"), mdx(\"p\", null, \"If we compare the scales to the chords, we see that scales all have higher numbers, which is natural due to more notes which leads to more ones and thus a higher number.\\nIf we just divide the chroma by the number of notes, we can get a more independent value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"// divide chroma decimal by number of ones to get relative darkness\\nexport function chromaDarkness(chroma) {\\n  return (\\n    parseInt(chroma, 2) /\\n    chroma\\n      .split('')\\n      .filter((d) => d === '1')\\n      .join('').length\\n  );\\n}\\n\")), mdx(\"div\", {\n    style: {\n      overflow: 'auto',\n      maxHeight: '300px'\n    }\n  }, mdx(\"ul\", null, Scale.names().map(function (scale) {\n    return {\n      name: scale,\n      type: 'scale',\n      notes: Scale.get(\"C4 \".concat(scale)).notes,\n      darkness: chromaDarkness(Scale.get(\"C4 \".concat(scale)).chroma)\n    };\n  }).concat(ChordType.names().map(function (chord) {\n    return {\n      name: chord,\n      type: 'chord',\n      notes: Chord.getChord(chord, 'C4').notes,\n      darkness: chromaDarkness(Chord.getChord(chord, 'C4').chroma)\n    };\n  })).sort(function (a, b) {\n    return a.darkness - b.darkness;\n  }).map(function (_ref2, index) {\n    var name = _ref2.name,\n        darkness = _ref2.darkness,\n        notes = _ref2.notes;\n    return mdx(\"li\", {\n      key: index\n    }, mdx(PlayButton, {\n      events: renderRhythmObject({\n        sequential: notes,\n        duration: notes.length / 4\n      }),\n      loop: false,\n      mdxType: \"PlayButton\"\n    }), Math.round(darkness * 100) / 100, \": \", name);\n  }))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/light-and-dark-scales/","title":"Light & Dark Scales","tags":[],"keywords":[],"date":"March 31, 2020","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"8bb5e8c2-38f0-5043-b36e-0dd0e3ce18a1","excerpt":"Chords Let's use the SVG Piano to display chords. My favourite lib for music theory in javascript is  tonal .\nIt comes with a dictionary…","slug":"/chords/","title":"Chords and Scales","date":"March 27, 2020"},"next":{"__typename":"MdxBlogPost","id":"9e433633-2afd-5cc7-9082-8fe6ccbace1d","excerpt":"This article explains a recursive algorithm that performs a combinatorial search.\nThe concept will be used in a future post to find all…","slug":"/combinatorial-search/","title":"Combinatorial Search","date":"March 31, 2020"}},"pageContext":{"id":"70724d89-4437-5ebe-8e74-3bda0a7c5524","previousId":"8bb5e8c2-38f0-5043-b36e-0dd0e3ce18a1","nextId":"9e433633-2afd-5cc7-9082-8fe6ccbace1d"}},"staticQueryHashes":["386998304","4198970465","764694655"]}