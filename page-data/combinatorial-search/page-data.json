{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/combinatorial-search/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"9e433633-2afd-5cc7-9082-8fe6ccbace1d","excerpt":"This article explains a recursive algorithm that performs a combinatorial search.\nThe concept will be used in a future post to find allâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Combinatorial Search\",\n  \"date\": \"2020-03-31T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This article explains a recursive algorithm that performs a combinatorial search.\\nThe concept will be used in a future post to find all possible piano voicings for a given chord.\\nWe will walk through the concepts with this urn demo:\"), mdx(Analyzer, {\n    render: function render(_ref2) {\n      var start = _ref2.start,\n          stop = _ref2.stop,\n          analyze = _ref2.analyze;\n      return mdx(Urn, {\n        balls: 3,\n        minItems: 2,\n        maxItems: 5,\n        samples: 3,\n        uniqueItems: true,\n        hideCombinations: false,\n        canEditSamples: true,\n        canEditOrder: true,\n        canEditUnique: true,\n        picker: function picker(items) {\n          var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : items.length;\n          var strictOrder = arguments.length > 2 ? arguments[2] : undefined;\n          var unique = arguments.length > 3 ? arguments[3] : undefined;\n          start();\n          var results = Permutation.search(function (collected, solutions) {\n            return analyze(collected, collected.length >= number ? [] : unique ? items.filter(function (ball) {\n              return !collected.includes(ball) && (strictOrder || !solutions.find(function (solution) {\n                return Permutation.isEqual([].concat(_toConsumableArray(collected), [ball]), solution);\n              }));\n            }) : items);\n          }, function (collected, solutions) {\n            return collected.length === number && (strictOrder || !solutions.find(function (solution) {\n              return Permutation.isEqual(collected, solution);\n            }));\n          });\n          stop();\n          return results;\n        },\n        mdxType: \"Urn\"\n      });\n    },\n    mdxType: \"Analyzer\"\n  }), mdx(\"h2\", {\n    \"id\": \"the-algorithm\"\n  }, \"The algorithm\"), mdx(\"p\", null, \"The following algorithm can be used to generate permutations of any kind:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"class Permutation {\\n  static search<T>(\\n    finder: (path: T[], solutions: T[][]) => T[],\\n    validator: (path: T[], solutions: T[][]) => boolean,\\n    concatFn = (_path: T[], _candidate: T): T[] => [..._path, _candidate],\\n    path: T[] = [],\\n    solutions: T[][] = []\\n  ): T[][] {\\n    // get candidates for current path\\n    const candidates = finder(path, solutions)\\n    // runs current path through validator to either get a new solution or nothing\\n    if (validator(path, solutions)) {\\n      solutions.push(path)\\n    }\\n    // if no candidates found, we cannot go deeper => either solution or dead end\\n    if (!candidates.length) {\\n      return solutions\\n    }\\n    // go deeper\\n    return candidates.reduce(\\n      (_, candidate) =>\\n        Permutation.search(\\n          finder,\\n          validator,\\n          concatFn,\\n          concatFn(path, candidate),\\n          solutions\\n        ),\\n      []\\n    )\\n  }\\n}\\n\")), mdx(\"p\", null, \"The basic three steps are:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"call the finder to get possible candidates based on the current path and solutions.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"validate current path, and if valid, add to solutions\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"if no more candidates => done, if more candidates => repeat\")), mdx(\"h2\", {\n    \"id\": \"classic-combinatorics-urn-model\"\n  }, \"Classic Combinatorics: Urn model\"), mdx(\"p\", null, \"Let\\u2019s implement the classic combinatoric urn model with it.\"), mdx(\"h3\", {\n    \"id\": \"basic-urn-implementation\"\n  }, \"Basic Urn Implementation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function urn(items) {\\n  return Permutation.search(\\n    // all balls that are not yet collected, are available => unique\\n    collected => items.filter(ball => !collected.includes(ball)),\\n    // all collections that have the length of the items are valid => pull till empty\\n    collected => collected.length === items.length\\n  )\\n}\\n\")), mdx(\"p\", null, \"Here, we pass two functions:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The first function returns a set of items we can pull at a given state. In this case, we return all items that have not been collected yet\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The second function returns a validation function for a given collection to be accepted as \\u201Csolution\\u201D. In this case, we only accept collections of the items length\")), mdx(\"p\", null, \"The functions in this case lead to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Order is important\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Balls can be pulled once\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We pull till its \\u201Cempty\\u201D\")), mdx(Urn, {\n    minItems: 2,\n    maxItems: 5,\n    balls: 3,\n    picker: function picker(items) {\n      return Permutation.search(function (collected) {\n        return items.filter(function (ball) {\n          return !collected.includes(ball);\n        });\n      }, function (collected) {\n        return collected.length === items.length;\n      });\n    },\n    mdxType: \"Urn\"\n  }), mdx(\"h3\", {\n    \"id\": \"extension-1-pull-sample\"\n  }, \"Extension 1: pull sample\"), mdx(\"p\", null, \"We can extend the implementation by passing a number of balls that should be pulled:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function urn(items, number = items.length) {\\n  return Permutation.search(\\n    collected => items.filter(ball => !collected.includes(ball)),\\n    collected => collected.length === number\\n  )\\n}\\n\")), mdx(\"p\", null, \"This is like pulling Lotto numbers:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Order is important\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each ball is unique (only one can be pulled)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pulling only a subset (e.g. 6 of 49)\")), mdx(Urn, {\n    minItems: 2,\n    maxItems: 5,\n    samples: 2,\n    balls: 3,\n    canEditSamples: true,\n    picker: function picker(items) {\n      var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : items.length;\n      return Permutation.search(function (collected) {\n        return collected.length >= number ? [] : items.filter(function (ball) {\n          return !collected.includes(ball);\n        });\n      }, function (collected) {\n        return collected.length === number;\n      });\n    },\n    mdxType: \"Urn\"\n  }), mdx(\"p\", null, \"The above implementation works, but has a performance flaw: The first function does not include the sample so it will always run till the end, despite the fact that it won\\u2019t find new valid combinations. Fix:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function urn(items, number = items.length) {\\n  return Permutation.search(\\n    collected =>\\n      collected.length >= number\\n        ? []\\n        : items.filter(ball => !collected.includes(ball)),\\n    collected => collected.length === number\\n  )\\n}\\n\")), mdx(\"p\", null, \"Returning an empty array means, we have no candidates that could be added => recursion stops.\"), mdx(\"h3\", {\n    \"id\": \"extension-2-ignore-order\"\n  }, \"Extension 2: ignore order\"), mdx(\"p\", null, \"We could also ignore the order of items:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function isEqual(collectionA, collectionB) {\\n  return collectionA.sort().join(\\\"-\\\") === collectionB.sort().join(\\\"-\\\")\\n}\\n\\nfunction urn(items, number = items.length, strictOrder = true) {\\n  return Permutation.search(\\n    collected =>\\n      collected.length >= number\\n        ? []\\n        : items.filter(ball => !collected.includes(ball)),\\n    (collected, solutions) =>\\n      collected.length === number &&\\n      (strictOrder ||\\n        !solutions.find(solution => Permutation.isEqual(collected, solution)))\\n  )\\n}\\n\")), mdx(\"p\", null, \"Note: This implementation of isEqual only works with strings.\"), mdx(\"p\", null, \"A real world usage would be pulling a hand in a card game:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Order is not important\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each card is unique\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Pulling only a subset of the deck\")), mdx(Urn, {\n    balls: 3,\n    minItems: 2,\n    maxItems: 6,\n    samples: 2,\n    canEditSamples: true,\n    canEditOrder: true,\n    ignoreOrder: true,\n    picker: function picker(items) {\n      var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : items.length;\n      var strictOrder = arguments.length > 2 ? arguments[2] : undefined;\n      return Permutation.search(function (collected) {\n        return collected.length >= number ? [] : items.filter(function (ball) {\n          return !collected.includes(ball);\n        });\n      }, function (collected, solutions) {\n        return collected.length === number && (strictOrder || !solutions.find(function (solution) {\n          return Permutation.isEqual(collected, solution);\n        }));\n      });\n    },\n    mdxType: \"Urn\"\n  }), mdx(\"h3\", {\n    \"id\": \"extension-3-balls-can-be-pulled-multiple-times\"\n  }, \"Extension 3: Balls can be pulled multiple times:\"), mdx(\"p\", null, \"Lets add a flag called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unique\"), \". If we switch it to false, a ball can be picked multiple times.\"), mdx(\"p\", null, \"A good mental model for this is a combination lock:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Order is important\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each number can be used multiple times\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The amount of picks is not related to the amount of available numbers\")), mdx(\"p\", null, \"Another mental model for this without ordering is throwing multiple dice:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Order is not important\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each number can be used multiple times\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We throw how many dices we want\")), mdx(Urn, {\n    balls: 2,\n    minItems: 2,\n    maxItems: 5,\n    samples: 4,\n    uniqueItems: false,\n    canEditSamples: true,\n    canEditOrder: true,\n    canEditUnique: true,\n    picker: function picker(items) {\n      var number = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : items.length;\n      var strictOrder = arguments.length > 2 ? arguments[2] : undefined;\n      var unique = arguments.length > 3 ? arguments[3] : undefined;\n      return Permutation.search(function (collected) {\n        return collected.length >= number ? [] : unique ? items.filter(function (ball) {\n          return !collected.includes(ball);\n        }) : items;\n      }, function (collected, solutions) {\n        return collected.length === number && (strictOrder || !solutions.find(function (solution) {\n          return Permutation.isEqual(collected, solution);\n        }));\n      });\n    },\n    mdxType: \"Urn\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function urn(\\n  items,\\n  number = items.length,\\n  strictOrder = true,\\n  unique = true\\n) {\\n  return Permutation.search(\\n    collected =>\\n      collected.length >= number\\n        ? []\\n        : unique\\n        ? items.filter(ball => !collected.includes(ball)),\\n        : items\\n    (collected, solutions) =>\\n      collected.length === number &&\\n      (strictOrder ||\\n        !solutions.find(solution => Permutation.isEqual(collected, solution)))\\n  );\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"final-thoughts\"\n  }, \"Final Thoughts\"), mdx(\"p\", null, \"Now we should have a clear understanding of how to perform combinatorial search with a functional approach.\\nIn the next post(s), we will use that knowledge to generate voicings, melodies and rhythms!\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/combinatorial-search/","title":"Combinatorial Search","tags":[],"keywords":[],"date":"March 31, 2020"},"previous":{"__typename":"MdxBlogPost","id":"8bb5e8c2-38f0-5043-b36e-0dd0e3ce18a1","excerpt":"Chords Let's use the SVG Piano to display chords. My favourite lib for music theory in javascript is  tonal .\nIt comes with a dictionaryâ€¦","slug":"/chords/","title":"Chords and Scales","date":"March 27, 2020"},"next":{"__typename":"MdxBlogPost","id":"26f772d2-9d92-57d7-953c-c6aa8bb6e664","excerpt":"Let's play with colors. Vizualization loves color. To map musical notes to color, we can do various things. rainbow with hsl One simpleâ€¦","slug":"/coloring-pitches/","title":"Coloring Pitches","date":"April 01, 2020"}},"pageContext":{"id":"9e433633-2afd-5cc7-9082-8fe6ccbace1d","previousId":"8bb5e8c2-38f0-5043-b36e-0dd0e3ce18a1","nextId":"26f772d2-9d92-57d7-953c-c6aa8bb6e664"}}}