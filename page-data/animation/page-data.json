{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/animation/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"5b4e9753-a8e6-5932-a877-bf3fb1bb1930","excerpt":"Let's make a react component that can be used to animate anything directly inside MDX files: The above Animation uses a component called…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Animating React Components\",\n  \"date\": \"2020-04-19T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let\\u2019s make a react component that can be used to animate anything directly inside MDX files:\"), mdx(AnimationFrame, {\n    autostart: true,\n    mdxType: \"AnimationFrame\"\n  }, function (_ref2) {\n    var time = _ref2.time;\n    var t = time.fromStart / 250;\n    return mdx(Plot, {\n      functions: [function (x) {\n        return Math.sin(3 * x) * Math.sin(t / 2);\n      }, function (x) {\n        return Math.sin(2 * x) * Math.sin(t / 3);\n      }],\n      range: {\n        x: [0, Math.PI],\n        y: [-1, 1]\n      },\n      height: 200,\n      strokeWidth: 4,\n      hideXAxis: true,\n      mdxType: \"Plot\"\n    });\n  }), mdx(\"p\", null, \"The above Animation uses a component called AnimationFrame which wraps the Plot component from last post:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"<AnimationFrame autostart>\\n  {({ time }) => {\\n    const t = time.fromStart / 250\\n    return (\\n      <Plot\\n        functions={[\\n          (x) => Math.sin(3 * x) * Math.sin(t / 2),\\n          (x) => Math.sin(2 * x) * Math.sin(t / 3),\\n        ]}\\n        range={{ x: [0, Math.PI], y: [-1, 1] }}\\n        height={200}\\n        strokeWidth={4}\\n        hideXAxis={true}\\n      />\\n    )\\n  }}\\n</AnimationFrame>\\n\")), mdx(\"h2\", {\n    \"id\": \"animationframe-component\"\n  }, \"AnimationFrame component\"), mdx(\"p\", null, \"The AnimationFrame component is relatively straightforward as it essentially just uses a custom hook called useFrame:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export default function AnimationFrame(props) {\\n  const [time, setTime] = useState({\\n    fromStart: 0,\\n    fromFirstStart: 0,\\n    progress: 0,\\n    delta: null,\\n  })\\n  const frame = useFrame(setTime, props.autostart)\\n  return props.children({ ...frame, time })\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"useframe\"\n  }, \"useFrame\"), mdx(\"p\", null, \"The more interesting useFrame hook:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"\\nexport default function useFrame(callback, autostart = false) {\\n  const requestRef = useRef<number>();\\n  const previousTimeRef = useRef<number>();\\n  const startTimeRef = useRef<number>();\\n  const stopTimeRef = useRef<number>(0);\\n  const maxTimeRef = useRef<number>();\\n  const [isRunning, setIsRunning] = useState(autostart);\\n\\n  const animate = time => {\\n    if (!startTimeRef.current) {\\n      startTimeRef.current = time;\\n    }\\n    if (previousTimeRef.current != undefined) {\\n      const delta = time - previousTimeRef.current\\n      const fromStart = time - startTimeRef.current;\\n      callback({\\n        time,\\n        delta,\\n        fromStart,\\n        fromFirstStart: fromStart + stopTimeRef.current,\\n        stopTime: stopTimeRef.current,\\n        progress: maxTimeRef.current ? fromStart / maxTimeRef.current : 0\\n      });\\n      if (maxTimeRef.current && fromStart >= maxTimeRef.current) {\\n        stop();\\n        maxTimeRef.current = null;\\n        return;\\n      }\\n    }\\n    previousTimeRef.current = time;\\n    requestRef.current = requestAnimationFrame(animate);\\n  }\\n\\n  function start(maxTime?) {\\n    if (isRunning) {\\n      stop();\\n    }\\n    if (maxTime) {\\n      maxTimeRef.current = maxTime;\\n    }\\n    requestRef.current = requestAnimationFrame(animate);\\n    setIsRunning(true);\\n  }\\n\\n  function stop() {\\n    if (previousTimeRef.current && startTimeRef.current) {\\n      stopTimeRef.current = previousTimeRef.current - startTimeRef.current + stopTimeRef.current;\\n    }\\n    cancelAnimationFrame(requestRef.current);\\n    startTimeRef.current = 0;\\n    requestRef.current = null;\\n    setIsRunning(false)\\n  }\\n  function toggle() {\\n    if (!requestRef.current) {\\n      start()\\n    } else {\\n      stop();\\n    }\\n  }\\n\\n  React.useEffect(() => {\\n    autostart && start();\\n    return () => stop()\\n  }, []); // Make sure the effect runs only once\\n  return { start, stop, toggle, isRunning };\\n}\\n\")), mdx(\"p\", null, \"In its essence, it takes a callback that is repeatedly invoked inside \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame\"\n  }), \"requestAnimationFrame\"), \".\\nWhen start is called, the animation begins.\"), mdx(\"h3\", {\n    \"id\": \"perspectives-on-time\"\n  }, \"Perspectives on time\"), mdx(\"p\", null, \"The callback is passed different perspectives on time:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"time: total time elapsed since document creation (default requestAnimation param)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"delta: time elapsed since last frame e.g. 17ms for 60fps\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"fromStart: time elapsed since animation was started\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"fromFirstStart: time elapsed since animation was started the first time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"stopTime: the last time the animation was stopped\")), mdx(\"p\", null, \"fromStart and fromFirstStart should be the most interesting for most use cases:\"), mdx(AnimationFrame, {\n    mdxType: \"AnimationFrame\"\n  }, function (_ref3) {\n    var toggle = _ref3.toggle,\n        time = _ref3.time,\n        isRunning = _ref3.isRunning,\n        start = _ref3.start;\n    return mdx(React.Fragment, null, mdx(Fab, {\n      onClick: function onClick() {\n        return toggle();\n      },\n      mdxType: \"Fab\"\n    }, !isRunning ? mdx(PlayArrowIcon, {\n      mdxType: \"PlayArrowIcon\"\n    }) : mdx(StopIcon, {\n      mdxType: \"StopIcon\"\n    })), time && mdx(React.Fragment, null, mdx(\"p\", null, \"time.fromStart:\", \" \", mdx(\"span\", {\n      style: {\n        color: \"yellow\"\n      }\n    }, Math.round(time.fromStart / 10) / 100, \"s\")), mdx(\"p\", null, \"time.fromFirstStart:\", \" \", mdx(\"span\", {\n      style: {\n        color: \"green\"\n      }\n    }, Math.round(time.fromFirstStart / 10) / 100, \"s\")), mdx(\"p\", null, \"time.delta: \", Math.round(time.delta), \"ms =\", \" \", Math.round(1000 / time.delta), \"fps\"), time && mdx(Plot, {\n      range: {\n        x: [0, Math.PI],\n        y: [0, 1]\n      },\n      height: 330,\n      functions: [function (x) {\n        return Math.abs(Math.sin(x + time.fromFirstStart / 1000));\n      }, function (x) {\n        return Math.abs(Math.sin(x + time.fromStart / 1000));\n      }],\n      colors: [\"green\", \"yellow\"],\n      mdxType: \"Plot\"\n    }), mdx(\"svg\", {\n      width: 100,\n      height: 300\n    }, mdx(\"circle\", {\n      cy: 300 - Math.abs(Math.sin(time.fromStart / 1000)) * (300 - 20) - 10,\n      cx: 40,\n      r: 10,\n      fill: \"yellow\"\n    }), mdx(\"circle\", {\n      cy: 300 - Math.abs(Math.sin(time.fromFirstStart / 1000)) * (300 - 20) - 10,\n      cx: 10,\n      r: 10,\n      fill: \"green\"\n    }))), mdx(\"br\", null));\n  }), mdx(\"h3\", {\n    \"id\": \"progress\"\n  }, \"progress\"), mdx(\"p\", null, \"We can turn the continuus animation to a timed one by passing a maxTime to the start method.\\nIf doing so, the callback param \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"progress\"), \" will contain a number between 0 and 1.\"), mdx(AnimationFrame, {\n    mdxType: \"AnimationFrame\"\n  }, function (_ref4) {\n    var toggle = _ref4.toggle,\n        time = _ref4.time,\n        isRunning = _ref4.isRunning,\n        start = _ref4.start,\n        stop = _ref4.stop;\n    return mdx(React.Fragment, null, mdx(Fab, {\n      onClick: function onClick() {\n        return start(1000);\n      },\n      mdxType: \"Fab\"\n    }, !isRunning ? mdx(PlayArrowIcon, {\n      mdxType: \"PlayArrowIcon\"\n    }) : mdx(StopIcon, {\n      mdxType: \"StopIcon\"\n    })), mdx(\"h1\", {\n      style: {\n        opacity: time.progress\n      }\n    }, Math.round(time.progress * 100), \"%\"));\n  }), mdx(\"h2\", {\n    \"id\": \"react-animation-libs\"\n  }, \"React Animation libs\"), mdx(\"p\", null, \"Of course, there are several libs for animating in the react world:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://reactcommunity.org/react-transition-group/\"\n  }), \"https://reactcommunity.org/react-transition-group/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://www.react-spring.io/\"\n  }), \"https://www.react-spring.io/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/nearform/react-animation\"\n  }), \"https://github.com/nearform/react-animation\"))), mdx(\"p\", null, \"But they are mainly focused on one time animations rather than on infinite time flow.\\nOnly react spring would allow never ending animations using a spring tension of 0, but still\\nthe values are sprining between number bounds that are only indirectly controllable via spring constants.\"), mdx(\"h2\", {\n    \"id\": \"d3-transition\"\n  }, \"d3-transition\"), mdx(\"p\", null, \"When using d3, we could use d3-transition, but this is only possible in combination with d3-selection, which I try to avoid, as I want to control the DOM from React as direct as possible.\\nAlso, like with the libs above, it is not really elegant to do \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://bl.ocks.org/d3noob/bf44061b1d443f455b3f857f82721372\"\n  }), \"infinite animations\")), mdx(\"h2\", {\n    \"id\": \"tbd\"\n  }, \"TBD\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"check out \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/d3/d3-timer\"\n  }), \"https://github.com/d3/d3-timer\"))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/animation/","title":"Animating React Components","tags":[],"keywords":[],"date":"April 19, 2020"},"previous":{"__typename":"MdxBlogPost","id":"d6c214c4-7204-5fda-bdd8-a3efaf8971f2","excerpt":"As the basis of many upcoming visualizations, I will use libraries of  the huge d3 ecosystem .\nFor many applications, for example to animate…","slug":"/plotting-functions/","title":"Plotting Functions with React and d3.js","date":"April 18, 2020"},"next":{"__typename":"MdxBlogPost","id":"f32b7e0f-4d3d-55fb-8e79-2892c936ef3d","excerpt":"Let's understand the harmonic series by looking at a monochord: You can play it by hovering over it with the mouse.\nThe length / pitch can…","slug":"/harmonics/","title":"The Harmonic Series & Additive Synthesis","date":"April 20, 2020"}},"pageContext":{"id":"5b4e9753-a8e6-5932-a877-bf3fb1bb1930","previousId":"d6c214c4-7204-5fda-bdd8-a3efaf8971f2","nextId":"f32b7e0f-4d3d-55fb-8e79-2892c936ef3d"}}}