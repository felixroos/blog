{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/svg-piano-roll/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"bdafcba1-105a-5d30-900e-8138f1dfe63e","excerpt":"After playback was implemented in the last post, we can now feed our eyes with some colored bars: Drawing the SVG Using a little bit of d…","body":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"SVG Piano Roll Component\",\n  \"date\": \"2020-06-10T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"After playback was implemented in the last post, we can now feed our eyes with some colored bars:\"), mdx(Player, {\n    fold: true,\n    instruments: {\n      synth: synth,\n      drums: drums\n    },\n    rhythmLanes: ['sn', 'hh', 'cp', 'bd', 'cm'],\n    events: renderRhythmObject({\n      color: 'darksalmon',\n      duration: 4,\n      parallel: [[[['Eb4', 'F4', 'r', 'G3'], ['r', 'r', 'r', 'G3']], [['r', 'Bb3'], 'G3', 'r', ['r', 'D4']]], {\n        color: 'brown',\n        value: [['C3', 'C3', 'G2', 'r'], ['C3', 'C3', 'G2', 'r']]\n      }, [{\n        color: 'steelblue',\n        instrument: 'drums',\n        parallel: [[['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh'], ['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', ['hh', 'hh']]], [['bd', ['sn', 'bd'], 'bd', 'sn'], ['bd', ['sn', 'r', 'r', 'bd'], 'bd', 'sn']]]\n      }]]\n    }, [inheritProperty('instrument')]),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"renderRhythmObject(\\n  {\\n    color: 'darksalmon',\\n    duration: 4,\\n    parallel: [\\n      [\\n        [\\n          ['Eb4', 'F4', 'r', 'G3'],\\n          ['r', 'r', 'r', 'G3']\\n        ],\\n        [['r', 'Bb3'], 'G3', 'r', ['r', 'D4']]\\n      ],\\n      {\\n        color: 'brown',\\n        value: [\\n          ['C3', 'C3', 'G2', 'r'],\\n          ['C3', 'C3', 'G2', 'r']\\n        ]\\n      },\\n      [\\n        {\\n          color: 'steelblue',\\n          instrument: 'drums',\\n          parallel: [\\n            [\\n              ['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh'],\\n              ['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', ['hh', 'hh']]\\n            ],\\n            [\\n              ['bd', ['sn', 'bd'], 'bd', 'sn'],\\n              ['bd', ['sn', 'r', 'r', 'bd'], 'bd', 'sn']\\n            ]\\n          ]\\n        }\\n      ]\\n    ]\\n  },\\n  [inheritProperty('instrument')]\\n);\\n\"))), mdx(\"h2\", {\n    \"id\": \"drawing-the-svg\"\n  }, \"Drawing the SVG\"), mdx(\"p\", null, \"Using a little bit of d3, the basic implementation is pretty compact:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export default function PianoRoll(props: PianoRollProps) {\\n  let {\\n    width = 600,\\n    height = 200,\\n    margin = 1,\\n    noteRange = ['C3', 'C4'],\\n    timeRange = [0, 1],\\n    strokeWidth = 1,\\n    hiddenSymbols = ['r'],\\n    events\\n  } = props;\\n  const deepest = max(events.map((e) => (e.path ? e.path.length : 1)));\\n  const midiRange = [Note.midi(noteRange[0]), Note.midi(noteRange[1])];\\n  const x = scaleLinear()\\n      .domain(timeRange)\\n      .range([margin, width - margin]),\\n    y = scaleLinear()\\n      .domain([midiRange[0] - 1, midiRange[1]])\\n      .range([height - margin, margin]);\\n  return (\\n    <svg {...{ width, height }}>\\n      {events\\n        .filter(({ value }) => hiddenSymbols.indexOf(value) === -1)\\n        .map(({ value, time, duration, path, color }, i) => {\\n          return (\\n            <rect\\n              stroke=\\\"black\\\"\\n              strokeWidth={strokeWidth}\\n              fill={\\n                color || interpolateBlues((path ? path.length : 1) / deepest)\\n              }\\n              key={i}\\n              x={x(time)}\\n              y={y(Note.midi(value))}\\n              width={x(duration) - strokeWidth}\\n              height={y(midiRange[1] - 1) - strokeWidth}\\n            />\\n          );\\n        })}\\n    </svg>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Usage:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"<PianoRoll\\n  height={100}\\n  noteRange={['C3', 'A3']}\\n  events={renderRhythmObject({\\n    parallel: [\\n      { sequential: ['E3', 'F3', 'G3', 'A3'], color: 'magenta' },\\n      { sequential: ['C3', 'D3', 'E3', 'F3'], color: 'cyan' }\\n    ]\\n  })}\\n/>\\n\")), mdx(\"h2\", {\n    \"id\": \"rhythm-lanes\"\n  }, \"Rhythm Lanes\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"With the above piano roll implementation, only notes in scientific pitch notation will work.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"It would be nice if the piano roll recognizes all used values and creates a lane for each\")), mdx(\"p\", null, \"By filtering the events to be unique, we can create a lane for each unique value.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const uniqueLanes = events\\n  .filter(({ value }) => hiddenSymbols.indexOf(value) === -1)\\n  .map((e) => e.value)\\n  .filter((v, i, e) => e.indexOf(v) === i)\\n  .sort((a, b) => Note.midi(b) - Note.midi(a));\\n\")), mdx(\"p\", null, \"This will create lanes for rhythms too:\"), mdx(Player, {\n    fold: true,\n    instruments: {\n      drums: drums\n    },\n    events: renderRhythmObject({\n      duration: 2,\n      parallel: [['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh'], ['bd', ['sn', 'bd'], 'bd', 'sn']]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"h2\", {\n    \"id\": \"foldable-lanes\"\n  }, \"Foldable Lanes\"), mdx(\"p\", null, \"Using only unique events for notes has the effect of folding (similar to fold in ableton midi edit). I implemented this behaviour with the fold flag:\"), mdx(State, {\n    initial: {\n      fold: false\n    },\n    mdxType: \"State\"\n  }, function (_ref2) {\n    var state = _ref2.state,\n        setState = _ref2.setState;\n    return mdx(React.Fragment, null, mdx(\"label\", null, mdx(\"input\", {\n      type: \"checkbox\",\n      checked: state.fold,\n      onChange: function onChange(e) {\n        return setState({\n          fold: e.target.checked\n        });\n      }\n    }), \"Fold\"), mdx(\"br\", null), mdx(Player, {\n      fold: state.fold,\n      height: 100,\n      noteRange: ['C3', 'A3'],\n      events: renderRhythmObject({\n        duration: 2,\n        parallel: [{\n          sequential: ['E3', 'F3', 'G3', 'A3'],\n          color: 'magenta'\n        }, {\n          sequential: ['C3', 'D3', 'E3', 'F3'],\n          color: 'cyan'\n        }]\n      }),\n      mdxType: \"Player\"\n    }));\n  }), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"customize-rhythm-lanes\"\n  }, \"Customize Rhythm Lanes\"), mdx(\"p\", null, \"For consistent visualizations, it would be good to have a setting that controls which rhythm lanes are created.\\nBy passing an array of strings to rhythmLanes, we can control which lanes are created for non note events.\\nThe order will remain consistent even if we fold:\"), mdx(State, {\n    initial: {\n      fold: false\n    },\n    mdxType: \"State\"\n  }, function (_ref3) {\n    var state = _ref3.state,\n        setState = _ref3.setState;\n    return mdx(React.Fragment, null, mdx(\"label\", null, mdx(\"input\", {\n      type: \"checkbox\",\n      checked: state.fold,\n      onChange: function onChange(e) {\n        return setState({\n          fold: e.target.checked\n        });\n      }\n    }), \"Fold\"), mdx(\"br\", null), mdx(Player, {\n      fold: state.fold,\n      rhythmLanes: ['sn', 'hh', 'cp', 'bd', 'cm'],\n      instruments: {\n        drums: drums\n      },\n      events: renderRhythmObject({\n        duration: 2,\n        parallel: [['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh'], ['bd', ['sn', 'bd'], 'bd', 'sn']]\n      }),\n      mdxType: \"Player\"\n    }));\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"<PianoRoll\\n  fold={state.fold}\\n  rhythmLanes={['sn', 'hh', 'cp', 'bd', 'cm']}\\n  events={renderRhythmObject({\\n    duration: 2,\\n    parallel: [\\n      ['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh'],\\n      ['bd', ['sn', 'bd'], 'bd', 'sn']\\n    ]\\n  })}\\n/>\\n\")), mdx(\"h3\", {\n    \"id\": \"mixed-lanes\"\n  }, \"Mixed Lanes\"), mdx(\"p\", null, \"If we mix rhythm and note events, the piano roll will concat the rhythm lanes below the note lanes:\"), mdx(State, {\n    initial: {\n      fold: false\n    },\n    mdxType: \"State\"\n  }, function (_ref4) {\n    var state = _ref4.state,\n        setState = _ref4.setState;\n    var events = renderRhythmObject({\n      color: 'darksalmon',\n      duration: 4,\n      parallel: [[[['Eb4', 'F4', 'r', 'G3'], ['r', 'r', 'r', 'G3']], [['r', 'Bb3'], 'G3', 'r', ['r', 'D4']]], {\n        color: 'brown',\n        value: [['C3', 'C3', 'G2', 'r'], ['C3', 'C3', 'G2', 'r']]\n      }, [{\n        color: 'steelblue',\n        instrument: 'drums',\n        parallel: [[['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh'], ['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', ['hh', 'hh']]], [['bd', ['sn', 'bd'], 'bd', 'sn'], ['bd', ['sn', 'r', 'r', 'bd'], 'bd', 'sn']]]\n      }]]\n    }, [inheritProperty('instrument')]);\n    return mdx(React.Fragment, null, mdx(\"label\", null, mdx(\"input\", {\n      type: \"checkbox\",\n      checked: state.fold,\n      onChange: function onChange(e) {\n        return setState({\n          fold: e.target.checked\n        });\n      }\n    }), \"Fold\"), mdx(\"br\", null), mdx(Player, {\n      fold: state.fold,\n      events: events,\n      instruments: {\n        synth: synth,\n        drums: drums\n      },\n      mdxType: \"Player\"\n    }));\n  }), mdx(\"h3\", {\n    \"id\": \"custom-note-lanes\"\n  }, \"Custom note lanes\"), mdx(\"p\", null, \"Like for custom rhythm lanes, we may also want to show a specific set of notes, like a scale.\\nAlso, notes that are not in the set will be hidden! This can also be useful if we want to use microtonality.\"), mdx(PianoRoll, {\n    height: 100,\n    noteLanes: ['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4'],\n    events: renderRhythmObject({\n      duration: 2,\n      parallel: [{\n        sequential: ['Db3', 'F3', 'Ab3', 'C4'],\n        color: 'magenta'\n      }, {\n        sequential: ['C3', 'D3', 'E3', 'F3'],\n        color: 'cyan'\n      }]\n    }),\n    mdxType: \"PianoRoll\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"<PianoRoll\\n  height={100}\\n  noteLanes={['C3', 'D3', 'E3', 'F3', 'G3', 'A3', 'B3', 'C4']}\\n  events={renderRhythmObject({\\n    parallel: [\\n      { sequential: ['Db3', 'F3', 'Ab3', 'C4'], color: 'magenta' },\\n      { sequential: ['C3', 'D3', 'E3', 'F3'], color: 'cyan' }\\n    ]\\n  })}\\n/>\\n\")), mdx(\"h2\", {\n    \"id\": \"sync-with-playback\"\n  }, \"Sync with Playback\"), mdx(\"p\", null, \"To synchronize the drawing with Tone.js, it is recommended to use \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://tonejs.github.io/docs/r13/Draw\"\n  }), \"Tone.Draw\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function drawCallback(callback, grain = 1 / 30) {\\n  if (callback) {\\n    return new Tone.Loop((time) => {\\n      Tone.Draw.schedule(() => callback(Tone.Transport.seconds), time);\\n    }, grain).start(0);\\n  }\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"working-with-frequencies\"\n  }, \"Working with frequencies\"), mdx(\"p\", null, \"For experimentation with microtonality, we can also just use numbers to play frequencies:\"), mdx(Player, {\n    height: 100,\n    events: renderRhythmObject({\n      duration: 4,\n      value: stack(12, 4 / 3, 1).map(function (r) {\n        return equivalence(r) * 220;\n      }),\n      color: 'cyan'\n    }).map(function (e) {\n      return _objectSpread({}, e, {\n        value: e.value / 2\n      });\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"h2\", {\n    \"id\": \"next-steps\"\n  }, \"Next Steps\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"numbers should be sorted vertically\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"change zoom\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"add block wrap feature (like implemented in REPL)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"lane background colors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"labels\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/svg-piano-roll/","title":"SVG Piano Roll Component","tags":[],"keywords":[],"date":"June 10, 2020"},"previous":{"__typename":"MdxBlogPost","id":"6dd1e095-9570-58e5-80b8-ddf949a7fa94","excerpt":"Before implementing more rhythmical features, it would be good to hear some results. This is where the Player comes in.\nThe Player itself…","slug":"/rhythmical-playback/","title":"Tone.js Playback","date":"June 09, 2020"},"next":{"__typename":"MdxBlogPost","id":"4a67d2c8-1cf8-53f5-a3c4-25316e09bb2b","excerpt":"Last week, a friend a I built a MIDI Controller for the Arturia Mini V3 VST: Front Panel Controls At first, we identified the different 4…","slug":"/midimoog/","title":"Building a Minimoog MIDI Controller","date":"June 11, 2020"}},"pageContext":{"id":"bdafcba1-105a-5d30-900e-8138f1dfe63e","previousId":"6dd1e095-9570-58e5-80b8-ddf949a7fa94","nextId":"4a67d2c8-1cf8-53f5-a3c4-25316e09bb2b"}}}