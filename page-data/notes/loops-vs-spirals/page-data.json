{"componentChunkName":"component---node-modules-gatsby-theme-notes-src-templates-note-js","path":"/notes/loops-vs-spirals","result":{"data":{"note":{"id":"81d22ab2-de98-5406-8f72-e858967c958d","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Loops vs Spirals\",\n  \"date\": \"2021-05-01T00:00:00.000Z\",\n  \"keywords\": [\"voicings\", \"draft\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"So far, the workflow of playing music with rhythmical was this:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"generate timed events from a rhythmical tree object\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"throw those events into a web audio player\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"repeat those exact events until the end of time\")), mdx(\"p\", null, \"The problem with this approach is that it\\u2019s rigid.\\nThe loop never changes and there is no interaction between the user and the event stream.\\nTo really get an expressive music tool, it should be possible to change the events while they play.\"), mdx(\"p\", null, \"Even without user interaction, the loop should be able to retain a state over time. Take this example from the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./rhythmical-chords\"\n  }, \"rhythmical chords post\"), \":\"), mdx(Player, {\n    fold: false,\n    instruments: {\n      tinypiano: tinypiano,\n      drums: drums\n    },\n    events: renderRhythmObject({\n      duration: 12,\n      sequential: ['Cm7', 'Em7', 'Dm7', 'Cm7', 'Em7', 'Dm7', {\n        value: 'Cm7',\n        duration: 2\n      }, {\n        value: 'Bm7',\n        duration: 2\n      }]\n    }).reduce(voicingReducer(lefthand, ['C3', 'C6']), []),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"In the post, I said:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"This seems to work perfectly, the only jump remains at the repetition, which could be fixed by regenerating the voicing each round, which I will implement in the future.\")), mdx(\"h2\", {\n    \"id\": \"where-the-spiral-comes-in\"\n  }, \"Where the Spiral comes in\"), mdx(\"p\", null, \"If you give a pianist a leadsheet with chord symbols, he or she might play each form differently.\\nFor example, when transitioning from the last chord of the form to the first, the voice leading should still be smooth.\\nSo the pianist might choose to play a different voicing for the first chord on the second playthrough.\"), mdx(\"p\", null, \"This is what the metaphor of the spiral means: A stream of events that is oriented towards a repeating pattern,\\nbut that is constantly changing in time.\"), mdx(\"h2\", {\n    \"id\": \"time-slices\"\n  }, \"Time Slices\"), mdx(\"p\", null, \"To get that spirally behaviour, we need to generate a new slice of time once the old one is about to finish.\\nWhen generating the new slice, we can continue where we left off in an organic way.\"), mdx(\"p\", null, \"This behaviour reminds me of audio buffers, where a certain number of samples is generated and pushed to sound driver.\\nWe want to do the same, but in a more macroscopic fashion.\"), mdx(\"h2\", {\n    \"id\": \"voice-leading-example\"\n  }, \"Voice Leading Example\"), mdx(\"p\", null, \"This example showcases user interaction while playing. A random sequence of chords is played, voicing as smooth as possible inside the variable range:\"), mdx(DynamicSchedule, {\n    mdxType: \"DynamicSchedule\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using schedule callbacks, refering to values of react state won\\u2019t work, as they are not mutated.. \", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://react.christmas/2020/15\"\n  }, \"same problem here\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/Tonejs/Tone.js/wiki/Using-Tone.js-with-React-or-Vue\"\n  }, \"not much help here\"))))), mdx(\"h2\", {\n    \"id\": \"random-bleeps\"\n  }, \"Random Bleeps\"), mdx(RandomBleeps, {\n    mdxType: \"RandomBleeps\"\n  }), mdx(\"h2\", {\n    \"id\": \"\"\n  }, \"..\"), mdx(\"p\", null, \"In the last post about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"./rhythmical-trees\"\n  }, \"rhythmical trees\"), \", I used generator functions to iterate over tree nodes.\\nIn this post, I want to investigate if generators could be used to hold state and generate musical data step by step.\\nThis would solve the problem\"), mdx(\"h2\", {\n    \"id\": \"stateful-generators\"\n  }, \"Stateful Generators\"), mdx(\"p\", null, \"I found out that the next function of a generator also \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#advanced_generators\"\n  }, \"accepts an argument\"), \"!\\nThis allows data to flow in and out of the generator, enabling it to manage state:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function* infiniteGenerator() {\\n  let state = '';\\n  while (true) {\\n    state += yield state;\\n  }\\n}\\n\\ntest('infiniteGenerator', () => {\\n  const generator = infiniteGenerator();\\n  generator.next(); // A value passed to the first invocation of next() is always ignored.\\n  expect(generator.next('x').value).toBe('x');\\n  expect(generator.next('y').value).toBe('xy');\\n  expect(generator.next('z').value).toBe('xyz');\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"generating-voicings\"\n  }, \"Generating Voicings\"), mdx(\"p\", null, \"The state can be used to hold anything, like the latest voicing:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function* voicingGenerator({ range, dictionary, voiceLeading }) {\\n  let lastVoicing;\\n  let chord;\\n  while (true) {\\n    lastVoicing = chord ? Voicing.get(chord, range, dictionary, voiceLeading, lastVoicing) : [];\\n    chord = yield lastVoicing;\\n  }\\n}\\n\\ntest('voicingGenerator', () => {\\n  const range = ['E3', 'A4'],\\n    dictionary = lefthand,\\n    voiceLeading = topNoteDiff;\\n  const generator = voicingGenerator({ range, dictionary, voiceLeading });\\n  generator.next();\\n  expect(generator.next('Dm7').value).toEqual(['F3', 'A3', 'C4', 'E4']);\\n  expect(generator.next('G7').value).toEqual(['F3', 'A3', 'B3', 'E4']);\\n  expect(generator.next('C^7').value).toEqual(['E3', 'G3', 'B3', 'D4']);\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"scheduling\"\n  }, \"scheduling\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Advanced_techniques\"\n  }, \"https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API/Advanced_techniques\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.html5rocks.com/en/tutorials/audio/scheduling/\"\n  }, \"https://www.html5rocks.com/en/tutorials/audio/scheduling/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/Tonejs/Tone.js/issues/507\"\n  }, \"https://github.com/Tonejs/Tone.js/issues/507\"), \" => add tip to useStateRef inside scheduling callbacks?\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"Loophole Letters"}}},"pageContext":{"id":"81d22ab2-de98-5406-8f72-e858967c958d","parent":{"name":"loops-vs-spirals","base":"loops-vs-spirals.mdx","relativePath":"loops-vs-spirals.mdx","sourceInstanceName":"content/notes"},"title":"loops-vs-spirals"}},"staticQueryHashes":[]}