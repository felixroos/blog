{"componentChunkName":"component---node-modules-gatsby-theme-notes-src-templates-note-js","path":"/notes/idea-vault/sets","result":{"data":{"note":{"id":"e4ae3717-3b94-5a46-aa11-ba3cf44f9d45","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar circleOfFifths = Array.from({\n  length: 12\n}, function (_, i) {\n  return Note.get(Note.fromMidi(60 + i * 7 % 12)).pc;\n});\n\nvar scaleColor = function scaleColor(scale) {\n  return chromaColor(scaleChroma(scale));\n};\n\nvar familyScales = function familyScales(family) {\n  return mdx(\"ul\", {\n    style: {\n      margin: 0\n    }\n  }, circleOfFifths.map(function (tonic) {\n    return mdx(\"li\", {\n      style: {\n        marginBottom: 2,\n        listStyle: 'none',\n        display: 'flex'\n      },\n      key: tonic\n    }, Scale.modeNames(\"\".concat(tonic, \" \").concat(family)).map(function (_ref, i) {\n      var _ref2 = _slicedToArray(_ref, 2),\n          root = _ref2[0],\n          scale = _ref2[1];\n\n      return mdx(\"span\", {\n        style: {\n          backgroundColor: scaleColor(\"\".concat(root, \" \").concat(scale)),\n          marginRight: 2,\n          padding: 2\n        },\n        key: i\n      }, root, \" \", scale);\n    }));\n  }));\n};\n\nvar _frontmatter = {};\nvar layoutProps = {\n  circleOfFifths: circleOfFifths,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref3) {\n  var components = _ref3.components,\n      props = _objectWithoutProperties(_ref3, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"sets\"\n  }, \"Sets\"), mdx(\"p\", null, \"This page is an overview of the sets folder, which contains some components, but mostly utility functions for handling musical pitch class sets.\"), mdx(\"p\", null, \"Many of those are presented in the post \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../pitch-class-sets/\"\n  }, \"Pitch Class Sets\"), \".\"), mdx(\"h2\", {\n    \"id\": \"dependencies\"\n  }, \"dependencies\"), mdx(\"p\", null, \"run as npm script:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"cd ./content/components/sets && dependency-cruise -x \\\\\\\"^(../../../node_modules|test)\\\\\\\" --output-type dot . | dot -T svg > deps-sets.svg && mv ./deps-sets.svg ../../../static/deps-sets.svg\\n\")), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"../../../deps-sets.svg\",\n    \"alt\": \"sets depdendencies\"\n  })), mdx(\"h2\", {\n    \"id\": \"allpitches\"\n  }, \"allPitches\"), mdx(\"p\", null, \"Those are all pitch class names in their simplest names with both sharps and flats:\"), mdx(NestedGrid, {\n    cells: allPitches,\n    rows: [1, 1, 1, 1, 1, 1],\n    mdxType: \"NestedGrid\"\n  }), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"bynotechroma\"\n  }, \"byNoteChroma\"), mdx(\"p\", null, \"Sort given pitch classes or notes by chroma.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('byNoteChroma', () => {\\n  expect(['D', 'Dbb', 'C', 'C#'].sort(byNoteChroma)).toEqual(['C', 'Dbb', 'C#', 'D']);\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"bynotecount\"\n  }, \"byNoteCount\"), mdx(\"p\", null, \"Sort given scales by note count:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('byNoteCount', () => {\\n  expect(Scale.get('dorian').intervals.length).toEqual(7);\\n  expect(['dorian', 'major pentatonic', 'major', 'minor pentatonic'].sort(byNoteCount)).toEqual([\\n    'major pentatonic',\\n    'minor pentatonic',\\n    'dorian',\\n    'major',\\n  ]);\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"bysetnum\"\n  }, \"bySetNum\"), mdx(\"p\", null, \"Sort given scales by set num:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('bySetNum', () => {\\n  expect(scaleModes('major').sort(bySetNum)).toEqual([\\n    'lydian',\\n    'major',\\n    'mixolydian',\\n    'dorian',\\n    'aeolian',\\n    'phrygian',\\n    'locrian',\\n  ]);\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"chordchroma\"\n  }, \"chordChroma\"), mdx(\"p\", null, \"Get the chroma of the given chord:\"), mdx(NestedGrid, {\n    cells: [''].concat(Range.chromatic(['C3', 'B3']).map(function (n) {\n      return Note.get(n).pc;\n    })),\n    rows: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    mdxType: \"NestedGrid\"\n  }), mdx(\"div\", null, ['C^7', 'C7', 'Cm7'].map(function (chord, i) {\n    return mdx(NestedGrid, {\n      key: i,\n      cells: [chord].concat(chordChroma(chord).split('')),\n      rows: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      mdxType: \"NestedGrid\"\n    });\n  })), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"chordChroma('C^7');\\nchordChroma('C7');\\nchordChroma('Cm7');\\n\")), mdx(\"p\", null, \"Also see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../pitch-class-sets/#chromas--set-numbers\"\n  }, \"Pitch Class Sets > Chromas & Set Numbers\")), mdx(\"h2\", {\n    \"id\": \"chordscales\"\n  }, \"chordScales\"), mdx(\"p\", null, \"find scales that are supersets of the given chord:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"expect(chordScales('m7', scaleModes('major'))).toEqual(['phrygian', 'aeolian', 'dorian']);\\nexpect(chordScales('Dm7', scaleModes('major'), true)).toEqual(['D phrygian', 'D aeolian', 'D dorian']);\\nexpect(chordScales('m7', ['minor', 'dorian', 'major'])).toEqual(['minor', 'dorian']);\\nexpect(chordScales('^7', ['minor', 'dorian', 'major'])).toEqual(['major']);\\n\")), mdx(\"h2\", {\n    \"id\": \"chromacenter\"\n  }, \"chromaCenter\"), mdx(\"p\", null, \"Get the \\u201Ccenter\\u201D of a given chroma:\"), mdx(\"p\", null, \"TBD: write test that can be understood (current test is weird)\"), mdx(\"p\", null, \"Also see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../coloring-scales/\"\n  }, \"Coloring Scales\")), mdx(\"h2\", {\n    \"id\": \"chromachords\"\n  }, \"chromaChords\"), mdx(\"p\", null, \"Get all chords that match the given chroma, based on the given tonic.\"), mdx(\"p\", null, \"TBD: write tests\\nTBD: optional tonic to get all possible chords\"), mdx(\"h2\", {\n    \"id\": \"chromacolor\"\n  }, \"chromaColor\"), mdx(\"div\", null, familyScales('major')), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"chromaColor(scaleChroma('C major')); // #BEBE2D\\n\")), mdx(\"h2\", {\n    \"id\": \"chromadifference\"\n  }, \"chromaDifference\"), mdx(\"p\", null, \"Calculates the \\u201Cbit\\u201D difference of the two given chromas:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('chromaDifference', () => {\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('F major'))).toBe(2);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('Bb major'))).toBe(4);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('Eb major'))).toBe(6);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('Ab major'))).toBe(8);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('Db major'))).toBe(10);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('Gb major'))).toBe(10);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('B major'))).toBe(10);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('E major'))).toBe(8);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('A major'))).toBe(6);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('D major'))).toBe(4);\\n  expect(chromaDifference(scaleChroma('C major'), scaleChroma('G major'))).toBe(2);\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"chromareflection\"\n  }, \"chromaReflection\"), mdx(\"p\", null, \"Reflects a chroma around the given axis (chroma index):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('chromaReflection', () => {\\n  expect(chromaReflection(scaleChroma('C major'))).toBe(scaleChroma('Ab major'));\\n  expect(chromaReflection(scaleChroma('Ab major'), Note.chroma('Ab'))).toBe(scaleChroma('E major'));\\n  expect(chromaReflection(scaleChroma('Ab major'), Note.chroma('Ab'))).toBe(scaleChroma('E major'));\\n  expect(chromaReflection(scaleChroma('E major'), Note.chroma('E'))).toBe(scaleChroma('C major'));\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"chromascale\"\n  }, \"chromaScale\"), mdx(\"p\", null, \"Find scale name for given chroma, based on given tonic:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('chromaScale', () => {\\n  expect(chromaScale('101011010101', 'C')).toBe('C major');\\n  expect(chromaScale('101011010101', 'C', [])).toBe('');\\n  expect(chromaScale('101011010101', 'D')).toBe('D dorian');\\n  expect(chromaScale('101011010101', 'Eb')).toBe('');\\n  expect(chromaScale('101011010101', 'E')).toBe('E phrygian');\\n  expect(chromaScale(scaleChroma('C major'), 'D')).toBe('D dorian'); // see relatedScale\\n});\\n\")), mdx(\"p\", null, \"TBD: optionalize tonic to receive all possible scales\\nTBD: find out difference to chromaScales function\"), mdx(\"h2\", {\n    \"id\": \"chromasymbols\"\n  }, \"chromaSymbols\"), mdx(\"p\", null, \"receive all possible scales and chords for given chroma, based on given tonic\"), mdx(\"p\", null, \"TBD: optional tonic\"), mdx(\"h2\", {\n    \"id\": \"chromaticcircle\"\n  }, \"ChromaticCircle\"), mdx(\"p\", null, \"Displays a chromatic circle:\"), mdx(ChromaticCircle, {\n    tonic: \"C\",\n    pitches: ['C', 'E', 'G'],\n    sets: [{\n      stroke: 'steelblue',\n      set: [0, 4, 7, 0]\n    }],\n    label: \"C triad\",\n    r: 80,\n    nodeRadius: 16,\n    mdxType: \"ChromaticCircle\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<ChromaticCircle\\n  tonic=\\\"C\\\"\\n  pitches={['C', 'E', 'G']}\\n  sets={[{ stroke: 'steelblue', set: [0, 4, 7, 0] }]}\\n  label=\\\"C triad\\\"\\n  r={80}\\n  nodeRadius={16}\\n/>\\n\")), mdx(\"h2\", {\n    \"id\": \"findcircularindex\"\n  }, \"findCircularIndex\"), mdx(\"p\", null, \"return first matching index, visiting all items in a circular fashion, starting from index offset:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('findCircularIndex', () => {\\n  const chroma = '101011010101'.split(''); // c major\\n  const isOne = (d) => d === '1';\\n  expect(findCircularIndex(chroma, isOne)).toBe(0);\\n  expect(findCircularIndex(chroma, isOne, 1)).toBe(2);\\n  expect(findCircularIndex(chroma, isOne, 3)).toBe(4);\\n  expect(findCircularIndex(chroma, isOne, 5)).toBe(5);\\n  expect(findCircularIndex(chroma, isOne, 6)).toBe(7);\\n  expect(findCircularIndex(chroma, isOne, 8)).toBe(9);\\n  expect(findCircularIndex(chroma, isOne, 10)).toBe(11);\\n});\\n\")), mdx(\"p\", null, \"dependency: pitch-class-sets > \", \"[rotateMode, rotateScale]\", \" > nextOne > findCircularIndex\"), mdx(\"h2\", {\n    \"id\": \"getnodes\"\n  }, \"getNodes\"), mdx(\"p\", null, \"returns nodes ChromaticCircle / HarmonicCircle.\"), mdx(\"p\", null, \"TBD: test\"), mdx(\"h2\", {\n    \"id\": \"harmoniccircle\"\n  }, \"HarmonicCircle\"), mdx(\"p\", null, \"Displays a harmonic circle:\"), mdx(HarmonicCircle, {\n    tonic: \"C\",\n    pitches: ['C', 'E', 'G'],\n    sets: [{\n      stroke: 'steelblue',\n      set: [0, 4, 7, 0]\n    }],\n    label: \"C triad\",\n    r: 80,\n    nodeRadius: 16,\n    mdxType: \"HarmonicCircle\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<HarmonicCircle\\n  tonic=\\\"C\\\"\\n  pitches={['C', 'E', 'G']}\\n  sets={[{ stroke: 'steelblue', set: [0, 4, 7, 0] }]}\\n  label=\\\"C triad\\\"\\n  r={80}\\n  nodeRadius={16}\\n/>\\n\")), mdx(\"h2\", {\n    \"id\": \"negativeharmony\"\n  }, \"negativeHarmony\"), mdx(\"p\", null, \"flips around negative harmony axis:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('negativeHarmony', () => {\\n  expect(negativeHarmony(scaleChroma('C major'), 'C')).toBe(scaleChroma('C minor'));\\n  expect(negativeHarmony(chordChroma('C'), 'C')).toBe(chordChroma('Cm'));\\n  expect(negativeHarmony(chordChroma('Eb'), 'C')).toBe(chordChroma('Am')); // https://www.youtube.com/watch?v=x6zypc_LhnM\\n  expect(negativeHarmony(chordChroma('Eb6'), 'C')).toBe(chordChroma('Am7'));\\n  expect(negativeHarmony(chordChroma('C^7'), 'C')).toBe(chordChroma('Ab^7'));\\n  expect(negativeHarmony(chordChroma('F^7'), 'C')).toBe(chordChroma('Eb^7'));\\n  expect(negativeHarmony(chordChroma('F'), 'C')).toBe(chordChroma('Gm'));\\n  expect(negativeHarmony(chordChroma('Dm7'), 'C')).toBe(chordChroma('Gm7'));\\n  expect(negativeHarmony(chordChroma('G7'), 'C')).toBe(chordChroma('Dm7b5'));\\n  expect(negativeHarmony(scaleChroma('D major'), 'D')).toBe(scaleChroma('D minor'));\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"nextone\"\n  }, \"nextOne\"), mdx(\"p\", null, \"finds next \\u201C1\\u201D in the given chroma in a circular fashion, starting from the given index:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('nextOne', () => {\\n  expect(nextOne('101', 0)).toBe(2);\\n  expect(nextOne('101', 2)).toBe(0);\\n  expect(nextOne('10001', 4)).toBe(0);\\n  expect(nextOne('01001', 4)).toBe(1);\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"nextroot\"\n  }, \"nextRoot\"), mdx(\"p\", null, \"Finds next note inside given scale, starting from given index\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('nextRoot', () => {\\n  expect(nextRoot('C major', 1)).toBe('D');\\n  expect(nextRoot('C major', 5)).toBe('F');\\n  expect(nextRoot('C major', 7)).toBe('G');\\n  expect(nextRoot('C major', 1, 'D')).toBe('E');\\n  expect(nextRoot('A locrian #2', 7)).toBe('B');\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"oneofmodes\"\n  }, \"oneOfModes\"), mdx(\"p\", null, \"scale filter function that keeps scales that are modes of the given scale families:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"expect(Scale.names().filter(oneOfModes(['major']))).toEqual([\\n  'lydian',\\n  'locrian',\\n  'phrygian',\\n  'aeolian',\\n  'dorian',\\n  'mixolydian',\\n  'major',\\n]);\\n\")), mdx(\"h2\", {\n    \"id\": \"relatedscale\"\n  }, \"relatedScale\"), mdx(\"p\", null, \"returns name of related scale of given scale, inside scale family:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('relatedScale', () => {\\n  expect(relatedScale('C major', 'D')).toBe('D dorian');\\n  expect(relatedScale('C major', 'Eb')).toBe('');\\n  expect(relatedScale('C major', 'G')).toBe('G mixolydian');\\n  expect(relatedScale('A locrian #2', 'B')).toBe('B altered');\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"reorder\"\n  }, \"reorder\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"reorder array items in a circular fashion.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the subsequent indices of the returned item are \\u201Cstep\\u201D away in the given array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"items may be skipped or duplicated if items.length % step !== 1\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"expect(reorder('ABCD'.split(''), 0).join('')).toBe('AAAA'); //\\nexpect(reorder('ABCD'.split(''), 1).join('')).toBe('ABCD'); //\\nexpect(reorder('ABCD'.split(''), 2).join('')).toBe('ACAC'); //\\nexpect(reorder('ABCD'.split(''), 3).join('')).toBe('ADCB'); //\\nexpect(reorder('ABCD'.split(''), 4).join('')).toBe('AAAA'); //\\n\")), mdx(\"h2\", {\n    \"id\": \"reorderchroma\"\n  }, \"reorderChroma\"), mdx(\"p\", null, \"reorders chroma based on given steps (only 5 and 7 make sense):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"expect(reorderChroma('101011010101', 7)).toBe('111111000001'); // chromatic to fifths c major\\nexpect(reorderChroma('111111000001', 7)).toBe('101011010101'); // fifths to chromatic c major\\nexpect(reorderChroma('101011010101', 5)).toBe('110000011111'); // chromatic to fourths c major\\nexpect(reorderChroma('110000011111', 5)).toBe('101011010101'); // fourths to chromatic c major\\n\")), mdx(\"h2\", {\n    \"id\": \"rotatechroma\"\n  }, \"rotateChroma\"), mdx(\"p\", null, \"rotate ones so that the nth \\u201C1\\u201D is at the start:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"expect(rotateChroma(1, scaleChroma('C major'))).toBe(scaleChroma('C dorian'));\\nexpect(rotateChroma(2, scaleChroma('C major'))).toBe(scaleChroma('C phrygian'));\\nexpect(rotateChroma(3, scaleChroma('C major'))).toBe(scaleChroma('C lydian'));\\nexpect(rotateChroma(4, scaleChroma('C major'))).toBe(scaleChroma('C mixolydian'));\\nexpect(rotateChroma(5, scaleChroma('C major'))).toBe(scaleChroma('C aeolian'));\\nexpect(rotateChroma(6, scaleChroma('C major'))).toBe(scaleChroma('C locrian'));\\nexpect(rotateChroma(7, scaleChroma('C major'))).toBe(scaleChroma('C major'));\\n\")), mdx(\"h2\", {\n    \"id\": \"rotatemode\"\n  }, \"rotateMode\"), mdx(\"p\", null, \"Rotate mode / tonic n steps inside scale family:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('rotateMode', () => {\\n  expect(rotateMode('A locrian #2', 7)).toBe('B altered');\\n  expect(rotateMode('A locrian #2', 1)).toBe('B altered');\\n  expect(rotateMode('A major', 1)).toBe('B dorian');\\n  expect(rotateMode('A major', 7)).toBe('E mixolydian');\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"rotatescale\"\n  }, \"rotateScale\"), mdx(\"p\", null, \"Rotate scale inside scale family:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('rotateScale', () => {\\n  expect(rotateScale('C major', 1, scaleModes('major'))).toBe('C dorian');\\n  expect(rotateScale('C major', 7, scaleModes('major'))).toBe('C mixolydian');\\n  expect(rotateScale('C major', 5, scaleModes('major'))).toBe('C lydian');\\n  expect(rotateScale('C lydian', 5, scaleModes('major'))).toBe('C locrian');\\n  expect(rotateScale('G lydian', 5, scaleModes('major'))).toBe('G locrian');\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"rotatetonic\"\n  }, \"rotateTonic\"), mdx(\"p\", null, \"TBD: depcreate / kill\"), mdx(\"h2\", {\n    \"id\": \"scalechroma\"\n  }, \"scaleChroma\"), mdx(\"p\", null, \"Get the chroma of the given scale:\"), mdx(NestedGrid, {\n    cells: [''].concat(Range.chromatic(['C3', 'B3']).map(function (n) {\n      return Note.get(n).pc;\n    })),\n    rows: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n    mdxType: \"NestedGrid\"\n  }), mdx(\"div\", null, ['C major', 'C mixolydian', 'C minor'].map(function (scale, i) {\n    return mdx(NestedGrid, {\n      key: i,\n      cells: [scale].concat(scaleChroma(scale).split('')),\n      rows: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n      mdxType: \"NestedGrid\"\n    });\n  })), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"scaleChroma('C major');\\nscaleChroma('C mixolydian');\\nscaleChroma('C minor');\\n\")), mdx(\"h2\", {\n    \"id\": \"scalecolor\"\n  }, \"scaleColor\"), mdx(\"p\", null, \"TBD: test\"), mdx(\"p\", null, \"used in chordScaleGraph > chord-scales\"), mdx(\"h2\", {\n    \"id\": \"scaledifference\"\n  }, \"scaleDifference\"), mdx(\"p\", null, \"TBD: test\"), mdx(\"h2\", {\n    \"id\": \"scalemodes\"\n  }, \"scaleModes\"), mdx(\"p\", null, \"All modes of a given scale:\"), mdx(NestedGrid, {\n    cells: scaleModes('major'),\n    rows: [1, 1, 1, 1, 1, 1, 1],\n    mdxType: \"NestedGrid\"\n  }), mdx(\"br\", null), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"scaleModes('major');\\n\")), mdx(\"p\", null, \"Also see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../../pitch-class-sets/#modes\"\n  }, \"Pitch Class Sets > Modes\")), mdx(\"h2\", {\n    \"id\": \"scalepicker\"\n  }, \"ScalePicker\"), mdx(ScalePicker, {\n    scale: 'C major',\n    onChange: function onChange(scale) {\n      return console.log(scale);\n    },\n    scales: scaleModes('major'),\n    mdxType: \"ScalePicker\"\n  }), mdx(\"h2\", {\n    \"id\": \"scalereflection\"\n  }, \"scaleReflection\"), mdx(\"p\", null, \"TBD: test\"), mdx(\"h2\", {\n    \"id\": \"simplifyscale\"\n  }, \"simplifyScale\"), mdx(\"p\", null, \"returns the scale name with the least accidentals:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('simplifyScale', () => {\\n  expect(simplifyScale('C dorian')).toBe('C dorian');\\n  expect(simplifyScale('Gb locrian')).toBe('F# locrian');\\n  expect(simplifyScale('Gb major')).toBe('Gb major');\\n  expect(simplifyScale('F# major')).toBe('F# major');\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"totalaccidentals\"\n  }, \"totalAccidentals\"), mdx(\"p\", null, \"returns sum of accidentals / note alterations:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"test('totalAccidentals', () => {\\n  expect(totalAccidentals(['C', 'D', 'E'])).toBe(0);\\n  expect(totalAccidentals(['C#', 'Db', 'F##'])).toBe(4);\\n});\\n\")), mdx(\"h2\", {\n    \"id\": \"transposescale\"\n  }, \"transposeScale\"), mdx(\"p\", null, \"TBD: deprecate / kill > unused\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"Loophole Letters"}}},"pageContext":{"id":"e4ae3717-3b94-5a46-aa11-ba3cf44f9d45","parent":{"name":"sets","base":"sets.mdx","relativePath":"idea-vault/sets.mdx","sourceInstanceName":"content/notes"},"title":"sets"}},"staticQueryHashes":[]}