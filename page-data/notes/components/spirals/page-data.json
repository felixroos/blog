{"componentChunkName":"component---node-modules-gatsby-theme-notes-src-templates-note-js","path":"/notes/components/spirals","result":{"data":{"note":{"id":"8798922b-d878-50aa-9f6b-f28c9a5f03be","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"spirals\"\n  }, \"Spirals\"), mdx(\"p\", null, \"check \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://jhhl.net/TS/tonespiral.html\"\n  }, \"https://jhhl.net/TS/tonespiral.html\")), mdx(\"h2\", {\n    \"id\": \"linear-spiral\"\n  }, \"Linear Spiral\"), mdx(\"p\", null, \"In this spiral, the radius grows linearly:\"), mdx(State, {\n    initial: {\n      zoom: 0.11,\n      spin: 0,\n      precision: 4,\n      min: 0,\n      max: 6,\n      strokeWidth: 3\n    },\n    mdxType: \"State\"\n  }, function (_ref2) {\n    var state = _ref2.state,\n        setState = _ref2.setState;\n    return mdx(React.Fragment, null, mdx(\"div\", {\n      style: {\n        overflow: \"auto\",\n        maxWidth: 900,\n        maxHeight: 700,\n        position: \"relative\"\n      }\n    }, mdx(Spiral, {\n      width: 600,\n      height: 600,\n      stroke: \"gray\",\n      zoom: state.zoom,\n      spin: state.spin,\n      min: state.min,\n      max: state.max,\n      precision: state.precision,\n      strokeWidth: state.strokeWidth,\n      mdxType: \"Spiral\"\n    }), mdx(\"div\", {\n      style: {\n        position: \"absolute\",\n        left: 10,\n        bottom: 30\n      }\n    }, mdx(SimplePopover, {\n      placement: \"left-start\",\n      mdxType: \"SimplePopover\"\n    }, mdx(\"div\", {\n      style: {\n        width: 300\n      }\n    }, mdx(SpiralSettings, {\n      state: state,\n      setState: setState,\n      mdxType: \"SpiralSettings\"\n    }))))));\n  }), mdx(\"p\", null, \"If the values for zoom and precision are close to zero, there are some interesting glitches / meta spiral patterns.\"), mdx(\"p\", null, \"Each point on the spiral is calculated like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function spiralPosition(\\n  angle,\\n  radius,\\n  spin = 0,\\n  cx = radius,\\n  cy = radius\\n): [number, number] {\\n  return [\\n    Math.sin((spin + angle) * Math.PI * 2) * radius + cx,\\n    Math.cos((spin + angle) * Math.PI * 2) * radius + cy,\\n  ]\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"logarithmic-spiral\"\n  }, \"Logarithmic Spiral\"), mdx(\"p\", null, \"The radius of the following spiral is growing exponentially:\"), mdx(State, {\n    initial: {\n      zoom: 0.85,\n      spin: 0,\n      precision: 0.2,\n      min: 5,\n      max: 11,\n      strokeWidth: 3\n    },\n    mdxType: \"State\"\n  }, function (_ref3) {\n    var state = _ref3.state,\n        setState = _ref3.setState;\n    return mdx(React.Fragment, null, mdx(\"div\", {\n      style: {\n        overflow: \"auto\",\n        maxWidth: 900,\n        maxHeight: 700,\n        position: \"relative\"\n      }\n    }, mdx(Spiral, {\n      width: 600,\n      height: 600,\n      stroke: \"gray\",\n      min: state.min,\n      max: state.max,\n      zoom: state.zoom,\n      spin: state.spin,\n      precision: state.precision,\n      strokeWidth: state.strokeWidth,\n      getRadius: function getRadius(angle) {\n        return Math.pow(Math.abs(state.zoom) * 2, Math.abs(angle)) * Math.abs(state.zoom);\n      },\n      mdxType: \"Spiral\"\n    }), mdx(\"div\", {\n      style: {\n        position: \"absolute\",\n        left: 10,\n        bottom: 30\n      }\n    }, mdx(SimplePopover, {\n      placement: \"left-start\",\n      mdxType: \"SimplePopover\"\n    }, mdx(\"div\", {\n      style: {\n        width: 300\n      }\n    }, mdx(SpiralSettings, {\n      state: state,\n      setState: setState,\n      disableZoom: true,\n      mdxType: \"SpiralSettings\"\n    }))))));\n  }), mdx(\"p\", null, \"The radius can be calculated from the angle like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function getRadius(angle) {\\n  return (\\n    Math.pow(Math.abs(state.zoom) * 2, Math.abs(angle)) * Math.abs(state.zoom)\\n  )\\n}\\n\")), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Note that the angle is a float between 0 and 1 (easier to calculate with).\")), mdx(\"p\", null, \"Some special things about logarithmic spirals:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"it is self similar across scale\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"it creates the illusion of zooming when spinning\")), mdx(\"h2\", {\n    \"id\": \"animated\"\n  }, \"Animated\"), mdx(\"p\", null, \"The following animations are made by layering multiple spirals.\"), mdx(\"h3\", {\n    \"id\": \"linear\"\n  }, \"Linear\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tap image to load random close to zero values\")), mdx(State, {\n    initial: {\n      zoom: 0.007,\n      spin: 0,\n      precision: 0.24\n    },\n    mdxType: \"State\"\n  }, function (_ref4) {\n    var state = _ref4.state,\n        setState = _ref4.setState;\n    return mdx(AnimationFrame, {\n      mdxType: \"AnimationFrame\"\n    }, function (_ref5) {\n      var time = _ref5.time,\n          start = _ref5.start;\n      return mdx(\"div\", {\n        onClick: function onClick() {\n          setState({\n            zoom: Math.random() * 0.002,\n            precision: Math.random() * 0.2\n          });\n          start();\n        }\n      }, mdx(\"p\", null, state.zoom, \"x zoom, \", state.precision, \" precision\"), mdx(Spiral, {\n        width: 600,\n        height: 600,\n        zoom: state.zoom,\n        spin: -time.fromFirstStart / 10000,\n        precision: state.precision,\n        strokeWidth: 0.5,\n        mdxType: \"Spiral\"\n      }));\n    });\n  }), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"logarithmic\"\n  }, \"Logarithmic\"), mdx(State, {\n    initial: {\n      zoom: 0.57,\n      spin: 0,\n      precision: 0.02\n    },\n    mdxType: \"State\"\n  }, function (_ref6) {\n    var state = _ref6.state,\n        setState = _ref6.setState;\n    return mdx(AnimationFrame, {\n      mdxType: \"AnimationFrame\"\n    }, function (_ref7) {\n      var time = _ref7.time,\n          start = _ref7.start;\n      return mdx(\"div\", {\n        onClick: function onClick() {\n          start();\n          setState({\n            zoom: Math.random() * 0.1 + 0.5,\n            precision: Math.random() * 0.2\n          });\n        }\n      }, mdx(\"p\", null, state.zoom, \"x zoom, \", state.precision, \" precision\"), mdx(Spiral, {\n        width: 600,\n        height: 600,\n        min: 10,\n        zoom: state.zoom,\n        spin: -time.fromFirstStart / 10000,\n        precision: state.precision,\n        strokeWidth: 0.5,\n        getRadius: function getRadius(angle) {\n          return Math.pow(Math.abs(state.zoom) * 2, Math.abs(angle)) * Math.abs(state.zoom);\n        },\n        mdxType: \"Spiral\"\n      }));\n    });\n  }), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"hypnotic\"\n  }, \"Hypnotic\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Click image to start\")), mdx(AnimationFrame, {\n    mdxType: \"AnimationFrame\"\n  }, function (_ref8) {\n    var time = _ref8.time,\n        toggle = _ref8.toggle;\n    var spirals = 4;\n    var height = 600;\n    return mdx(\"div\", {\n      style: {\n        position: \"relative\",\n        height: height\n      }\n    }, Array.from({\n      length: spirals\n    }, function (_, i) {\n      return mdx(\"div\", {\n        key: i,\n        onClick: toggle,\n        style: {\n          position: \"absolute\"\n        }\n      }, mdx(Spiral, {\n        height: height,\n        zoom: 0.5,\n        spin: (-time.fromFirstStart / 5000 + i / spirals) % 1,\n        stroke: i % 2 ? \"black\" : \"white\",\n        strokeWidth: 200 / spirals,\n        strokeLinecap: \"round\",\n        mdxType: \"Spiral\"\n      }));\n    }));\n  }), mdx(\"br\", null), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"psychedelic\"\n  }, \"Psychedelic\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Click image to start\")), mdx(\"p\", null, \"The image takes a few moments to slow down.\"), mdx(AnimationFrame, {\n    mdxType: \"AnimationFrame\"\n  }, function (_ref9) {\n    var time = _ref9.time,\n        toggle = _ref9.toggle;\n    var spirals = 4;\n    var s = time.fromFirstStart / 1000;\n    var m = s / 60;\n    var h = m / 60;\n    var d = h / 24;\n    var height = 600;\n\n    var sinFloat = function sinFloat(t) {\n      return 0.5 * (Math.sin(t * Math.PI * 2) + 1);\n    };\n\n    var hslaFloat = function hslaFloat() {\n      var h = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;\n      var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.5;\n      var l = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.5;\n      var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;\n      return \"hsla(\".concat(Math.round(h % 1 * 360), \",\").concat(s * 100, \"%,\").concat(l * 100, \"%,\").concat(a, \")\");\n    };\n\n    var colDiff = 1 / spirals;\n    return mdx(\"div\", {\n      style: {\n        position: \"relative\",\n        height: height\n      }\n    }, Array.from({\n      length: spirals\n    }, function (_, i) {\n      return mdx(\"div\", {\n        style: {\n          position: \"absolute\"\n        },\n        onClick: toggle,\n        key: i\n      }, mdx(Spiral, {\n        zoom: 0.1,\n        height: height,\n        width: 900,\n        precision: Math.sin(m) * Math.pow(2, i - spirals),\n        stroke: hslaFloat(sinFloat(m + colDiff * i), 0.5, 0.5, sinFloat(m + colDiff * i)),\n        strokeWidth: spirals / (i + 1) * 20,\n        mdxType: \"Spiral\"\n      }));\n    }));\n  }), mdx(\"h2\", {\n    \"id\": \"tempered-pythagorean-tuning\"\n  }, \"Tempered Pythagorean Tuning\"), mdx(\"p\", null, \"stacked fifths vs 12edo\"), mdx(State, {\n    initial: {\n      zoom: 0.4,\n      spin: 0,\n      precision: 1,\n      min: 0,\n      max: 2,\n      strokeWidth: 2,\n      base: 55,\n      fontSize: 14\n    },\n    mdxType: \"State\"\n  }, function (_ref10) {\n    var state = _ref10.state,\n        setState = _ref10.setState;\n    var generator = 3 / 2;\n    var notes = 25;\n    var comma = equivalence(Math.pow(generator, 12), 2) - 1;\n    var temper = true;\n\n    var tempered = function tempered(i) {\n      return temper ? 1 / (1 + comma * i / 12) : 1;\n    };\n\n    var ratios = Array.from({\n      length: notes\n    }, function (_, i) {\n      return equivalence(Math.pow(generator, i), 2) * tempered(i) * Math.pow(2, Math.floor(i / 12));\n    });\n    var angles = ratios.map(function (ratio) {\n      return angle(ratio);\n    }).sort();\n    return mdx(React.Fragment, null, mdx(\"div\", {\n      style: {\n        overflow: 'auto',\n        maxWidth: 900,\n        maxHeight: 700,\n        position: 'relative'\n      }\n    }, mdx(Spiral, _extends({\n      width: 600,\n      height: 600,\n      stroke: \"gray\"\n    }, state, {\n      max: angles[angles.length - 1] + 1,\n      getRadius: function getRadius(angle, maxRadius, zoom) {\n        return 100 + angle * 100 * zoom;\n      },\n      lines: [].concat(Array.from({\n        length: 12\n      }, function (_, i) {\n        return [angle(Math.pow(2, i / 12)), angle(Math.pow(2, i / 12) * Math.pow(2, state.max)), 'gray'];\n      })).concat(ratios.map(function (ratio) {\n        return [angle(ratio), angle(ratio * Math.pow(2, 1)), frequencyColor(ratio * 440)];\n      })).concat(angles.map(function (angle, i) {\n        var next = i + 5;\n        return [angle, angles[next % angles.length] + Math.floor(next / angles.length), 'transparent'];\n      })),\n      onTrigger: function onTrigger(i) {\n        return harp.triggerAttackRelease((i + 1) * state.base, 1);\n      },\n      mdxType: \"Spiral\"\n    })), mdx(\"div\", {\n      style: {\n        position: 'absolute',\n        left: 10,\n        bottom: 30\n      }\n    }, mdx(SimplePopover, {\n      placement: \"left-start\",\n      mdxType: \"SimplePopover\"\n    }, mdx(\"div\", {\n      style: {\n        width: 300\n      }\n    }, mdx(SpiralSettings, {\n      state: state,\n      setState: setState,\n      mdxType: \"SpiralSettings\"\n    }))))));\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Tempered Pythagorean Tuning equals 12edo!!\")), mdx(\"h2\", {\n    \"id\": \"more\"\n  }, \"More\"), mdx(\"p\", null, \"Check out harmonic-spirals for music specific spirals.\\nTBD: add examples for lines / labels for generic spirals\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"make harmonic labels/lines work for subharmonic series = negative angles\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"Loophole Letters"}}},"pageContext":{"id":"8798922b-d878-50aa-9f6b-f28c9a5f03be","parent":{"name":"spirals","base":"spirals.mdx","relativePath":"components/spirals.mdx","sourceInstanceName":"content/notes"},"title":"spirals"}},"staticQueryHashes":[]}