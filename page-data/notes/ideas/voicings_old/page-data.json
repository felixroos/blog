{"componentChunkName":"component---node-modules-gatsby-theme-notes-src-templates-note-js","path":"/notes/ideas/voicings_old","result":{"data":{"note":{"id":"409fb3b0-933e-5142-bb90-ca3ee9845e77","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"taken from notes\"), mdx(\"h1\", {\n    \"id\": \"voicings\"\n  }, \"Voicings\"), mdx(\"p\", null, \"This document describes the way to find voicings for chords.\"), mdx(\"h2\", {\n    \"id\": \"update-new-approach\"\n  }, \"UPDATE: New Approach\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"combinations(['C', 'E', 'G'], {\\n  min: 2,\\n  max: 4,\\n  maxDistance: 7,\\n  minDistance: 1,\\n  required: ['E']\\n});\\n\\n/* \\n['C','E'] \\n['E','G'] \\n['C','E','G']\\n['E','G','C']\\n['G','C','E']\\n['C','E','G','C']\\n['C','G','C','E']\\n['E','G','C','G']\\n['E','G','C','E']\\n['G','C','E','G']\\n*/\\n\")), mdx(\"p\", null, \"with range\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"combinations(['C', 'E', 'G'], {\\n  min: 2,\\n  max: 4,\\n  maxDistance: 7,\\n  minDistance: 1,\\n  required: ['E'],\\n  range: ['C3', 'C5']\\n});\\n\\n/*\\n['C3','E3']\\n['C4','E4']\\n['E3','G3']\\n['E4','G4']\\n['C3','E3','G3']\\n['C4','E4','G4']\\n['E3','G3','C4']\\n['E4','G4','C5']\\n['G3','C4','E4']\\n['C3','E3','G3','C4']\\n['C4','E4','G4','C5']\\n['C3','G3','C4','E4']\\n['E3','G3','C4','G4']\\n['E3','G3','C4','E4']\\n['G3','C4','E4','G4']\\n*/\\n\")), mdx(\"h2\", {\n    \"id\": \"definition\"\n  }, \"Definition\"), mdx(\"p\", null, \"A Voicing is a ordered collection of absolute notes that represent a certain chord. E.g. the notes \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"[D3 F3 A3 C3]\"), \" could be a voicing of a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"D-7\"), \" chord. Another representation could be \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"[A3 C3 D3 F3]\"), \".\"), mdx(\"h2\", {\n    \"id\": \"degrees\"\n  }, \"Degrees\"), mdx(\"p\", null, \"Each note (pitch class) of a voicing plays a certain role in representing a chord. In the above example the notes play the following roles in a D-7 chord:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"D: first degree\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"F: third degree\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A: fifth degree\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"C: seventh degree\")), mdx(\"p\", null, \"Some degrees are more important than others. For example the third and seventh degrees are more important than the fifths. Here is an overview of the degrees (in tertian order):\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1st: root note. commonly played in the bass.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"3rd: defines quality of chord (minor or major)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"5th: supports the root. Can be omitted.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"7th: defines quality of a 7th chord.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"9th: color/tension\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"11th: color/tension\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"13th: color/tension\")), mdx(\"p\", null, \"This means, for a triad the most important degrees are 1 and 3, and for a seventh chord 1, 3 and 7.\\n3 and 7 are also called guide tones.\"), mdx(\"h2\", {\n    \"id\": \"general-voicing-rules\"\n  }, \"General Voicing Rules\"), mdx(\"p\", null, \"see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=qNff0NZiXC8\"\n  }), \"https://www.youtube.com/watch?v=qNff0NZiXC8\"), \"\\nor \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-chord-voicings/chord-voicing-rules/\"\n  }), \"http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-chord-voicings/chord-voicing-rules/\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Always play guide tones.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"1 and 5 can be omitted.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"9 11 and 13 can be added as tensions\")), mdx(\"h3\", {\n    \"id\": \"interval-structure--consonance\"\n  }, \"Interval Structure / Consonance\"), mdx(\"p\", null, \"Even if playing the same notes (pitch classes), the tension of the resulting sound can differ, depending on the interval structure. Some intervals create higher tension (dissonant) than others (consonant):\"), mdx(\"p\", null, \"consonant: 5P, 4P, 3M, 3m\\ndissonant: 5d, 2m, 2M, 9m\"), mdx(\"p\", null, \"generally, stacking thirds leads to more consonant voicings than stacking seconds. Quartal voicings often offer a combination of both consonant and dissonant intervals.\"), mdx(\"p\", null, \"Idea: write function that calculates all interelated intervals in a voicing + tells how consonant/dissonant the sound will be.\"), mdx(\"h3\", {\n    \"id\": \"general-interval-rules\"\n  }, \"General Interval Rules\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Avoid using too many 3rds (this is too boring)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Using 4ths and tritones creates a more \\u2018open\\u2019 and \\u2018harmonically ambiguous\\u2019 sound\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Use wider intervals at the bottom (to avoid muddiness)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Play dissonant intervals in the middle\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Play a consonant interval like a 3rd or 4th between the two highest notes\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Avoid \\u2018doubling\\u2019 notes within the chords, except the top note which can be doubled (otherwise the chord sounds lopsided)\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Keep all intervals smaller than a Perfect 5th, except the interval between the two bottom notes that can be wider (this ensures what you\\u2019re playing sounds like a single whole chord rather than two chords played simultaneously but far apart from each other)\")), mdx(\"h2\", {\n    \"id\": \"finding-valid-voicings\"\n  }, \"Finding valid voicings\"), mdx(\"h3\", {\n    \"id\": \"goals\"\n  }, \"Goals\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Avoid defining fixed sets of voicings for each chord.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Be able to control tension.\")), mdx(\"p\", null, \"The tonal-chord package contains the basic structure of all common chord symbols. So Voicings can be generated by altering the order of tonals output. see \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"http://danigb.github.io/tonal/api/module-Chord.html#.notes\"\n  }), \"Chord#notes\"), \".\"), mdx(\"h3\", {\n    \"id\": \"bruteforcing-combinations\"\n  }, \"Bruteforcing Combinations\"), mdx(\"p\", null, \"One idea to find out voicings could be to generate all possible orderings of the outputted notes.\"), mdx(\"p\", null, \"A triad has 6 different combinations (3 \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" 2 \"), \" 1).\"), mdx(\"p\", null, \"A 7th chord has 24 different orderings (4 \", \"*\", \" 6).\"), mdx(\"p\", null, \"A 9th chord 120 (5 \", \"*\", \" 24).\"), mdx(\"p\", null, \"An 11th chord 720 (6 \", \"*\", \" 120).\"), mdx(\"p\", null, \"A 13th chord 5040 (7 \", \"*\", \" 720).\"), mdx(\"h4\", {\n    \"id\": \"bruteforce-algorithm\"\n  }, \"Bruteforce algorithm\"), mdx(\"p\", null, \"The following recursive algorithm finds all combinations of an array:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export function permutateArray(array: any[]) {\\n  if (array.length === 1) {\\n    return array;\\n  }\\n  return array.reduce(\\n    (combinations, el) => [\\n      ...combinations,\\n      ...permutateArray(array.filter(e => e !== el)).map(subcombinations => [\\n        el,\\n        ...subcombinations\\n      ])\\n    ],\\n    []\\n  );\\n}\\n\")), mdx(\"p\", null, \"For example Cmaj7:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"permutateArray(Chord.notes('Cmaj7'));\\n\")), mdx(\"p\", null, \"outputs\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"[\\n  ['C', 'E', 'G', 'B'],\\n  ['C', 'E', 'B', 'G'], // 7\\n  ['C', 'G', 'E', 'B'], // 7\\n  ['C', 'G', 'B', 'E'], // 7\\n  ['C', 'B', 'E', 'G'], // 7\\n  ['C', 'B', 'G', 'E'], // 7\\n  ['E', 'C', 'G', 'B'], // 7\\n  ['E', 'C', 'B', 'G'], // 7\\n  ['E', 'G', 'C', 'B'], // 7\\n  ['E', 'G', 'B', ''],\\n  ['E', 'B', 'C', 'G'], // 7\\n  ['E', 'B', 'G', 'C'], // 7\\n  ['G', 'C', 'E', 'B'], // 7\\n  ['G', 'C', 'B', 'E'], // 7\\n  ['G', 'E', 'C', 'B'], // 7\\n  ['G', 'E', 'B', 'C'], // 7\\n  ['G', 'B', 'C', ''],\\n  ['G', 'B', 'E', 'C'], // 7\\n  ['B', 'C', 'E', 'G'][('B', 'C', 'G', 'E')], // 7\\n  ['B', 'E', 'C', 'G'], // 7\\n  ['B', 'E', 'G', ''],\\n  ['B', 'G', 'C', 'E'], // 7\\n  ['B', 'G', 'E', 'C'] // 7\\n];\\n\")), mdx(\"p\", null, \"The notes are now interpreted as being stacked above in the most compact way.\"), mdx(\"h4\", {\n    \"id\": \"sorting-out-problematic-voicings\"\n  }, \"Sorting out problematic voicings\"), mdx(\"p\", null, \"Many combinations are bad, meaning they contradict, the rules \\u201CGeneral Interval Rules\\u201D above. Rule 7 alone (keep intervals lower than perfect fiths) is infringed in most of the combinations. There are only 5 combinations remaining:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"[\\n  ['C', 'E', 'G', 'B'], // default\\n  ['E', 'G', 'B', 'C'], // inversion 1\\n  ['G', 'B', 'C', 'E'], // inversion 2\\n  ['B', 'C', 'E', 'G'], // inversion 3\\n  ['B', 'E', 'G', 'C'] // quartal voicing\\n];\\n\")), mdx(\"p\", null, \"Inversion 1 also violates rule 5 (play 3rd or 4th between two highest) and inversion 3 violates rule 3 (avoid low intervals at the bottom) giving:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"[\\n  ['C', 'E', 'G', 'B'], // default\\n  ['G', 'B', 'C', 'E'], // inversion 2\\n  ['B', 'E', 'G', 'C'] // quartal voicing\\n];\\n\")), mdx(\"h3\", {\n    \"id\": \"problem\"\n  }, \"Problem\"), mdx(\"p\", null, \"Bruteforcing all combinations and sorting out the bad ones would work but the algorithm would be very expensive, especially when using more notes.\"), mdx(\"h3\", {\n    \"id\": \"custom-combination-algorithm\"\n  }, \"Custom Combination Algorithm\"), mdx(\"p\", null, \"Instead of just generating all combinations, the bad ones could be avoided at the time of generation by stopping the recursion as soon as the rules are violated.\\nThe following algorithm is similar to permutateArray, but with a validate function param added:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export function permutateElements(array, validate?, path = []) {\\n  const isValid = next => !validate || validate(path, next, array);\\n  if (array.length === 1) {\\n    return isValid(array[0]) ? array : [];\\n  }\\n  return array\\n    .filter(isValid)\\n    .reduce(\\n      (combinations, el) => [\\n        ...combinations,\\n        ...permutateElements(\\n          array.filter(e => e !== el),\\n          validate,\\n          path.concat([el])\\n        ).map(subcombinations => [el, ...subcombinations])\\n      ],\\n      []\\n    );\\n}\\n\")), mdx(\"p\", null, \"This algorithm will be called on all elements that could be combined with the current tree. So we can avoid generating all combinations of a subtree that isnt even valid in the firstplace. A validation method for rule 7 could look like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// returns false for paths that would pick next notes that are more than a fifth away\\nfunction rule7(path, next) {\\n  if (!path.length) {\\n    return true;\\n  } // no notes picked yet\\n  const interval = Distance.interval(path[path.length - 1], next);\\n  return Interval.semitones(interval) < 6; // less than fifth\\n}\\nexpect(permutateElements(['C', 'E', 'G', 'B'], rule7)).toEqual([\\n  ['C', 'E', 'G', 'B'],\\n  ['E', 'G', 'B', 'C'],\\n  ['G', 'B', 'C', 'E'],\\n  ['B', 'C', 'E', 'G'],\\n  ['B', 'E', 'G', 'C']\\n]);\\n\")), mdx(\"p\", null, \"The validation could now be wrapped to be combinable with more validation rules:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// returns function that validates the next interval with the given method\\nfunction validateInterval(validate) {\\n  return (path, next, array) => {\\n    if (!path.length) {\\n      return true;\\n    }\\n    const interval = Distance.interval(path[path.length - 1], next);\\n    return validate(interval);\\n  };\\n}\\nfunction validate(path, next, array) {\\n  return validateInterval(interval => Interval.semitones(interval) <= 6)(\\n    path,\\n    next,\\n    array\\n  );\\n}\\n\\nexpect(permutateElements(['C', 'E', 'G', 'B'], validate)).toEqual([\\n  ['C', 'E', 'G', 'B'],\\n  ['E', 'G', 'B', 'C'],\\n  ['G', 'B', 'C', 'E'],\\n  ['B', 'C', 'E', 'G'],\\n  ['B', 'E', 'G', 'C']\\n]);\\n\")), mdx(\"p\", null, \".. adding rule 5 and 3 + combineValidators Method + combineValidators sugar:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// accepts validators as arguments and combines their results with logical and. Returns validator function.\\nfunction combineValidators(...validators: ((path, next, array) => boolean)[]) {\\n  return (path, next, array) =>\\n    validators.reduce(\\n      (result, validator) => result && validator(path, next, array),\\n      true\\n    );\\n}\\n// returns validator that validates rules 7 3 and 5 of the generic interval rules\\nfunction voicingValidator(path, next, array) {\\n  return combineValidators(\\n    validateInterval(interval => Interval.semitones(interval) <= 6),\\n    validateInterval(\\n      (interval, { array }) =>\\n        array.length !== 1 || Interval.semitones(interval) > 2\\n    ),\\n    validateInterval(\\n      (interval, { array }) =>\\n        path.length !== 1 || Interval.semitones(interval) > 2\\n    )\\n  )(path, next, array);\\n}\\nexpect(permutateElements(['C', 'E', 'G', 'B'], voicingValidator)).toEqual([\\n  ['C', 'E', 'G', 'B'],\\n  ['G', 'B', 'C', 'E'],\\n  ['B', 'E', 'G', 'C']\\n]);\\n\")), mdx(\"h3\", {\n    \"id\": \"wrapping-up\"\n  }, \"Wrapping up\"), mdx(\"p\", null, \"For more sugar, lets add a new method to always get valid voicings for a given set of notes:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export function getVoicingCombinations(\\n  notes,\\n  validator = (path, next, array) => true\\n) {\\n  return permutateElements(\\n    notes,\\n    combineValidators(validator, voicingValidator)\\n  );\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"complexity\"\n  }, \"Complexity\"), mdx(\"p\", null, \"Let\\u2019s analyse the complexity of the algorithm:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export function permutationComplexity(array, validate?, path = []) {\\n  let validations = 0;\\n  permutateElements(\\n    array,\\n    (path, next, array) => {\\n      ++validations;\\n      return !validate || validate(path, next, array);\\n    },\\n    path\\n  );\\n  return validations;\\n}\\n\")), mdx(\"p\", null, \"This method adds a validator that counts up a number for each call. This number is equal to the number of recursive function calls.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"test('permutationComplexity', () => {\\n  expect(permutationComplexity([])).toBe(0);\\n  expect(permutationComplexity([1])).toBe(1);\\n  expect(permutationComplexity([1, 2])).toBe(4);\\n  expect(permutationComplexity([1, 2, 3])).toBe(15);\\n  expect(permutationComplexity([1, 2, 3, 4])).toBe(64);\\n  expect(permutationComplexity([1, 2, 3, 4, 5])).toBe(325);\\n  expect(permutationComplexity([1, 2, 3, 4, 5, 6])).toBe(1956);\\n  expect(permutationComplexity([1, 2, 3, 4, 5, 6, 7])).toBe(13699);\\n  // same goes for other element types:\\n  expect(permutationComplexity(['C', 'Eb', 'G', 'Bb'])).toBe(64);\\n  expect(permutationComplexity(['C', 'Eb', 'G', 'Bb', 'D'])).toBe(325);\\n  expect(permutationComplexity(['C', 'D', 'E', 'F', 'G', 'A', 'B'])).toBe(\\n    13699\\n  );\\n});\\n\")), mdx(\"p\", null, \"The complexity seems to follow this pattern:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-sh\"\n  }), \"c(n) = c(n-1) * n + n\\n\")), mdx(\"h3\", {\n    \"id\": \"with-interval-validation\"\n  }, \"With interval validation\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"expect(permutationComplexity(['C', 'E', 'G'], voicingValidator)).toBe(12);\\nexpect(\\n  permutationComplexity(\\n    ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#'],\\n    voicingValidator\\n  )\\n).toBe(372);\\nexpect(\\n  permutationComplexity(['C', 'D', 'E', 'F', 'G', 'A', 'B'], voicingValidator)\\n).toBe(1187);\\nexpect(permutationComplexity(['C', 'Eb', 'Gb', 'A'], voicingValidator)).toBe(\\n  44\\n);\\nexpect(permutationComplexity(['C', 'D', 'F', 'G'], voicingValidator)).toBe(29);\\nexpect(permutationComplexity(['C', 'Eb', 'G', 'Bb'], voicingValidator)).toBe(\\n  33\\n);\\nexpect(permutationComplexity(['C', 'E', 'G', 'B', 'D'], voicingValidator)).toBe(\\n  86\\n);\\nexpect(permutationComplexity(['C', 'D', 'E', 'F'], voicingValidator)).toBe(23);\\n\")), mdx(\"p\", null, \"Adding custom voicing validation, the complexity depends on the interval structure of the input.\\nBut roughly said, the call counts are now reduced by 92%-98% on the upper limit, and 51% for four voices.\"), mdx(\"h2\", {\n    \"id\": \"voice-leading\"\n  }, \"Voice Leading\"), mdx(\"p\", null, \"A very important part of playing sequential chords is voice leading. Good voice leading generally means as little movement as possible (but as much as necessary). Now that we know all valid combinations of pitch classes for a given chord, we need a way of selecting the best combinations based on the voicing that was played before.\"), mdx(\"p\", null, \"The following method calculates the intervals between each chord note:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export function voicingIntervals(chordA, chordB, min = true) {\\n  const intervals = chordA.map((n, i) => Distance.interval(n, chordB[i]));\\n  if (min) {\\n    return intervals.map(i => minInterval(i));\\n  }\\n  return intervals;\\n}\\nexpect(util.voicingIntervals(['C', 'E', 'G'], ['C', 'Eb', 'G'])).toEqual([\\n  '1P',\\n  '-1A',\\n  '1P'\\n]);\\nexpect(util.voicingIntervals(['C', 'E', 'G'], ['C', 'Eb', 'G'], false)).toEqual(\\n  ['1P', '8d', '1P']\\n);\\nexpect(util.voicingIntervals(['C', 'E', 'G'], ['C', 'Eb', 'G', 'Bb'])).toEqual([\\n  '1P',\\n  '-1A',\\n  '1P'\\n]);\\nexpect(util.voicingIntervals(['C', 'E', 'G', 'B'], ['C', 'Eb', 'G'])).toEqual([\\n  '1P',\\n  '-1A',\\n  '1P',\\n  null\\n]);\\n\")), mdx(\"p\", null, \"There are some edge cases:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"if chordB has more notes than chordA, The upper notes of chordB will be ignored.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"if chordA has more notes than chordB, the upper intervals will be null\")), mdx(\"p\", null, \"We will handle those cases later.\"), mdx(\"h3\", {\n    \"id\": \"comparing-interval-groups\"\n  }, \"Comparing interval groups\"), mdx(\"p\", null, \"To be able to compare different voicing intervals, we need a numerical value that tells how much has changed:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// adds semitones of intervals\\nexport function semitoneMovement(intervals) {\\n  return intervals.reduce((semitones, interval) => {\\n    return semitones + Interval.semitones(interval);\\n  }, 0);\\n}\\n// adds absolute semitones of intervals\\nexport function semitoneDifference(intervals) {\\n  return intervals.reduce((semitones, interval) => {\\n    return semitones + Math.abs(Interval.semitones(interval));\\n  }, 0);\\n}\\n\")), mdx(\"p\", null, \"The semitoneMovement method tells in which direction the whole movements tends. If for example one voice is going up and the other is going down the same amount, it will return 0.\\nThe semitoneDifference method tells how much difference the intervals have in absolute semitones.\\nNow we can combine the voicingIntervals and semitone functions:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export function voicingDifference(chordA, chordB, min = true) {\\n  return semitoneDifference(voicingIntervals(chordA, chordB, min));\\n}\\n\\nexport function voicingMovement(chordA, chordB, min = true) {\\n  return semitoneMovement(voicingIntervals(chordA, chordB, min));\\n}\\n\")), mdx(\"p\", null, \"Some test values:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"test('voicingDifference', () => {\\n  expect(util.voicingDifference(['C', 'E', 'G'], ['C', 'Eb', 'G'])).toBe(1);\\n  expect(util.voicingDifference(['C', 'E', 'G'], ['D', 'F#', 'A'])).toBe(6);\\n  expect(util.voicingDifference(['C', 'E', 'G'], ['E', 'G#', 'B'])).toBe(12);\\n});\\n\\ntest('voicingMovement', () => {\\n  expect(util.voicingMovement(['C', 'E', 'G'], ['C', 'Eb', 'G'])).toBe(-1);\\n  expect(util.voicingMovement(['C', 'E', 'G'], ['D', 'F#', 'A'])).toBe(6);\\n  expect(util.voicingMovement(['C', 'E', 'G'], ['B', 'E', 'G#'])).toBe(0);\\n});\\n\")), mdx(\"h3\", {\n    \"id\": \"finding-the-best-combination\"\n  }, \"Finding the best combination\"), mdx(\"p\", null, \"Now we can finally find out which voicing is the best combination to follow an existing combination:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"// finds best combination following the given notes, based on minimal movement\\nexport function bestCombination(notes, combinations) {\\n  return combinations.reduce((best, current) => {\\n    const currentMovement = voicingDifference(notes, current);\\n    const bestMovement = voicingDifference(notes, best);\\n    if (Math.abs(currentMovement) < Math.abs(bestMovement)) {\\n      return current;\\n    }\\n    return best;\\n  });\\n}\\n\\ntest.only('bestCombination', () => {\\n  const dmin = [\\n    ['F', 'A', 'C', 'E'],\\n    ['C', 'E', 'F', 'A'],\\n    ['E', 'A', 'C', 'F']\\n  ];\\n  const g7 = [\\n    ['B', 'D', 'F', 'A'],\\n    ['B', 'F', 'A', 'D'],\\n    ['F', 'A', 'B', 'D'],\\n    ['A', 'D', 'F', 'B']\\n  ];\\n  expect(getVoicingCombinations(['F', 'A', 'C', 'E'])).toEqual(dmin);\\n  expect(getVoicingCombinations(['B', 'D', 'F', 'A'])).toEqual(g7);\\n  expect(bestCombination(dmin[0], g7)).toEqual(['F', 'A', 'B', 'D']);\\n  expect(bestCombination(dmin[1], g7)).toEqual(['B', 'D', 'F', 'A']);\\n  expect(bestCombination(dmin[2], g7)).toEqual(['F', 'A', 'B', 'D']);\\n});\\n\")), mdx(\"p\", null, \"Now we now the best voice leading from one voicing to the next!\"), mdx(\"h2\", {\n    \"id\": \"adding-octaves\"\n  }, \"Adding Octaves\"), mdx(\"p\", null, \"All notes that were handled so far were just relative pitch classes without an octave.\\nThe following function will handle that:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"function getNextVoicing(chord, lastVoicing, bottomOctave = 3) {\\n  // make sure tonal can read the chord\\n  chord = getTonalChord(chord);\\n  // get chord notes\\n  const notes = Chord.notes(chord);\\n  // find voicings\\n  const combinations = getVoicingCombinations(notes);\\n  if (!lastVoicing) {\\n    return renderAbsoluteNotes(randomElement(combinations), bottomOctave);\\n  }\\n  // get pitch classes of last voicing\\n  const lastPitches = lastVoicing.map(n => Note.pc(n));\\n  // find best next combination\\n  const nextPitches = bestCombination(lastPitches, combinations);\\n  // get nearest first note\\n  const nearest = getNearestNote(lastPitches[0], nextPitches[0]);\\n  bottomOctave = Note.props(nearest).oct;\\n  // render all notes, starting from the bottomOctave\\n  return renderAbsoluteNotes(notes, bottomOctave);\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"problems\"\n  }, \"Problems\"), mdx(\"p\", null, \"When using the algorithm in the real world, one major problem is range:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"test.only('getNextVoicing', () => {\\n  let voicing;\\n  const startOctave = 3;\\n  let times = 3;\\n  for (let i = 0; i < times; ++i) {\\n    Note.names(' ')\\n      .concat(['C'])\\n      .forEach(note => {\\n        voicing = getNextVoicing(note + '-7', voicing, startOctave);\\n      });\\n  }\\n  expect(Note.oct(voicing[0])).toBe(startOctave + times);\\n});\\n\")), mdx(\"p\", null, \"This snippet will generate voicings that increase in seconds. The best voice leading for seconds\\nwill always keep the existing structure. This means that the overall pitch will increase each time and eventually exhaust the range of the instrument. A real pianist will always stay in the range where the chords sound good, even if the jumps do not follow the best voice leading. So the algorithm needs a mechanism to force leading the voices in a certain direction. The direction could be implemented at.\"), mdx(\"h2\", {\n    \"id\": \"available-and-unavailable-tensions\"\n  }, \"Available and Unavailable Tensions\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=KKk1HLsbi7A\"\n  }), \"https://www.youtube.com/watch?v=KKk1HLsbi7A\")), mdx(\"p\", null, \"Available Tensions:\\nIn a chord, you can always play a major second above a chord note (of its not the b7..)\\nAll the other notes are either chord notes or unavailable tensions.\"), mdx(\"h2\", {\n    \"id\": \"chord-symbols\"\n  }, \"Chord Symbols\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=A6Ete9i5yyc\"\n  }), \"https://www.youtube.com/watch?v=A6Ete9i5yyc\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"always play 3 and 7\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"always play highest note of chord symbol\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"e.g. C^13 => play E B and A\")), mdx(\"h2\", {\n    \"id\": \"ireal-voicings\"\n  }, \"ireal voicings\"), mdx(\"p\", null, \"InApp:\"), mdx(\"p\", null, \"5\\n2\\nadd9 +\\no\\n\\xF8\\nsus\\n\\u25B3 ^\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"m\\n\\u25B37 ^7\\n-7 m7\\n7\\n7sus\\n\\xF87\\no7\\n\\u25B39 ^9\\n\\u25B313 ^13\\n6\\n6/9 69\\n^7#11\")), mdx(\"p\", null, \"^9#11\\n^7#5\\nm6\\nm69\\n-\\u25B37 m^7\\n-\\u25B39 m^9\\n-9 m9\\n-11 m11\\n-7b5 m7b5\\n\\xF89\\n-b6 mb6\\n-#5 m#5\\n9\\n7b9\\n7#9\\n7#11\\n7b5\\n7#5\\n9#11\\n9b5\"), mdx(\"p\", null, \"9#5\\n7b13\\n7#9#5\\n7#9b5\\n7#9#11\\n7b9#11\\n7b9b5\\n7b9#5\\n7b9#9\\n7b9b13\\n7alt\\n13\\n13#11\\n13b9\\n13#9\\n7b9sus\\n7susadd3\\n9sus\\n13sus\\n7b13sus\"), mdx(\"p\", null, \"11\"), mdx(\"p\", null, \"not used\"), mdx(\"p\", null, \"add9\\n\\xF89\\n7alt\\n7susadd3\"), mdx(\"p\", null, \"used in 1350 standards:\"), mdx(\"p\", null, \"5\\n2 +\\no\\n\\xF8 (h)\\nsus\\n\\u25B3 ^\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"m\\n\\u25B37 ^7\\n-7 m7\\n7\\n7sus\\n\\xF87\\no7\\n\\u25B39 ^9\\n\\u25B313 ^13\\n6\\n6/9 69\\n^7#11\\n^9#11\\n^7#5\\nm6 -6\\nm69\\n-\\u25B37 m^7 -^7\\n-\\u25B39 m^9 -^9\\n-9 m9\\n-11 m11\\n-7b5 m7b5\\n-b6 mb6\\n-#5 m#5\\n9\\n7b9\\n7#9\\n7#11\\n7b5\\n7#5\\n9#11\\n9b5\\n9#5\\n7b13\\n7#9#5\\n7#9b5\\n7#9#11\\n7b9#11\\n7b9b5\\n7b9#5\\n7b9#9\\n7b9b13\\n13\\n13#11\\n13b9\\n13#9\\n7b9sus\\n9sus\\n13sus\\n7b13sus\\n11\")), mdx(\"p\", null, \"sonderzeichen:\"), mdx(\"p\", null, \"\\u201CW\\u201D > keine note \\xFCber x (z.B W/C)\\n\\u201Cr\\u201D > faulenzer\"), mdx(\"h2\", {\n    \"id\": \"test\"\n  }, \"Test\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"|  C-^9     |  C2       |  Ch       |  C9b5     |\\n|  C-#5     |  C7+      |  C        |  C^7      |\\n|  C7       |  C-7      |  Ch7      |  C7#9     |\\n|  C7b9     |  C^7#5    |  C^       |  C6       |\\n|  C9       |  C-6      |  Co7      |  C-^7     |\\n|  Co       |  C^9      |  C7#11    |  C7#5     |\\n|  C-       |  C7sus    |  C7sus4   |  C69      |\\n|  C7b13    |  C^       |  C+       |  C7b9b5   |\\n|  C-9      |  C9sus    |  C7b9sus  |  C7b9#5   |\\n|  C13      |  C^7#11   |  C-7b5    |  C^13     |\\n|  C7#9b5   |  C-11     |  C11      |  C7b5     |\\n|  C9#5     |  C13b9    |  C9#11    |  C13#11   |\\n|  C-b6     |  C7#9#5   |  C-69     |  C13sus   |\\n|  C^9#11   |  C7b9#9   |  Csus     |  C7#9#11  |\\n|  C7b9b13  |  C7b9#11  |  C13#9    |\\n\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"image":{"src":"/static/og-image/voicings-old-4877b62055.png"},"site":{"siteMetadata":{"title":"Loophole Letters"}}},"pageContext":{"id":"409fb3b0-933e-5142-bb90-ca3ee9845e77","parent":{"name":"voicings_old","base":"voicings_old.md","relativePath":"ideas/voicings_old.md","sourceInstanceName":"content/notes"},"title":"voicings_old"}}}