{"componentChunkName":"component---node-modules-gatsby-theme-notes-src-templates-note-js","path":"/notes/ideas/rhythmical","result":{"data":{"note":{"id":"0688a639-940d-5343-8ffa-5eedcab08214","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", {\n    \"id\": \"finding-a-textual-format-for-musical-expression\"\n  }, \"finding a textual format for musical expression\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This file documents my process of finding the idea of the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://felixroos.github.io/rhythmical/\"\n  }, \"extended rhythmical format\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Up to this point I had already implemented the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/felixroos/rhythmical\"\n  }, \"basis of rhythmical\"), \", which is the nested array syntax (similar to tidalcycles), but I had not found a solution for polyphony, other than \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/felixroos/rhythmical#polyrythms\"\n  }, \"writing multiple Tone.js schedulers\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I found inspiration after reading through \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/soundio/music-json/issues/2\"\n  }, \"this issue\"), \" and by reading through \\u201CLisp as a second language\\u201D, which implements the idea of parallel and sequential musical structures in nested lists\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I tried to search for a way of combining the nested array notation with the parallel and sequential approach, using json format\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Though it might look like it, I did not intend to write a teardown of the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/soundio/music-json\"\n  }, \"musicJSON proposal\"), \", it just acted as a starting point that got me puzzled, trying to find a better solution\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The format proposed in musicJSON is perfectly fine for many use cases (as it is essentially midi with meta data in json), I just don\\u2019t think it is a format that expresses music in a musical way, being only suitable to be processed by machines rather by humans\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If you have questions, arguments, ideas or similar, you leave me a message \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/felixroos/\"\n  }, \"at github\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://felixroos.github.io/rhythmical/\"\n  }, \"I have implemented the format with many additions\"))), mdx(\"h2\", {\n    \"id\": \"original-musicjson-proposal\"\n  }, mdx(\"a\", {\n    parentName: \"h2\",\n    \"href\": \"https://github.com/soundio/music-json#music-json-proposal\"\n  }, \"original musicJSON proposal\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"name\\\": \\\"Dolphin Dance\\\",\\n  \\\"events\\\": [\\n    [2, \\\"note\\\", 76, 0.8, 0.5],\\n    [2.5, \\\"note\\\", 77, 0.6, 0.5],\\n    [3, \\\"note\\\", 79, 1, 0.5],\\n    [3.5, \\\"note\\\", 74, 1, 3.5],\\n    [10, \\\"note\\\", 76, 1, 0.5],\\n    [0, \\\"chord\\\", \\\"C\\\", \\\"\\u2206\\\", 4],\\n    [4, \\\"chord\\\", \\\"G\\\", \\\"-\\\", 4]\\n  ],\\n  \\\"interpretation\\\": {\\n    \\\"time_signature\\\": \\\"4/4\\\",\\n    \\\"key\\\": \\\"C\\\",\\n    \\\"transpose\\\": 0\\n  }\\n}\\n\")), mdx(\"h1\", {\n    \"id\": \"ideas-for-optimization\"\n  }, \"ideas for optimization\"), mdx(\"h2\", {\n    \"id\": \"idea-1-use-object-syntax-for-being-independent-of-param-ordering\"\n  }, \"idea 1: use object syntax for being independent of param ordering:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"t\\\": 2, \\\"note\\\": 76, \\\"v\\\": 0.8, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 2.5, \\\"note\\\": 77, \\\"v\\\": 0.6, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 3, \\\"note\\\": 79, \\\"v\\\": 1, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 3.5, \\\"note\\\": 74, \\\"v\\\": 1, \\\"d\\\": 3.5 },\\n  { \\\"t\\\": 10, \\\"note\\\": 76, \\\"v\\\": 1, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 0, \\\"chord\\\": \\\"C\\\", \\\"symbol\\\": \\\"\\u2206\\\", \\\"d\\\": 4 },\\n  { \\\"t\\\": 4, \\\"chord\\\": \\\"G\\\", \\\"symbol\\\": \\\"-\\\", \\\"d\\\": 4 }\\n]\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"t = time => defaults to 0\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"v = velocity => defaults to 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"d = duration => defaults to 1\")), mdx(\"h3\", {\n    \"id\": \"benefits-of-object-syntax\"\n  }, \"benefits of object syntax\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"readability\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"flexibility => can move properties around\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"easy manipulation using object destructuring\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can set default values and omit them\")), mdx(\"h3\", {\n    \"id\": \"drawbacks-of-object-syntax\"\n  }, \"drawbacks of object syntax\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"more verbose\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"can be solved with primitive optimization (for many common use cases), see below\")), mdx(\"h3\", {\n    \"id\": \"optimization-value-attribute--type\"\n  }, \"optimization: value attribute + type\"), mdx(\"p\", null, \"Currently we have chord and note attributes. It would be slicker to have a more open value attribute + an optional type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"t\\\": 2, \\\"value\\\": 76, \\\"v\\\": 0.8, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 2.5, \\\"value\\\": 77, \\\"v\\\": 0.6, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 3, \\\"value\\\": 79, \\\"v\\\": 1, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 3.5, \\\"value\\\": 74, \\\"v\\\": 1, \\\"d\\\": 3.5 },\\n  { \\\"t\\\": 10, \\\"value\\\": 76, \\\"v\\\": 1, \\\"d\\\": 0.5 },\\n  { \\\"t\\\": 0, \\\"value\\\": \\\"C\\u2206\\\", \\\"type\\\": \\\"chord\\\", \\\"d\\\": 4 },\\n  { \\\"t\\\": 4, \\\"value\\\": \\\"G-\\\", \\\"type\\\": \\\"chord\\\", \\\"d\\\": 4 }\\n]\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Now the default type is \\u2018note\\u2019\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Also, i removed the symbol attribute and concatted them to the value.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I see no reason why those should be seperated as it is totally possible to parse those (e.g. see tonal lib).\")))), mdx(\"h3\", {\n    \"id\": \"primitive-shorthand-notation\"\n  }, \"primitive shorthand notation\"), mdx(\"p\", null, \"We could allow primitves (= strings or numbers) to drastically cut the characters for events that happen all at the same time like chords:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const cMajorStrings = [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"]\\nconst cMajorNumbers = [61, 65, 68]\\n\")), mdx(\"p\", null, \"Using default values strings can then be converted to\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const cMajorStrings = [\\n  { value: \\\"C3\\\", d: 1, v: 1, t: 0 },\\n  { value: \\\"E3\\\", d: 1, v: 1, t: 0 },\\n  { value: \\\"E3\\\", d: 1, v: 1, t: 0 },\\n]\\nconst cMajorNumbers = [\\n  { value: 61, d: 1, v: 1, t: 0 },\\n  { value: 65, d: 1, v: 1, t: 0 },\\n  { value: 68, d: 1, v: 1, t: 0 },\\n]\\n\")), mdx(\"h3\", {\n    \"id\": \"typescript-interfaces\"\n  }, \"typescript interfaces\"), mdx(\"p\", null, \"Lets formulate typescript interfaces for the current state of our object:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface AbsoluteEvent<T> T | {\\n    t: number = 0,\\n  value: T,\\n  type: string = 'note',\\n    v: number = 1,\\n  d: number = 1\\n}\\ndeclare type AbsoluteEvents = AbsoluteEvent<any>[];\\n\")), mdx(\"h2\", {\n    \"id\": \"idea-2-relative-time\"\n  }, \"idea 2: relative time\"), mdx(\"p\", null, \"Lets add a feature that approaches the way humans read and write music:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"get rid of absolute time\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"introduce rests\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"t\\\": 0, \\\"d\\\": 4, \\\"value\\\": \\\"C\\u2206\\\", \\\"type\\\": \\\"chord\\\" },\\n  { \\\"d\\\": 2, \\\"type\\\": \\\"rest\\\" },\\n  { \\\"d\\\": 0.5, \\\"value\\\": 76, \\\"v\\\": 0.8 },\\n  { \\\"d\\\": 0.5, \\\"value\\\": 77, \\\"v\\\": 0.6 },\\n  { \\\"d\\\": 0.5, \\\"value\\\": 79 },\\n  { \\\"d\\\": 3.5, \\\"value\\\": 74 },\\n  { \\\"t\\\": 4, \\\"d\\\": 4, \\\"value\\\": \\\"G-\\\", \\\"type\\\": \\\"chord\\\" },\\n  { \\\"d\\\": 1, \\\"type\\\": \\\"rest\\\" },\\n  { \\\"d\\\": 2, \\\"type\\\": \\\"rest\\\" },\\n  { \\\"d\\\": 0.5, \\\"value\\\": 76 }\\n]\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"t can still be set => object is treated absolute\")), mdx(\"h3\", {\n    \"id\": \"conversion-to-absolute-time\"\n  }, \"conversion to absolute time\"), mdx(\"p\", null, \"To make this machine readable / playable, we can easily calculate the absolute time value for each event by adding all previous durations (of non absolute events) together:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"t\\\": 0, \\\"d\\\": 4, \\\"value\\\": \\\"C\\u2206\\\", \\\"type\\\": \\\"chord\\\" },\\n  { \\\"t\\\": 0, \\\"d\\\": 2 },\\n  { \\\"t\\\": 2, \\\"d\\\": 0.5, \\\"value\\\": 76, \\\"v\\\": 0.8 },\\n  { \\\"t\\\": 2.5, \\\"d\\\": 0.5, \\\"value\\\": 77, \\\"v\\\": 0.6 },\\n  { \\\"t\\\": 3, \\\"d\\\": 0.5, \\\"value\\\": 79 },\\n  { \\\"t\\\": 3.5, \\\"d\\\": 3.5, \\\"value\\\": 74 },\\n  { \\\"t\\\": 4, \\\"d\\\": 4, \\\"value\\\": \\\"G-\\\", \\\"type\\\": \\\"chord\\\" },\\n  { \\\"t\\\": 7, \\\"d\\\": 1 }, // rest\\n  { \\\"t\\\": 8, \\\"d\\\": 2 }, // rest\\n  { \\\"t\\\": 10, \\\"d\\\": 0.5, \\\"value\\\": 76 }\\n]\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Note that the chord events stay like they are + their duration is ignored for calculation (because they have t defined)\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"The need to keep absolute time values for the chords conveys a limitation of relative time: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"It can only express monophonic sequences\"), \". We will find a much neater abstraction for this later.\")), mdx(\"h3\", {\n    \"id\": \"primitive-shorthand-notation-1\"\n  }, \"primitive shorthand notation\"), mdx(\"p\", null, \"Like before, we could further optimize the relative format by allowing primitives (= numbers or strings) instead of objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const cMajorNumbers = [61, 62, 63, 64, 65, 66, 67, 68]\\nconst cMajorStrings = [\\\"C3\\\", \\\"D3\\\", \\\"E3\\\", \\\"F3\\\", \\\"G3\\\", \\\"A3\\\", \\\"B3\\\", \\\"C4\\\"]\\n\")), mdx(\"p\", null, \"those strings could be interpreted as values:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const cMajorNumbers = [\\n  { value: 61 },\\n  { value: 62 },\\n  { value: 63 },\\n  { value: 64 },\\n  { value: 65 },\\n  { value: 66 },\\n  { value: 67 },\\n  { value: 68 },\\n]\\nconst cMajorStrings = [\\n  { value: \\\"C3\\\" },\\n  { value: \\\"D3\\\" },\\n  { value: \\\"E3\\\" },\\n  { value: \\\"F3\\\" },\\n  { value: \\\"G3\\\" },\\n  { value: \\\"A3\\\" },\\n  { value: \\\"B3\\\" },\\n  { value: \\\"C4\\\" },\\n]\\n\")), mdx(\"p\", null, \"which, with added defaults, would result in:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"value\\\": \\\"C3\\\", \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"D3\\\", \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"E3\\\", \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"F3\\\", \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"G3\\\", \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"A3\\\", \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"B3\\\", \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"C4\\\", \\\"d\\\": 1, \\\"v\\\": 1 }\\n]\\n\")), mdx(\"p\", null, \"\\u2026 which could be transformed to absolute time by adding all previous durations together:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"value\\\": \\\"C3\\\", \\\"t\\\": 0, \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"D3\\\", \\\"t\\\": 1, \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"E3\\\", \\\"t\\\": 2, \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"F3\\\", \\\"t\\\": 3, \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"G3\\\", \\\"t\\\": 4, \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"A3\\\", \\\"t\\\": 5, \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"B3\\\", \\\"t\\\": 6, \\\"d\\\": 1, \\\"v\\\": 1 },\\n  { \\\"value\\\": \\\"C4\\\", \\\"t\\\": 7, \\\"d\\\": 1, \\\"v\\\": 1 }\\n]\\n\")), mdx(\"p\", null, \"\\u2026 which can now be parsed easily.\"), mdx(\"h3\", {\n    \"id\": \"typescript-interfaces-1\"\n  }, \"typescript interfaces\"), mdx(\"p\", null, \"Lets formulate typescript interfaces for that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface RelativeEvent<T> = T | {\\n  d: number = 1, // duration\\n  value?: T,\\n  type: string = 'note',\\n  v: number = 1, // volume\\n}\\ntype RelativeEvents = RelativeEvent[];\\ntype MixedEvents = Array<RelativeEvent<any> | AbsoluteEvent<any>>;\\n\")), mdx(\"h3\", {\n    \"id\": \"benefits-for-relative-time\"\n  }, \"benefits for relative time:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"less edits required for common operations\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"better readability\")), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"axiom\"), \": a good format will always require less edits/keystrokes for common operations\\ncommon operations: inserting bars, removing bars, duplicating measures\")), mdx(\"p\", null, \"examples where less edits are beneficial:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"version control\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"writing by hand / live coding\")), mdx(\"h3\", {\n    \"id\": \"edit-example-1-removing-bars-with-absolute-time\"\n  }, \"edit example 1: removing bars with absolute time\"), mdx(\"p\", null, \"image those two bars in absolute time notation:\"), mdx(\"p\", null, \"example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const absoluteBars = [\\n  // first measure\\n  { t: 0 /* .. */ },\\n  { t: 1 /* .. */ },\\n  { t: 1.5 /* .. */ },\\n  { t: 2 /*..*/ },\\n  // second measure\\n  { t: 4 /* .. */ },\\n  { t: 4.5 /* .. */ },\\n  { t: 5 /* .. */ },\\n  { t: 6 /*..*/ },\\n  { t: 7 /*..*/ },\\n]\\n\")), mdx(\"p\", null, \"if we want to remove the first bar, we need to adjust subtract 4 beats from all notes that come after.\\nthis would be the end result:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const absoluteBarsEdited = [\\n  // second measures\\n  { t: 0 /* .. */ },\\n  { t: 0.5 /* .. */ },\\n  { t: 1 /* .. */ },\\n  { t: 2 /*..*/ },\\n  { t: 3 /*..*/ },\\n]\\n\")), mdx(\"p\", null, \"if we would not subtract 4 beats, we would have one measure silence.\"), mdx(\"p\", null, \"similar to that, if we want to duplicate a phrase, we need to adjust all numbers.\\nif we duplicate without further adjustments, we have the same phrase at the same position => not useful\"), mdx(\"p\", null, \"same thing applies for moving stuff around.\"), mdx(\"h3\", {\n    \"id\": \"edit-example-2-removing-bars-with-relative-time\"\n  }, \"edit example 2: removing bars with relative time\"), mdx(\"p\", null, \"imagine the same bars in relative notation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const relativeBars = [\\n  // first measure\\n  { d: 1 /* .. */ },\\n  { d: 0.5 /* .. */ },\\n  { d: 0.5 /* .. */ },\\n  { d: 2 /*..*/ },\\n  // second measures\\n  { d: 0.5 /* .. */ },\\n  { d: 0.5 /* .. */ },\\n  { d: 1 /* .. */ },\\n  { d: 1 /*..*/ },\\n  { d: 1 /*..*/ },\\n]\\n\")), mdx(\"p\", null, \"if we want to remove the first bar, we can just remove it and the rest will automatically be placed at the start.\\nif we really wanted to behave it as the absolute format does, we can just insert a bar rest:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const relativeBarsWithRest = [\\n  // first measure\\n  {d: 4, type: \\\"rest\\\" },\\n  // second measures\\n  {t: 0.5, /* */ }\\n  {t: 0.5, /* */ }\\n  {t: 1, /* */ }\\n  {t: 1, /* */ }\\n  {t: 1, /* */ }\\n]\\n\")), mdx(\"h2\", {\n    \"id\": \"idea-3-combining-absolute-and-relative-events-through-nesting\"\n  }, \"idea 3: combining absolute and relative events through nesting\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface RelativeEvent<T> = T | {\\n  d: number = 1,\\n  value?: T,\\n  type: string = 'note',\\n  v: number = 1,\\n}\\n\\ninterface AbsoluteEvent<T> T | {\\n  t: number = 0,\\n  d: number = 1,\\n  value: T,\\n  type: string = 'note',\\n  v: number = 1,\\n}\\n\")), mdx(\"p\", null, \"By comparing the two events, we see they are almost the same, except the t property. We could combine both:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface Event<T> T | {\\n  t?: number; // if set, event is treated absolute\\n  d: number = 1\\n  value: T | T[]; // add possibility to use array\\n  type: string = 'note',\\n  v: number = 1;\\n}\\n\")), mdx(\"p\", null, \"and add a nested array type:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface NestedArray<T> extends Array<T | NestedArray<T>>;\\ndeclare type NestedEvent = NestedArray<Event<string>>;\\n\")), mdx(\"p\", null, \"Now we can endlessly nest events into each other\"), mdx(\"p\", null, \"e.g. a chord sequence could like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  {\\n    \\\"type\\\": \\\"relative\\\",\\n    \\\"value\\\": [\\n      { \\\"type\\\": \\\"absolute\\\", \\\"value\\\": [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { \\\"type\\\": \\\"absolute\\\", \\\"value\\\": [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { \\\"type\\\": \\\"absolute\\\", \\\"value\\\": [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] }\\n    ]\\n  }\\n]\\n\")), mdx(\"p\", null, \"If we would express this as a hard coded type, this would be:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"interface MyChordSequence = Array<Event<Array<Event<string[]>>>>\\n\")), mdx(\"p\", null, \"Now lets think through how this would be converted to absolute, non nested events.\"), mdx(\"h3\", {\n    \"id\": \"peeling-the-onion\"\n  }, \"peeling the onion\"), mdx(\"p\", null, \"Lets imagine how the algorithm would resolve this nested structure. Note that the following process will not be the end algorithm but just an illustration of how it might work.\"), mdx(\"p\", null, \"The type now affects how children are given their default values. On the outer most event, deafault values are added + the children (layer 2) are treated relative (adding up default values):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const peeled = [\\n  // layer 1\\n  {\\n    t: 0,\\n    d: 1,\\n    v: 1,\\n    type: \\\"relative\\\",\\n    value: [\\n      // layer 2\\n      { t: 0, d: 1, v: 1, type: \\\"absolute\\\", value: [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { t: 1, d: 1, v: 1, type: \\\"absolute\\\", value: [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { t: 2, d: 1, v: 1, type: \\\"absolute\\\", value: [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] },\\n    ],\\n  },\\n]\\n\")), mdx(\"p\", null, \"Now having absolute times on the first and second layer, we can multiply the outer duration with all inner durations and times (nothing spectacular happens as all durations are 1) and then add the times together. This way we can remove the outer layer as it is now represented in the second level:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const peeled = [ // layer 2\\n  { t: 0, d: 1, v: 1, type: \\\"absolute\\\", value: [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n  { t: 1, d: 1, v: 1, type: \\\"absolute\\\", value: [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n  { t: 2, d: 1, v: 1, type: \\\"absolute\\\", value: [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] },\\n],\\n\")), mdx(\"p\", null, \"Now we can convert the strings in the third layer to objects with default values:\"), mdx(\"p\", null, \"The whole object now looks like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const peeled = [\\n  // former layer 2\\n  {\\n    t: 0,\\n    d: 1,\\n    v: 1,\\n    type: \\\"absolute\\\",\\n    value: [\\n      // former layer 3\\n      { value: \\\"C3\\\", t: 0, d: 1, v: 1 },\\n      { value: \\\"E3\\\", t: 0, d: 1, v: 1 },\\n      { value: \\\"G3\\\", t: 0, d: 1, v: 1 },\\n    ],\\n  },\\n  {\\n    t: 1,\\n    d: 1,\\n    v: 1,\\n    type: \\\"absolute\\\",\\n    value: [\\n      { value: \\\"C3\\\", t: 0, d: 1, v: 1 },\\n      { value: \\\"F3\\\", t: 0, d: 1, v: 1 },\\n      { value: \\\"A3\\\", t: 0, d: 1, v: 1 },\\n    ],\\n  },\\n  {\\n    t: 2,\\n    d: 1,\\n    v: 1,\\n    type: \\\"absolute\\\",\\n    value: [\\n      { value: \\\"D3\\\", t: 0, d: 1, v: 1 },\\n      { value: \\\"G3\\\", t: 0, d: 1, v: 1 },\\n      { value: \\\"B3\\\", t: 0, d: 1, v: 1 },\\n    ],\\n  },\\n]\\n\")), mdx(\"p\", null, \"Now, again, we can combine the times and duration by multiplying durations and adding times together:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const peeled = [\\n  { value: \\\"C3\\\", t: 0, d: 1, v: 1 },\\n  { value: \\\"E3\\\", t: 0, d: 1, v: 1 },\\n  { value: \\\"G3\\\", t: 0, d: 1, v: 1 },\\n  { value: \\\"C3\\\", t: 1, d: 1, v: 1 },\\n  { value: \\\"F3\\\", t: 1, d: 1, v: 1 },\\n  { value: \\\"A3\\\", t: 1, d: 1, v: 1 },\\n  { value: \\\"D3\\\", t: 2, d: 1, v: 1 },\\n  { value: \\\"G3\\\", t: 2, d: 1, v: 1 },\\n  { value: \\\"B3\\\", t: 2, d: 1, v: 1 },\\n]\\n\")), mdx(\"p\", null, \"Thats it! We have successfully turned the nested object into a single layer array with absolute events.\\nThis was just a non formal proof that this could be done with an algorithm.\"), mdx(\"h3\", {\n    \"id\": \"optimization-1-extra-attributes-to-eliminate-type\"\n  }, \"optimization 1: extra attributes to eliminate type\"), mdx(\"p\", null, \"as an alternative to the type / value combination, we could add extra attributes for absolute and relative children:\"), mdx(\"p\", null, \"chord sequence before:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const before = [\\n  {\\n    type: \\\"relative\\\",\\n    value: [\\n      { type: \\\"absolute\\\", value: [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { type: \\\"absolute\\\", value: [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { type: \\\"absolute\\\", value: [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] },\\n    ],\\n  },\\n]\\n\")), mdx(\"p\", null, \"after:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const after = [\\n  {\\n    relative: [\\n      { absolute: [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { absolute: [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { absolute: [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] },\\n    ],\\n  },\\n]\\n\")), mdx(\"p\", null, \"This is much more compact and readable!\"), mdx(\"h4\", {\n    \"id\": \"other-possible-wordings\"\n  }, \"Other possible wordings\"), mdx(\"p\", null, \"one good metaphor would be electric circuits, which work just like our timing system:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const circuit = [\\n  {\\n    series: [\\n      { parallel: [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { parallel: [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { parallel: [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] },\\n    ],\\n  },\\n]\\n\")), mdx(\"p\", null, \"another would be using daw wording:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const song = [\\n  {\\n    sequence: [\\n      { tracks: [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { tracks: [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { tracks: [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] },\\n    ],\\n  },\\n]\\n\")), mdx(\"p\", null, \"or like in the lisp paper:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const music = [\\n  {\\n    sequential: [\\n      { parallel: [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { parallel: [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { parallel: [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] },\\n    ],\\n  },\\n]\\n\")), mdx(\"p\", null, \"I\\u2019ll stick to relative / absolute for now but this may change in the implementation\"), mdx(\"h3\", {\n    \"id\": \"optimization-2-relative-as-default-mode\"\n  }, \"optimization 2: relative as default mode\"), mdx(\"p\", null, \"Another great optimization is using relative as default, so we can just use an array:\"), mdx(\"p\", null, \"instead of this\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  {\\n    \\\"relative\\\": [\\n      { \\\"absolute\\\": [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n      { \\\"absolute\\\": [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n      { \\\"absolute\\\": [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] }\\n    ]\\n  }\\n]\\n\")), mdx(\"p\", null, \"that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"absolute\\\": [\\\"C3\\\", \\\"E3\\\", \\\"G3\\\"] },\\n  { \\\"absolute\\\": [\\\"C3\\\", \\\"F3\\\", \\\"A3\\\"] },\\n  { \\\"absolute\\\": [\\\"D3\\\", \\\"G3\\\", \\\"B3\\\"] }\\n]\\n\")), mdx(\"p\", null, \"So each array is treated as relative, as long it is not the value of an \\u201Cabsolute\\u201D attribute.\"), mdx(\"p\", null, \"This enables us to write:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\\"C3\\\", [\\\"D3\\\", \\\"E3\\\"], \\\"F3\\\", [\\\"D3\\\", \\\"E3\\\"]]\\n\")), mdx(\"p\", null, \"which could be interpreted as\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"a quarter note\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"followed by two eights notes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"followed by a quarter note\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"followed by two eights notes\")), mdx(\"p\", null, \"This is the same notation principle that tidalcycles uses.\"), mdx(\"p\", null, \"Resolving the default mode:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"relative\\\": [\\n    \\\"C3\\\",\\n    { \\\"relative\\\": [\\\"D3\\\", \\\"E3\\\"] },\\n    \\\"F3\\\",\\n    { \\\"relative\\\": [\\\"D3\\\", \\\"E3\\\"] }\\n  ]\\n}\\n\")), mdx(\"p\", null, \"Resolving strings to objects:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n  \\\"relative\\\": [\\n    { \\\"value\\\": \\\"C3\\\" },\\n    { \\\"relative\\\": [{ \\\"value\\\": \\\"D3\\\" }, { \\\"value\\\": \\\"E3\\\" }] },\\n    { \\\"value\\\": \\\"F3\\\" },\\n    { \\\"relative\\\": [{ \\\"value\\\": \\\"D3\\\" }, { \\\"value\\\": \\\"E3\\\" }] }\\n  ]\\n}\\n\")), mdx(\"p\", null, \"peeling off layer 1:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"t\\\": 0, \\\"d\\\": 1, \\\"value\\\": \\\"C3\\\" },\\n  { \\\"t\\\": 1, \\\"d\\\": 1, \\\"relative\\\": [{ \\\"value\\\": \\\"D3\\\" }, { \\\"value\\\": \\\"E3\\\" }] },\\n  { \\\"t\\\": 2, \\\"d\\\": 1, \\\"value\\\": \\\"F3\\\" },\\n  { \\\"t\\\": 3, \\\"d\\\": 1, \\\"relative\\\": [{ \\\"value\\\": \\\"D3\\\" }, { \\\"value\\\": \\\"E3\\\" }] }\\n]\\n\")), mdx(\"p\", null, \"adding default values to layer 2\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"t\\\": 0, \\\"d\\\": 1, \\\"value\\\": \\\"C3\\\" },\\n  {\\n    \\\"t\\\": 1,\\n    \\\"d\\\": 1,\\n    \\\"value\\\": [\\n      { \\\"t\\\": 0, \\\"d\\\": 1, \\\"value\\\": \\\"D3\\\" },\\n      { \\\"t\\\": 1, \\\"d\\\": 1, \\\"value\\\": \\\"E3\\\" }\\n    ]\\n  },\\n  { \\\"t\\\": 2, \\\"d\\\": 1, \\\"value\\\": \\\"F3\\\" },\\n  {\\n    \\\"t\\\": 3,\\n    \\\"d\\\": 1,\\n    \\\"value\\\": [\\n      { \\\"t\\\": 0, \\\"d\\\": 1, \\\"value\\\": \\\"D3\\\" },\\n      { \\\"t\\\": 1, \\\"d\\\": 1, \\\"value\\\": \\\"E3\\\" }\\n    ]\\n  }\\n]\\n\")), mdx(\"p\", null, \"peeling off layer 2:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  { \\\"t\\\": 0, \\\"d\\\": 1, \\\"value\\\": \\\"C3\\\" },\\n  { \\\"t\\\": 1, \\\"d\\\": 0.5, \\\"value\\\": \\\"D3\\\" },\\n  { \\\"t\\\": 1.5, \\\"d\\\": 0.5, \\\"value\\\": \\\"E3\\\" },\\n  { \\\"t\\\": 2, \\\"d\\\": 1, \\\"value\\\": \\\"F3\\\" },\\n  { \\\"t\\\": 3, \\\"d\\\": 0.5, \\\"value\\\": \\\"D3\\\" },\\n  { \\\"t\\\": 3.5, \\\"d\\\": 0.5, \\\"value\\\": \\\"E3\\\" }\\n]\\n\")), mdx(\"p\", null, \"Note that we need to divide time and duration by the number of children in a group to resolve it! This will later be done by the algorithm using arrays of fractions.\"), mdx(\"h3\", {\n    \"id\": \"polyphony-example\"\n  }, \"Polyphony example\"), mdx(\"p\", null, \"We could arrange multiple tracks like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const backbeat = {\\n  absolute: [\\n    [\\\"bd\\\", \\\"~\\\", \\\"bd\\\", \\\"~\\\"], //bassdrum\\n    [\\\"hh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\"], //hihat\\n    [\\\"~\\\", \\\"sd\\\", \\\"~\\\", \\\"sd\\\"], //snaredrum\\n  ],\\n}\\n\")), mdx(\"p\", null, \"Note that the inner arrays will still be relative by default, as the absolute param only tells that the next level will be absolute. It will resolve like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"{\\n  absolute: [\\n    { relative: [\\\"bd\\\", \\\"~\\\", \\\"bd\\\", \\\"~\\\"] },\\n    { relative: [\\\"hhhh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\", \\\"hh\\\"] },\\n    { relative: [\\\"~\\\", \\\"snare\\\", \\\"~\\\", \\\"snare\\\"] },\\n  ],\\n}\\n\")), mdx(\"p\", null, \"This has now been implemented! Have a look at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://felixroos.github.io/rhythmical/\"\n  }, \"rhythmical REPL\")));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"Loophole Letters"}}},"pageContext":{"id":"0688a639-940d-5343-8ffa-5eedcab08214","parent":{"name":"rhythmical","base":"rhythmical.md","relativePath":"ideas/rhythmical.md","sourceInstanceName":"content/notes"},"title":"rhythmical"}},"staticQueryHashes":[]}