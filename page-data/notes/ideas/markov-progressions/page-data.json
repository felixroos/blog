{"componentChunkName":"component---node-modules-gatsby-theme-notes-src-templates-note-js","path":"/notes/ideas/markov-progressions","result":{"data":{"note":{"id":"3f8dfd0a-51dd-5710-bdfe-e495344c2562","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Moved from harmonical lib > still contains source code to generate stuff\"), mdx(\"h1\", {\n    \"id\": \"markov-chain-chord-progressions\"\n  }, \"Markov Chain Chord Progressions\"), mdx(\"p\", null, \"Idea: Use Markov Chains to generate chord sequences\"), mdx(\"p\", null, mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"http://setosa.io/ev/markov-chains/\"\n  }, \"(If you forgot what markov chains are)\")), mdx(\"h2\", {\n    \"id\": \"markov-states\"\n  }, \"Markov States\"), mdx(\"p\", null, \"Each possible chord is a state:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"There are ~60 chord symbols used in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/felixroos/harmonical/blob/master/src/Harmony.ts#L12\"\n  }, \"ireal\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each chord can have 12 different roots (possibly more due to enharmonics)\")), mdx(\"p\", null, \"So there are 60\", \"*\", \"12 = 720 states.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"TBD: Think about harmonic rhythm\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"TBD: Think about pitch independent states\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"em\", {\n    parentName: \"li\"\n  }, \"TBD: Think about states that include enharmonics\"))), mdx(\"h2\", {\n    \"id\": \"transition-probabilities\"\n  }, \"Transition Probabilities\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Using the ireal 1350 standards set, we can calculate the probabilities between the states.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"I already created the 1350_stats set\")), mdx(\"h3\", {\n    \"id\": \"data-structures\"\n  }, \"Data Structures\"), mdx(\"p\", null, \"The changes set has the following structure:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const changes = [\\n  {\\n    semitones: 5,\\n    symbols: ['-7', '7'],\\n    count: 7584,\\n    roots: {\\n      C: 1015,\\n      D: 1249\\n      /* ... all root counts */\\n    },\\n    chromas: {\\n      '0': 1015,\\n      '1': 78\\n      /* ... all chroma counts */\\n    }\\n  },\\n  {\\n    semitones: 5,\\n    symbols: ['7', '^7'],\\n    count: 3359,\\n    roots: {\\n      Ab: 154,\\n      E: 56\\n      /* ... all root counts */\\n    },\\n    chromas: {\\n      '0': 647,\\n      '1': 57\\n      /* ... all chroma counts */\\n    }\\n  }\\n  /* ... all other changes.. */\\n];\\n\")), mdx(\"p\", null, \"A chord state looks like that:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const chord = {\\n  root: 'C'\\n  symbol: '-7',\\n};\\n\")), mdx(\"h3\", {\n    \"id\": \"calculating-the-probabilities\"\n  }, \"Calculating the Probabilities\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function transitionProbabilities(chord) {\\n  /* First we can filter the changes that start with our chord symbol: */\\n\\n  const relatedChanges = changes.filter(\\n    change => change.symbols[0] === chord.symbol\\n  );\\n\\n  /* => if we had C-7 like above, we would get only the changes that start with a `-7`.\\nNow we can calculate the total number of possibilities for the next chord: */\\n\\n  const possibilities = relatedChanges.reduce(\\n    (count, change) => count + change.total\\n  );\\n\\n  /* This just adds all counts of the related changes together. */\\n\\n  /* Now we have all ingredients to calculate probabilities for each follow up chord: */\\n\\n  return relatedChanges.map(change => ({\\n    next: {\\n      root: transpose(chord.root, Interval.fromSemitones(change.semitones)),\\n      symbol: change.symbols[1]\\n    },\\n    probability: change.roots[chord.root] / possibilities\\n  }));\\n}\\n\")), mdx(\"p\", null, \"e.g. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transitionProbabilites({ root:'C', symbol:'-7' })\"), \" could output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[\\n  {\\n    next: {\\n      root: 'F',\\n      symbol: '7'\\n    },\\n    probability: 0.2 // not the actual number\\n  },\\n  {\\n    next: {\\n      root: 'F',\\n      symbol: '-7'\\n    },\\n    probability: 0.1 // not the actual number\\n  }\\n  /* etc... */\\n];\\n\")), mdx(\"h3\", {\n    \"id\": \"generate-all-possible-states\"\n  }, \"Generate all possible States\"), mdx(\"p\", null, \"We can generate all possible states like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function possibleStates(roots, symbols) {\\n  /** Fist, lets generate all possible states: */\\n  const states = possibleRoots.reduce(\\n    (allStates, root) =>\\n      allStates.concat(allSymbols.map(symbol => ({ root, symbol }))),\\n    []\\n  );\\n}\\nconst possibleRoots = ['C', 'C#', 'Db' /** etc */];\\nconst possibleSymbols = ['-7', '7', '^7' /** etc */];\\npossibleStates(possibleRoots, possibleSymbols);\\n// outputs [{ root: 'C', symbol: '-7' }, /* etc */ ]\\n\")), mdx(\"h3\", {\n    \"id\": \"generate-matrix\"\n  }, \"Generate Matrix\"), mdx(\"p\", null, \"With the above function we can now generate a matrix that contains all transition probabilities:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"function transitionMatrix(states) {\\n  return states.map(chord => transitionProbabilites(chord));\\n}\\n\")), mdx(\"p\", null, \"Which outputs a two dimensional Array with states.length\", \"*\", \"states.length cells:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"[\\n  [0.1, 0.01, 0.2 /* etc */],\\n  [0.01, 0.04, 0.12 /* etc */]\\n  /* etc */\\n];\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the first index of the array is the state we\\u2019re in\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the second index is the state we transition to\")), mdx(\"h3\", {\n    \"id\": \"lookup\"\n  }, \"Lookup\"), mdx(\"p\", null, \"To lookup the probability for a certain transition we can now do:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const roots = ['C', 'C#', 'Db' /** etc */];\\nconst symbols = ['-7', '7', '^7' /** etc */];\\nconst states = possibleStates(roots, symbols);\\nconst matrix = transitionMatrix(states);\\n\\nfunction transitionProbability(from, to, states) {\\n  return matrix[states.indexOf(from)][states.indexOf(to)];\\n}\\n// example usage:\\ntransitionProbability(\\n  { root: 'C', symbol: '-7' },\\n  { root: 'F', symbol: '7' },\\n  states\\n);\\n// outputs float e.g. 0.06\\n\")), mdx(\"h3\", {\n    \"id\": \"initial-state-probabilites\"\n  }, \"Initial State Probabilites\"), mdx(\"p\", null, \"TBD: Analyze Standards for starting chords\"), mdx(\"h2\", {\n    \"id\": \"playing-with-sequences\"\n  }, \"Playing with Sequences\"), mdx(\"h3\", {\n    \"id\": \"probability-of-an-existing-sequence\"\n  }, \"Probability of an existing Sequence\"), mdx(\"p\", null, \"With the matrix, we can calculate the commonness of a tune by just multiplying all transition probabilites together.\"), mdx(\"h3\", {\n    \"id\": \"generating-sequences\"\n  }, \"Generating Sequences\"), mdx(\"p\", null, \"Using a weighted randomizer, we can generate chord sequences that follow the markov model:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\"\n  }, \"TBD\\n\")), mdx(\"h3\", {\n    \"id\": \"rootless-probabilities\"\n  }, \"Rootless Probabilities\"), mdx(\"p\", null, \"Instead of using each possible chord as states, we could just probabilities to the changes set. This will ignore the fact that some roots are more often used than others with the same change.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const changesWithProbabilities = [\\n  {\\n    semitones: 5,\\n    symbols: ['-7', '7'],\\n    count: 7584,\\n    // probability: getProbabilty(change, changes),\\n    groupSize: getGroupSize(change, changes),\\n    roots: {\\n      C: 1015,\\n      D: 1249\\n      /* ... all root counts */\\n    },\\n    chromas: {\\n      '0': 1015,\\n      '1': 78\\n      /* ... all chroma counts */\\n    }\\n  }\\n  /* .. */\\n];\\n\\nfunction getGroupSize(change, changes) {\\n  return changes\\n    .filter(c => c.symbols[0] === change.symbols[0])\\n    .reduce((sum, c) => sum + c.count, 0);\\n}\\n\\nfunction getProbability(change, changes) {\\n  return change.count / getGroupSize(change, changes);\\n}\\n\")), mdx(\"p\", null, \"Now we can get the next possible chords like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"// changes now have probabilities precalculated like done above\\nfunction nextPossibleChords(from, to, changes) {\\n  const semitones = Interval.semitones(Distance.interval(from.root, to.root));\\n  const possibleChanges = changes.filter(c => c.semitones === semitones);\\n  return possibleChanges.map(change => ({\\n    chord: change.root + change.symbol,\\n    // probability: getProbability(change, changes),\\n    // could also be precalculated:\\n    // probability: change.count / getGroupSize(change, changes)\\n    probability: change.count / change.groupSize\\n  })); // could also be sorted by probability\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"hidden-markov-model-melodies\"\n  }, \"Hidden Markov Model Melodies\"), mdx(\"p\", null, \"We could step up the whole thing by adding melodies/notes into the mix. This could be achieved by a hidden markov model:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We do not know the changes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can just observe notes that are played\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"We can guess the changes\")), mdx(\"h3\", {\n    \"id\": \"note-choice-probabilities\"\n  }, \"Note choice probabilities\"), mdx(\"p\", null, \"For that, we would need probabilities for a pitch to appear over a certain chord symbol:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[\\n  {\\n    pitch: 'C',\\n    state: {\\n      root: 'A',\\n      symbol: '-7'\\n    },\\n    probability: 0.6\\n  },\\n  {\\n    pitch: 'C#',\\n    state: {\\n      root: 'A',\\n      symbol: '-7'\\n    },\\n    probability: 0.00000001\\n  }\\n  /** etc.. */\\n];\\n\")), mdx(\"p\", null, \"The above example shows that a C is much more likely to appear over a A-7 than a C#.\"), mdx(\"p\", null, \"We could also have different probability sets for melodies vs chord voicings.\"), mdx(\"p\", null, \"Having that, we can guess the changes, or, the other way around: generate melodies or voicings based on chord symbols!\"), mdx(\"h3\", {\n    \"id\": \"how-to-obtain-note-choice-probabilities\"\n  }, \"How to obtain note choice probabilities?\"), mdx(\"p\", null, \"We would need a set of transcriptions that include chord symbols, or at least tunes where the changes are known.\"));\n}\n;\nMDXContent.isMDXComponent = true;"},"site":{"siteMetadata":{"title":"Loophole Letters"}}},"pageContext":{"id":"3f8dfd0a-51dd-5710-bdfe-e495344c2562","parent":{"name":"markov-progressions","base":"markov-progressions.md","relativePath":"ideas/markov-progressions.md","sourceInstanceName":"content/notes"},"title":"markov-progressions"}},"staticQueryHashes":[]}