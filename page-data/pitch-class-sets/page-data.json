{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/pitch-class-sets/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"ce7d60f2-ecd4-51b0-9f20-f3c29a05b10b","excerpt":"Let's explore the world of pitch class sets. Harmonic & Chromatic Circles There are (at least) two ways we can represent 12 notes in aâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar oneOfModes = function oneOfModes(families) {\n  return function (scale) {\n    return families.map(function (f) {\n      return Scale.get(f).normalized;\n    }).includes(Scale.get(scale).normalized);\n  };\n};\n\nvar scaleModes = function scaleModes() {\n  for (var _len = arguments.length, families = new Array(_len), _key = 0; _key < _len; _key++) {\n    families[_key] = arguments[_key];\n  }\n\n  return Scale.names().filter(oneOfModes(families));\n};\n\nvar byCenter = function byCenter(a, b) {\n  return Scale.get(a).setNum - Scale.get(b).setNum;\n};\n\nvar roots = ['C', 'C#', 'Db', 'D', 'D#', 'Eb', 'E', 'F', 'F#', 'Gb', 'G', 'G#', 'Ab', 'A', 'A#', 'Bb', 'B'];\n\nvar intervalCircle = function intervalCircle(tonicAndinterval) {\n  var _tonicAndinterval$spl = tonicAndinterval.split(' '),\n      _tonicAndinterval$spl2 = _slicedToArray(_tonicAndinterval$spl, 2),\n      tonic = _tonicAndinterval$spl2[0],\n      interval = _tonicAndinterval$spl2[1];\n\n  var pitches = [tonic, Note.transpose(tonic, interval)];\n  var set = pitches.map(function (pc) {\n    return Note.get(pc).chroma;\n  });\n  return _objectSpread({\n    tonic: tonic,\n    pitches: pitches,\n    sets: [{\n      stroke: 'steelblue',\n      set: set\n    }],\n    label: tonicAndinterval\n  }, smallCircle);\n};\n\nvar smallCircle = {\n  r: 80,\n  nodeRadius: 16\n};\n\nvar scaleCircle = function scaleCircle(scaleName) {\n  var scale = Scale.get(scaleName);\n  var tonic = scaleName.split(' ')[0];\n  var set = scale.notes.concat([tonic]).map(function (pc) {\n    return Note.get(pc).chroma;\n  });\n  return _objectSpread({\n    tonic: tonic,\n    pitches: scale.notes,\n    sets: [{\n      stroke: 'steelblue',\n      set: set\n    }],\n    label: scaleName\n  }, smallCircle);\n};\n\nvar relectedCircle = function relectedCircle(scale, interval, middleAxis) {\n  var _scaleCircle = scaleCircle(scale),\n      sets = _scaleCircle.sets,\n      props = _objectWithoutProperties(_scaleCircle, [\"sets\"]);\n\n  var _intervalCircle = intervalCircle(interval),\n      _intervalCircle$sets = _slicedToArray(_intervalCircle.sets, 1),\n      intervalSet = _intervalCircle$sets[0].set;\n\n  return _objectSpread({\n    sets: sets.concat([{\n      set: intervalSet,\n      stroke: 'black',\n      offset: middleAxis ? 1 / 24 : 0\n    }])\n  }, props);\n};\n\nvar _frontmatter = {\n  \"title\": \"Pitch Class Sets\",\n  \"date\": \"2021-01-03T00:00:00.000Z\",\n  \"keywords\": [\"tuning\", \"music theory\"]\n};\nvar layoutProps = {\n  oneOfModes: oneOfModes,\n  intervalCircle: intervalCircle,\n  smallCircle: smallCircle,\n  scaleCircle: scaleCircle,\n  relectedCircle: relectedCircle,\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Let\\u2019s explore the world of pitch class sets.\"), mdx(\"h2\", {\n    \"id\": \"harmonic--chromatic-circles\"\n  }, \"Harmonic & Chromatic Circles\"), mdx(\"p\", null, \"There are (at least) two ways we can represent 12 notes in a circle:\"), mdx(State, {\n    initial: {\n      scale: 'C major',\n      relative: false\n    },\n    mdxType: \"State\"\n  }, function (_ref2) {\n    var state = _ref2.state,\n        setState = _ref2.setState;\n    var tonic = state.scale.split(' ')[0];\n    var scale = Scale.get(state.scale);\n    var set = scale.notes.concat([tonic]).map(function (pc) {\n      return Note.get(pc).chroma;\n    });\n    var pcset = PcSet.get(scale.notes);\n    var scales = scaleModes('major', 'melodic minor').sort(byCenter);\n\n    var setScale = function setScale(scale) {\n      return setState({\n        scale: simplifyScale(scale || state.scale)\n      });\n    };\n\n    return mdx(React.Fragment, null, mdx(\"center\", null, mdx(Grid, {\n      spacing: 0,\n      container: true,\n      style: {\n        width: '100%'\n      },\n      alignItems: \"center\",\n      mdxType: \"Grid\"\n    }, mdx(Grid, {\n      item: true,\n      xs: 6,\n      mdxType: \"Grid\"\n    }, mdx(\"h3\", null, \"Circle of Fifths\"), mdx(HarmonicCircle, {\n      sets: [{\n        stroke: 'steelblue',\n        set: set\n      }],\n      pitches: scale.notes,\n      tonic: scale.tonic,\n      relative: state.relative,\n      mdxType: \"HarmonicCircle\"\n    }), mdx(Button, {\n      color: \"primary\",\n      onClick: function onClick() {\n        return setScale(rotateScale(state.scale, 5, scales));\n      },\n      mdxType: \"Button\"\n    }, \"rotate scale\"), mdx(Button, {\n      color: \"primary\",\n      onClick: function onClick() {\n        return setScale(rotateMode(state.scale, 5, scales));\n      },\n      mdxType: \"Button\"\n    }, \"rotate mode\"), mdx(Button, {\n      color: \"primary\",\n      onClick: function onClick() {\n        return setScale(transposeScale(5, state.scale));\n      },\n      mdxType: \"Button\"\n    }, \"transpose\")), mdx(Grid, {\n      item: true,\n      xs: 6,\n      mdxType: \"Grid\"\n    }, mdx(\"h3\", null, \"Chromatic Circle\"), mdx(ChromaticCircle, {\n      sets: [{\n        stroke: 'steelblue',\n        set: set\n      }],\n      pitches: scale.notes,\n      tonic: scale.tonic,\n      relative: state.relative,\n      mdxType: \"ChromaticCircle\"\n    }), mdx(Button, {\n      color: \"primary\",\n      onClick: function onClick() {\n        return setScale(rotateScale(state.scale, 1, scales));\n      },\n      mdxType: \"Button\"\n    }, \"rotate scale\"), mdx(Button, {\n      color: \"primary\",\n      onClick: function onClick() {\n        return setScale(rotateMode(state.scale, 1, scales));\n      },\n      mdxType: \"Button\"\n    }, \"rotate mode\"), mdx(Button, {\n      color: \"primary\",\n      onClick: function onClick() {\n        return setScale(transposeScale(-1, state.scale));\n      },\n      mdxType: \"Button\"\n    }, \"transpose\"))), mdx(ScalePicker, {\n      scale: state.scale,\n      onChange: function onChange(scale) {\n        return setState({\n          scale: scale\n        });\n      },\n      scales: scales,\n      mdxType: \"ScalePicker\"\n    }), mdx(\"br\", null), mdx(\"label\", null, \"absolute\", mdx(Switch, {\n      checked: state.relative,\n      color: \"primary\",\n      onChange: function onChange(e) {\n        return setState({\n          relative: e.target.checked\n        });\n      },\n      mdxType: \"Switch\"\n    }), \"relative\"), mdx(\"br\", null), \" Chroma: \", pcset.chroma, \" = \", pcset.setNum, \" \"));\n  }), mdx(\"p\", null, \"The blue line connects all pitches that are part of the selected scale. Using those representations, we can build a geometric intuition for musical phenomena.\\nIn a nutshell, the circle of fifth helps to understand harmonic relationships, while the chromatic circle works better for melodic content.\"), mdx(\"h2\", {\n    \"id\": \"chromas--set-numbers\"\n  }, \"Chromas & Set Numbers\"), mdx(\"p\", null, \"In the circles above, a so called chroma is displayed for each scale. A chroma is a format to represent a set of notes.\\nFor example, the chroma of a C major scale is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"101011010101\"), \".\"), mdx(\"p\", null, \"The idea: each digit stands for 1 of 12 possible pitches, where the first digit is C, then going chromatically up.\\nA 1 means that the pitch that is represented by the digit is in the set, a 0 means it is not.\"), mdx(\"p\", null, \"A set number is just the decimal representation of a chroma:\"), mdx(State, {\n    initial: {\n      scale: 'major',\n      root: 'C'\n    },\n    mdxType: \"State\"\n  }, function (_ref3) {\n    var state = _ref3.state,\n        setState = _ref3.setState;\n    return mdx(React.Fragment, null, mdx(\"select\", {\n      value: state.root,\n      onChange: function onChange(e) {\n        return setState({\n          root: e.target.value\n        });\n      }\n    }, Note.names().map(function (note, index) {\n      return mdx(\"option\", {\n        key: index\n      }, note);\n    })), mdx(\"select\", {\n      value: state.scale,\n      onChange: function onChange(e) {\n        return setState({\n          scale: e.target.value\n        });\n      }\n    }, ['major', 'minor', 'dorian', 'mixolydian', 'harmonic minor', 'melodic minor'].map(function (scale, index) {\n      return mdx(\"option\", {\n        key: index\n      }, scale);\n    })), \" \", mdx(\"pre\", null, Range.chromatic(['C3', 'B3']).map(function (n) {\n      return Note.get(n);\n    }).map(function (_ref4) {\n      var pc = _ref4.pc,\n          alt = _ref4.alt;\n      return alt ? ' ' : pc;\n    }).join(''), ' ', \"= setNum\", mdx(\"br\", null), PcSet.get(Scale.get(state.root + ' ' + state.scale).notes).chroma, \" =\", ' ', PcSet.get(Scale.get(state.root + ' ' + state.scale).notes).setNum, mdx(\"br\", null), Array.from({\n      length: Note.chroma(state.root) + 1\n    }).join(' '), \"^\"));\n  }), mdx(\"p\", null, \"To find more about scale representations, be sure to check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://ianring.com/musictheory/scales/#representing\"\n  }, \"The Exciting Universe of Music Theory\"), \".\\nUnfortunately, the chromas and set numbers are reversed, which does not seem right to me. Read \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.youtube.com/watch?v=4MIVQqSOJU4&lc=Ugzl97yE7jsVWS9JLmd4AaABAg\"\n  }, \"these comments\"), \" to find out more.\"), mdx(\"h3\", {\n    \"id\": \"chroma-from-scale\"\n  }, \"Chroma from Scale\"), mdx(\"p\", null, \"To get the chroma for a given scale, we can do this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"PcSet.get(Scale.get('D dorian')).chroma; // 101011010101\\n\")), mdx(\"details\", null, mdx(\"summary\", null, \"Why not Scale.get().chroma ?\"), mdx(\"p\", null, \"Because it is always relative to C, ignoring the root of the scale:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const scaleProps = Scale.get('G major');\\n\\nscaleProps.chroma;\\n// '101011010101' => ingores G\\n\\nPcSet.get(scaleProps.notes).chroma;\\n// '101011010101' => relative to G => correct\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"scale-from-chroma\"\n  }, \"Scale from Chroma\"), mdx(\"p\", null, \"As the opposite of the above, we might also want the scale for a given chroma:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const chromaScale = (chroma, tonic, scaleTypes = Scale.names()) => {\\n  const type = scaleTypes.find((type) => scaleChroma(`${tonic} ${type}`) === chroma);\\n  if (type) {\\n    return `${tonic} ${type}`;\\n  }\\n  return '';\\n};\\nexpect(chromaScale('101011010101', 'C')).toBe('C major');\\nexpect(chromaScale('101011010101', 'D')).toBe('D dorian');\\nexpect(chromaScale('101011010101', 'E')).toBe('E phrygian');\\nexpect(chromaScale('101011010101', 'Eb')).toBe('');\\n\")), mdx(\"h3\", {\n    \"id\": \"chroma-from-chord\"\n  }, \"Chroma from Chord\"), mdx(\"p\", null, \"Of course, we can also represent a chord as a chroma:\"), mdx(State, {\n    initial: {\n      chord: 'M',\n      root: 'C'\n    },\n    mdxType: \"State\"\n  }, function (_ref5) {\n    var state = _ref5.state,\n        setState = _ref5.setState;\n    return mdx(React.Fragment, null, mdx(\"select\", {\n      value: state.root,\n      onChange: function onChange(e) {\n        return setState({\n          root: e.target.value\n        });\n      }\n    }, Note.names().map(function (note, index) {\n      return mdx(\"option\", {\n        key: index\n      }, note);\n    })), mdx(\"select\", {\n      value: state.chord,\n      onChange: function onChange(e) {\n        return setState({\n          chord: e.target.value\n        });\n      }\n    }, ['M', 'm', '7', '^7', 'm7'].map(function (chord, index) {\n      return mdx(\"option\", {\n        key: index\n      }, chord);\n    })), \" \", mdx(\"pre\", null, Range.chromatic(['C3', 'B3']).map(function (n) {\n      return Note.get(n);\n    }).map(function (_ref6) {\n      var pc = _ref6.pc,\n          alt = _ref6.alt;\n      return alt ? ' ' : pc;\n    }).join(''), ' ', \"= setNum\", mdx(\"br\", null), PcSet.get(Chord.get(state.root + ' ' + state.chord).notes).chroma, \" =\", ' ', PcSet.get(Chord.get(state.root + ' ' + state.chord).notes).setNum, mdx(\"br\", null), Array.from({\n      length: Note.chroma(state.root) + 1\n    }).join(' '), \"^\"));\n  }), mdx(\"h2\", {\n    \"id\": \"set-concepts\"\n  }, \"Set Concepts\"), mdx(\"p\", null, \"Let\\u2019s look at different concepts around pitch class sets.\"), mdx(\"h3\", {\n    \"id\": \"modes\"\n  }, \"Modes\"), mdx(\"p\", null, \"These are the 7 modes of C major:\"), mdx(ChromaticCircle, _extends({}, scaleCircle('C major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('D dorian'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('E phrygian'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('F lydian'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('G mixolydian'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('A aeolian'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('B locrian'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All of the above resemble the same set (same pitches)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each set can be started at any contained pitch, which gives n modes for n pitch sets.\")), mdx(\"h3\", {\n    \"id\": \"transpositions--rotations\"\n  }, \"Transpositions / Rotations\"), mdx(\"p\", null, \"Transposing a set leads to rotation. These are the 12 major scales:\"), mdx(ChromaticCircle, _extends({}, scaleCircle('C major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('Db major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('D major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('Eb major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('E major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('F major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('F# major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('G major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('Ab major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('A major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('Bb major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('B major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"p\", null, \"For some scales, there are less than 12 unique rotations, for example:\"), mdx(ChromaticCircle, _extends({}, scaleCircle('C whole tone'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('Db whole tone'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('D whole tone'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The above example shows that there are just 2 whole tone scales\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"After 2 rotations, we end up with D whole tone, which is a mode of C whole tone => same notes\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All symmetric scales will have less than 12 unique rotations\")), mdx(\"h3\", {\n    \"id\": \"complements\"\n  }, \"Complements\"), mdx(\"p\", null, \"A complement can be obtained by using the gaps of another set:\"), mdx(ChromaticCircle, _extends({}, scaleCircle('D major'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, scaleCircle('Ab pentatonic'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each set has exactly one complement\")), mdx(\"h3\", {\n    \"id\": \"reflections\"\n  }, \"Reflections\"), mdx(\"p\", null, \"The reflection of a set can be generated by flipping it around:\"), mdx(\"p\", null, \"Flipping around the 1 / b5 will drop a major third down:\"), mdx(ChromaticCircle, _extends({}, relectedCircle('C major', 'C 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, relectedCircle(scaleReflection('C major', 0, false, 'Ab'), 'C 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"p\", null, \"Flipping around the 5th / b2 gives us whole tone steps down:\"), mdx(ChromaticCircle, _extends({}, relectedCircle('C major', 'G 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, relectedCircle(scaleReflection('C major', 1, false, 'Bb'), 'G 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"p\", null, \"Flipping around at the 2nd / b13 degree returns the same set:\"), mdx(ChromaticCircle, _extends({}, relectedCircle('C major', 'D 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, relectedCircle(scaleReflection('C major', 2, false, 'C'), 'D 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"p\", null, \"Flipping around at the 6th / b3:\"), mdx(ChromaticCircle, _extends({}, relectedCircle('C major', 'Eb 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, relectedCircle(scaleReflection('C major', 3, false, 'D'), 'Eb 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"p\", null, \"Flipping around at the 3rd / b7:\"), mdx(ChromaticCircle, _extends({}, relectedCircle('C major', 'E 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, relectedCircle(scaleReflection('C major', 4, false, 'E'), 'E 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"p\", null, \"Flipping around at 4th / 7:\"), mdx(ChromaticCircle, _extends({}, relectedCircle('C major', 'F 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, relectedCircle(scaleReflection('C major', 5, false, 'Gb'), 'F 4A'), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"h3\", {\n    \"id\": \"negative-harmony-reflections\"\n  }, \"Negative Harmony Reflections\"), mdx(\"p\", null, \"If we move the axis between the notes, we can get the \\u201Cnegative harmony\\u201D:\"), mdx(ChromaticCircle, _extends({}, relectedCircle('C major', 'A 4A', true), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(ChromaticCircle, _extends({}, relectedCircle(scaleReflection('C major', 4, true, 'C'), 'A 4A', true), {\n    mdxType: \"ChromaticCircle\"\n  })), mdx(\"p\", null, \"Here, the C major scale is flipped around the axis between Eb/E and A/Bb.\"), mdx(\"h2\", {\n    \"id\": \"conclusion\"\n  }, \"Conclusion\"), mdx(\"p\", null, \"This was just a broad overview of some things that can be done with pitch class sets.\\nI will write about more concepts and some of the above in greater detail in future posts.\\nBe sure to check out the links below:\"), mdx(\"h2\", {\n    \"id\": \"links\"\n  }, \"Links\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://ianring.com/musictheory/\"\n  }, \"The Exciting Universe Of Music Theory\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://www.milesokazaki.com/wp-content/uploads/2016/02/visual-reference-smaller.pdf\"\n  }, \"Visual Reference for Musicians\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=OMDtp89Xqlw\"\n  }, \"Combinatorial Music Theory\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.youtube.com/watch?v=GAWcpmLGJoA\"\n  }, \"Basics of Set Theory\"))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/pitch-class-sets/","title":"Pitch Class Sets","tags":[],"keywords":["tuning","music theory"],"date":"January 03, 2021","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"741b6b01-5d98-5094-b22b-3a1406e358fc","excerpt":"After we found a basic way of  coloring pitches , let's now look at a way to color scales. Chroma Center This is the C major scale in aâ€¦","slug":"/coloring-scales/","title":"Coloring Musical Scales","date":"January 02, 2021"},"next":{"__typename":"MdxBlogPost","id":"49e613ce-0f88-5708-b2e0-ae72e48a5d6c","excerpt":"After the  Minimoog MIDI Controller , here comes another electronics project I did a few days ago.\nAs I had a  M Audio Keystation 88 MkIIâ€¦","slug":"/diy-midi-keyboard/","title":"DIY MIDI Keyboard Scanner","date":"February 11, 2021"}},"pageContext":{"id":"ce7d60f2-ecd4-51b0-9f20-f3c29a05b10b","previousId":"741b6b01-5d98-5094-b22b-3a1406e358fc","nextId":"49e613ce-0f88-5708-b2e0-ae72e48a5d6c"}},"staticQueryHashes":["386998304","4198970465","764694655"]}