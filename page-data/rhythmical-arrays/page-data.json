{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/rhythmical-arrays/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"3dc66d40-f4bc-5565-9061-581e1b6a44cf","excerpt":"In this post, I want to describe how and why  rhythmical  is implemented. Nested vs Flat Arrays The goal of rhythmical is to convert rhythms…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rhythmical Arrays\",\n  \"date\": \"2020-05-27T00:00:00.000Z\",\n  \"keywords\": [\"rhythmical\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Player, {\n    fold: true,\n    events: renderRhythmObject({\n      duration: 14,\n      value: [['e5', ['b4', 'c5'], 'd5', ['c5', 'b4']], ['a4', ['a4', 'c5'], 'e5', ['d5', 'c5']], ['b4', ['r', 'c5'], 'd5', 'e5'], ['c5', 'a4', 'a4', 'r'], [['r', 'd5'], ['r', 'f5'], 'a5', ['g5', 'f5']], ['e5', ['r', 'c5'], 'e5', ['d5', 'c5']], ['b4', ['b4', 'c5'], 'd5', 'e5'], ['c5', 'a4', 'a4', 'r']]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Player\\n  events={renderRhythmObject({\\n    duration: 16,\\n    value: [\\n      ['e5', ['b4', 'c5'], 'd5', ['c5', 'b4']],\\n      ['a4', ['a4', 'c5'], 'e5', ['d5', 'c5']],\\n      ['b4', ['r', 'c5'], 'd5', 'e5'],\\n      ['c5', 'a4', 'a4', 'r'],\\n      [['r', 'd5'], ['r', 'f5'], 'a5', ['g5', 'f5']],\\n      ['e5', ['r', 'c5'], 'e5', ['d5', 'c5']],\\n      ['b4', ['b4', 'c5'], 'd5', 'e5'],\\n      ['c5', 'a4', 'a4', 'r']\\n    ]\\n  })}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"In this post, I want to describe how and why \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/felixroos/rhythmical\"\n  }, \"rhythmical\"), \" is implemented.\"), mdx(\"h2\", {\n    \"id\": \"nested-vs-flat-arrays\"\n  }, \"Nested vs Flat Arrays\"), mdx(\"p\", null, \"The goal of rhythmical is to convert rhythms from nested arrays to a flat arrays.\"), mdx(\"h3\", {\n    \"id\": \"nested-array\"\n  }, \"Nested Array\"), mdx(\"p\", null, \"A simple nested array looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"['C4', ['E4', 'G4'], 'B4', 'D5'];\\n\")), mdx(\"p\", null, \"We can visualize it with a tree:\"), mdx(RhythmicalTree, {\n    rhythm: ['C4', ['E4', 'G4'], 'B4', 'D5'],\n    height: 150,\n    mdxType: \"RhythmicalTree\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Pro\"), \": Easy to read and write for humans\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Pro\"), \": Good for hierarchical visualizations\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Contra\"), \": Hard to parse for machines\")), mdx(\"h3\", {\n    \"id\": \"flat-array\"\n  }, \"Flat Array\"), mdx(\"p\", null, \"A flat representation of the nested array above could look like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[\\n  { value: 'C4', time: 0, duration: 1 },\\n  { value: 'E4', time: 1, duration: 0.5 },\\n  { value: 'G4', time: 1.5, duration: 0.5 },\\n  { value: 'B4', time: 2, duration: 1 },\\n  { value: 'D5', time: 3, duration: 1 }\\n];\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Pro\"), \": Easy to parse for machines\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Pro\"), \": Good for playback / visualization\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Contra\"), \": Hard to read and write for humans\")), mdx(\"p\", null, \"We can render this as a piano roll:\"), mdx(PianoRoll, {\n    noteRange: ['C4', 'D5'],\n    center: 0,\n    events: renderRhythmObject(['C4', ['E4', 'G4'], 'B4', 'D5']),\n    mdxType: \"PianoRoll\"\n  }), mdx(\"br\", null), mdx(\"p\", null, \"\\u2026 or as a score:\"), mdx(Score, {\n    width: 660,\n    height: 100,\n    staves: rhythmicalScore([['C4', ['E4', 'G4'], 'B4', 'D5']]),\n    mdxType: \"Score\"\n  }), mdx(\"p\", null, \"\\u2026 or play it back\"), mdx(PlayButton, {\n    events: renderRhythmObject({\n      duration: 4,\n      value: ['C4', ['E4', 'G4'], 'B4', 'D5']\n    }),\n    mdxType: \"PlayButton\"\n  }), mdx(\"p\", null, \"Now we want to find out how this transformation can be done.\"), mdx(\"h2\", {\n    \"id\": \"flattening-arrays\"\n  }, \"Flattening arrays\"), mdx(\"p\", null, \"Of course, we could just use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Array.flat\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"Array.flat(['C4', ['E4', 'G4'], 'B4', 'D5']);\\n// ['C4', 'E4', 'G4', 'B4', 'D5']\\n\")), mdx(\"p\", null, \"But with this, we loose the nesting information.\"), mdx(\"h3\", {\n    \"id\": \"keeping-track-of-indices\"\n  }, \"Keeping track of indices\"), mdx(\"p\", null, \"To keep the nesting info when flattening, we need some way of representation for the position of elements inside the tree.\\nWe could use an array of indices:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[\\n  { value: 'C4', path: [0] },\\n  { value: 'E4', path: [1, 0] },\\n  { value: 'G4', path: [1, 1] },\\n  { value: 'B4', path: [2] },\\n  { value: 'D5', path: [3] }\\n];\\n\")), mdx(\"p\", null, \"So now we keep the nesting information. This is enough information to recreate the original nested tree.\"), mdx(\"h3\", {\n    \"id\": \"keeping-track-of-array-lengths\"\n  }, \"Keeping track of array lengths\"), mdx(\"p\", null, \"While the above flat array with indices might be lossless, it is really expensive to work with it, as we do not know how many elements are on each level.\\nWe could iterate over all elements and count them, but this is rather expensive. To avoid this, we can just keep track of the array lengths:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[\\n  { value: 'C4', path: [[0, 4]] },\\n  {\\n    value: 'E4',\\n    path: [\\n      [1, 4],\\n      [0, 2]\\n    ]\\n  },\\n  {\\n    value: 'G4',\\n    path: [\\n      [1, 4],\\n      [1, 2]\\n    ]\\n  },\\n  { value: 'B4', path: [[2, 4]] },\\n  { value: 'D5', path: [[3, 4]] }\\n];\\n\")), mdx(\"h3\", {\n    \"id\": \"basic-implementation\"\n  }, \"Basic Implementation\"), mdx(\"p\", null, \"This is a simple recursive implementation:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function flatArray<T>(array: NestedArray<T>, path: Path[] = [], flat: FlatItem<T>[] = []): FlatItem<T>[] {\\n  for (let i = 0; i < array.length; i++) {\\n    if (typeof array[i] !== 'object') {\\n      flat.push({ value: array[i] as T, path: path.concat([[i, array.length]]) })\\n    } else if (Array.isArray(array[i])) {\\n      flatArray(array[i] as NestedArray<T>, path.concat([[i, array.length]]), flat)\\n    } else {\\n      throw new Error('Non-Array Objects not supported!')\\n    }\\n  }\\n  return flat;\\n}\\nexport interface NestedArray<T> extends Array<T | NestedArray<T>> { }\\nexport type Path = [number, number];\\nexport type FlatItem<T> = { value: T, path: Path[] };\\n\")), mdx(\"details\", null, mdx(\"summary\", null, \"show example tests\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"test('flatArray', () => {\\n  expect(flatArray([])).toEqual([]);\\n  expect(flatArray(['C'])).toEqual([{ value: 'C', path: [[0, 1]] }]);\\n  expect(flatArray(['C', 'D'])).toEqual([\\n    { value: 'C', path: [[0, 2]] },\\n    { value: 'D', path: [[1, 2]] }\\n  ]);\\n  expect(flatArray(['C', 'D', ['E', 'F']])).toEqual([\\n    { value: 'C', path: [[0, 3]] },\\n    { value: 'D', path: [[1, 3]] },\\n    {\\n      value: 'E',\\n      path: [\\n        [2, 3],\\n        [0, 2]\\n      ]\\n    },\\n    {\\n      value: 'F',\\n      path: [\\n        [2, 3],\\n        [1, 2]\\n      ]\\n    }\\n  ]);\\n});\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"calculating-absolute-time--duration-from-paths\"\n  }, \"Calculating absolute time + duration from paths\"), mdx(\"p\", null, \"We can calculate absolute time and duration of a path array like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export function getTimeDuration(path: [number, number][], whole = 1) {\\n  let time = 0;\\n  let subdivision = whole;\\n  for (let i = 0; i < path.length; i++) {\\n    subdivision *= 1 / path[i][1];\\n    time += path[i][0] * subdivision;\\n  }\\n  return [time, subdivision];\\n}\\n\")), mdx(\"details\", null, mdx(\"summary\", null, \"show example tests\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"test('getTimeDuration', () => {\\n  expect(getTimeDuration([[0, 2]])).toEqual([0, 0.5]);\\n  expect(getTimeDuration([[1, 2]])).toEqual([0.5, 0.5]);\\n  expect(\\n    getTimeDuration([\\n      [0, 2],\\n      [0, 2]\\n    ])\\n  ).toEqual([0, 0.25]);\\n  expect(\\n    getTimeDuration([\\n      [0, 2],\\n      [1, 2]\\n    ])\\n  ).toEqual([0.25, 0.25]);\\n  expect(\\n    getTimeDuration([\\n      [1, 2],\\n      [0, 2]\\n    ])\\n  ).toEqual([0.5, 0.5]);\\n});\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"why-not-calculate-directly\"\n  }, \"Why not calculate directly?\"), mdx(\"p\", null, \"Of course we could directly calculate the time and duration in the process of flattening, but the path representation has some advantages:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no information is lost => we could recreate the nested tree from the flat output\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we can transform nested trees by treating the paths like fractions\")), mdx(\"h3\", {\n    \"id\": \"throwing-it-together\"\n  }, \"Throwing it together\"), mdx(\"p\", null, \"We can now combine flatArray with getTimeDuration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export function flatRhythmArray<T>(array: NestedArray<T>, whole = 1) {\\n  return flatArray(array).map(({ value, path }) => {\\n    let [time, duration] = getTimeDuration(path);\\n    return { value, time, duration };\\n  });\\n}\\n\")), mdx(\"details\", null, mdx(\"summary\", null, \"show example tests\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"test('flatRhythmArray', () => {\\n  expect(flatRhythmArray(['C', 'D'])).toEqual([\\n    { value: 'C', time: 0, duration: 0.5 },\\n    { value: 'D', time: 0.5, duration: 0.5 }\\n  ]);\\n  expect(flatRhythmArray(['C', ['D', 'E']])).toEqual([\\n    { value: 'C', time: 0, duration: 0.5 },\\n    { value: 'D', time: 0.5, duration: 0.25 },\\n    { value: 'E', time: 0.75, duration: 0.25 }\\n  ]);\\n});\\n\"))), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"array-nesting--unflattening\"\n  }, \"Array nesting / unflattening\"), mdx(\"p\", null, \"By remembering the tree position with the path array, we can return to the nested state again:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"export function nestArray<T>(items: FlatItem<T>[]): NestedArray<T> {\\n  return items.reduce((nested, item) => {\\n    let [index, subdivision] = item.path[0];\\n    if (!nested.length && subdivision) {\\n      nested = Array(subdivision).fill(0); // populate array\\n    }\\n    if (item.path.length === 1) {\\n      nested[index] = item.value;\\n    } else {\\n      nested[index] = nestArray(\\n        items\\n          .filter((i) => i.path.length > 1 && i.path[0][0] === index) // remove siblings\\n          .map((i) => ({ ...i, path: i.path.slice(1) })) // remove first path\\n      );\\n    }\\n    return nested;\\n  }, []);\\n}\\n\")), mdx(\"details\", null, mdx(\"summary\", null, \"show example tests\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-ts\"\n  }, \"test('nestArray', () => {\\n  expect(nestArray([])).toEqual([]);\\n  expect(nestArray([{ value: 'C', path: [[0, 1]] }])).toEqual(['C']);\\n  expect(\\n    nestArray([\\n      { value: 'C', path: [[0, 2]] },\\n      { value: 'D', path: [[1, 2]] }\\n    ])\\n  ).toEqual(['C', 'D']);\\n\\n  expect(\\n    nestArray([\\n      { value: 'C', path: [[0, 3]] },\\n      { value: 'D', path: [[1, 3]] },\\n      {\\n        value: 'E',\\n        path: [\\n          [2, 3],\\n          [0, 2]\\n        ]\\n      },\\n      {\\n        value: 'F',\\n        path: [\\n          [2, 3],\\n          [1, 2]\\n        ]\\n      }\\n    ])\\n  ).toEqual(['C', 'D', ['E', 'F']]);\\n});\\n\"))), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"durations\"\n  }, \"Durations\"), mdx(\"p\", null, \"There is one thing we missed so far: We need a way to adjust the duration of elements.\\nFor example, without durations, we cannot represent this:\"), mdx(Score, {\n    width: 400,\n    height: 100,\n    staves: [[['C4', '2d'], ['D4', 'q']]],\n    mdxType: \"Score\"\n  }), mdx(PlayButton, {\n    events: renderRhythmObject({\n      duration: 2,\n      value: [{\n        value: 'C4',\n        duration: 3\n      }, 'D4']\n    }),\n    mdxType: \"PlayButton\"\n  }), mdx(\"p\", null, \"So we need some way to specify durations. We could use objects with duration and value:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[{ value: 'C4', duration: 3 }, 'D4'];\\n\")), mdx(\"p\", null, \"or some form of custom string syntax:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"['C4*3', 'D4'];\\n\")), mdx(\"p\", null, \"If not specified, the default value for duration is 1.\"), mdx(\"p\", null, \"With durations, calculating absolute time gets more complicated, because the time depends on the durations of the preceeding elements.\\nThe most obvious way to do this is by including the duration with the path, so we have 3 numbers:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[\\n  { value: 'C4', path: [[0, 3, 4]] },\\n  { value: 'D4', path: [[3, 1, 4]] }\\n];\\n\")), mdx(\"p\", null, \"Now, the format for the paths is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[index, duration, subdivision]\"), \". Note that the index and subdivision are now scaled to the total duration. This representation can be seen as fractions:\"), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"time_{c4} = \\\\frac{0}{4}\"), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"duration_{c4} = \\\\frac{3}{4}\"), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"time_{d4} = \\\\frac{3}{4}\"), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"duration_{d4} = \\\\frac{1}{4}\"), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"next-steps\"\n  }, \"Next Steps\"), mdx(\"p\", null, \"We will implement durations in another post, as it requires allowing non-Array objects, which i call the extended rhythmical format. It opens up even \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://felixroos.github.io/rhythmical/\"\n  }, \"more possibilities\"), \", like polyphony.\"));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/rhythmical-arrays/","title":"Rhythmical Arrays","tags":[],"keywords":["rhythmical"],"date":"May 27, 2020","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"8a099b31-c986-5be4-923e-803592f97811","excerpt":"In this post, I want to find out how I can render  rhythmical format  as staff notation. About rhythmical In short, rhythmical is a small…","slug":"/rhythmical-staff/","title":"Rhythmical Staff Notation","date":"May 24, 2020"},"next":{"__typename":"MdxBlogPost","id":"4c59f9e6-3f00-5f54-b5bf-7bd71f4936f8","excerpt":"In the last post, we implemented the  rhythmical array notation .\nToday, I want to write about why and how the more powerful rhythmical…","slug":"/rhythmical-objects/","title":"Rhythmical Objects","date":"May 29, 2020"}},"pageContext":{"id":"3dc66d40-f4bc-5565-9061-581e1b6a44cf","previousId":"8a099b31-c986-5be4-923e-803592f97811","nextId":"4c59f9e6-3f00-5f54-b5bf-7bd71f4936f8"}},"staticQueryHashes":["386998304","4198970465","764694655"]}