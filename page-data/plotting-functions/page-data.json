{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/plotting-functions/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"d6c214c4-7204-5fda-bdd8-a3efaf8971f2","excerpt":"As the basis of many upcoming visualizations, I will use libraries of  the huge d3 ecosystem .\nFor many applications, for example to animate…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Plotting Functions with React and d3.js\",\n  \"date\": \"2020-04-18T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"As the basis of many upcoming visualizations, I will use libraries of \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/d3/d3/blob/master/API.md\"\n  }), \"the huge d3 ecosystem\"), \".\\nFor many applications, for example to animate vibrating strings, it want to plot functions:\"), mdx(Plot, {\n    functions: [function (x) {\n      return Math.sin(x);\n    }, function (x) {\n      return Math.cos(x);\n    }],\n    range: {\n      x: [-Math.PI, Math.PI],\n      y: [-1, 1]\n    },\n    mdxType: \"Plot\"\n  }), mdx(\"p\", null, \"The code:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"<Plot\\n  functions={[(x) => Math.sin(x), (x) => Math.cos(x)]}\\n  range={{ x: [-Math.PI, Math.PI], y: [-1, 1] }}\\n/>\\n\")), mdx(\"h2\", {\n    \"id\": \"combining-d3-and-react\"\n  }, \"Combining d3 and react\"), mdx(\"p\", null, \"As d3 has its own API for handling the DOM, we could theoretically do the job without React.\\nBut as I want to be able to use components in MDX files directly, React needs to be at least a wrapper for d3.\"), mdx(\"h3\", {\n    \"id\": \"with-d3-selection\"\n  }, \"With d3-selection\"), mdx(\"p\", null, \"So now let\\u2019s just use React as a wrapper and let d3 handle the DOM inside the svg element, by using its jquery-like API \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/d3/d3-selection\"\n  }), \"d3-selection\"), \".\"), mdx(\"p\", null, \"By using most of the code from \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://observablehq.com/@d3/continuous-scales#visualizeScale\"\n  }), \"here\"), \" and pasting it into the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://reactjs.org/docs/refs-and-the-dom.html#callback-refs\"\n  }), \"ref callback\"), \", we can operate directly on the svg element:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import React from \\\"react\\\"\\nimport { scaleLinear } from \\\"d3-scale\\\"\\nimport { select } from \\\"d3-selection\\\"\\nimport { axisBottom, axisLeft } from \\\"d3-axis\\\"\\n\\nexport default function FunctionPlot({ f, width, margin, height, range }) {\\n  margin = margin || 40\\n  width = width || 400\\n  height = height || 300\\n  range = range || { x: [-1, 1], y: [-1, 1] }\\n  return (\\n    <svg\\n      ref={(el) => {\\n        const svg = select(el)\\n            .attr(\\\"width\\\", width + 20)\\n            .attr(\\\"height\\\", height + 20),\\n          x = scaleLinear()\\n            .domain(range.x)\\n            .range([margin, width - margin]),\\n          y = scaleLinear()\\n            .domain(range.y)\\n            .range([height - margin, margin]),\\n          g = svg.append(\\\"g\\\"),\\n          line = []\\n        for (let i = margin + 1e-6; i < width - margin; i += 1) {\\n          const X = x.invert(i),\\n            Y = f(X),\\n            j = y(Y)\\n          line.push([i, j])\\n        }\\n        g.append(\\\"path\\\")\\n          .attr(\\\"d\\\", \\\"M\\\" + line.join(\\\"L\\\"))\\n          .style(\\\"stroke\\\", \\\"steelblue\\\")\\n          .style(\\\"fill\\\", \\\"none\\\")\\n        g.append(\\\"g\\\")\\n          .attr(\\\"transform\\\", `translate(${margin},0)`)\\n          .call(axisLeft(y))\\n        g.append(\\\"g\\\")\\n          .attr(\\\"transform\\\", `translate(0,${y(0)})`)\\n          .call(axisBottom(x))\\n      }}\\n    ></svg>\\n  )\\n}\\n\")), mdx(\"p\", null, \"and using it:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"<FunctionPlot f={(x) => Math.sin(x)} range={{ x: [-4, 4], y: [-1, 1] }} />\\n\")), mdx(FunctionPlotA, {\n    f: function f(x) {\n      return Math.sin(x);\n    },\n    range: {\n      x: [-4, 4],\n      y: [-1, 1]\n    },\n    mdxType: \"FunctionPlotA\"\n  }), mdx(\"p\", null, \"Other d3 APIs used:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://observablehq.com/@d3/introduction-to-d3s-scales?collection=@d3/d3-scale\"\n  }), \"d3-scale\"), \" for a convenient translation of the function value range to the pixels dimensions on screen\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/d3/d3-axis\"\n  }), \"d3-axis\"), \" for easy-to-use x and y axis\")), mdx(\"h3\", {\n    \"id\": \"with-jsx\"\n  }, \"With JSX\"), mdx(\"p\", null, \"As React is already a pretty good lib to handle the DOM efficiently, we can (mostly) spare d3-selection and render the SVG elements in JSX:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"export function FunctionPlot({ f, width, margin, height, range }) {\\n  margin = margin || 40\\n  width = width || 400\\n  height = height || 300\\n  range = range || { x: [-1, 1], y: [-1, 1] }\\n  const line = [],\\n    x = scaleLinear()\\n      .domain(range.x)\\n      .range([margin, width - margin]),\\n    y = scaleLinear()\\n      .domain(range.y)\\n      .range([height - margin, margin])\\n  for (let i = margin + 1e-6; i < width - margin; i += 1) {\\n    const X = x.invert(i),\\n      Y = f(X),\\n      j = y(Y)\\n    line.push([i, j])\\n  }\\n  return (\\n    <svg width={width + 20} height={height + 20}>\\n      <g>\\n        <path d={`M${line.join(\\\"L\\\")}`} stroke=\\\"steelblue\\\" fill=\\\"none\\\" />\\n        <g\\n          transform={`translate(${margin},0)`}\\n          ref={(g) => select(g).call(axisLeft(y))}\\n        />\\n        <g\\n          transform={`translate(0,${y(0)})`}\\n          ref={(g) => select(g).call(axisBottom(x))}\\n        />\\n      </g>\\n    </svg>\\n  )\\n}\\n\")), mdx(\"p\", null, \"Now the .select / .append calls have been refactored to JSX. I like this code much more as it looks flatter and lets me manipulate the svg elements directly as JSX without using a wide API surface of chaining methods.\"), mdx(\"p\", null, \"The output is exactly the same:\"), mdx(FunctionPlotB, {\n    f: function f(x) {\n      return Math.sin(x);\n    },\n    range: {\n      x: [-4, 4],\n      y: [-1, 1]\n    },\n    mdxType: \"FunctionPlotB\"\n  }), mdx(\"p\", null, \"You may have noticed that the axes are still rendered using ref callback + d3-selection.\\nThis is because the axes methods are generators that output a subtree of DOM nodes.\\nIf we wanted to avoid using d3-selection completely, we could implement our own axis component using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://observablehq.com/@d3/scale-ticks\"\n  }), \"scale.ticks\"), \".\"), mdx(\"p\", null, \"But for my use case, the above approach is perfectly fine.\"), mdx(\"p\", null, \"I am really excited by d3 and the way it is organized in small modules, letting me pick only the parts I need! It will be a big part of upcoming visualizations on this blog.\"), mdx(\"h2\", {\n    \"id\": \"more-d3-resources\"\n  }, \"More d3 Resources\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://observablehq.com/collection/@d3/learn-d3\"\n  }), \"https://observablehq.com/collection/@d3/learn-d3\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://medium.com/@enjalot/how-do-you-learn-d3-js-ccffc151419b\"\n  }), \"https://medium.com/@enjalot/how-do-you-learn-d3-js-ccffc151419b\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://medium.com/@enjalot/the-hitchhikers-guide-to-d3-js-a8552174733a\"\n  }), \"https://medium.com/@enjalot/the-hitchhikers-guide-to-d3-js-a8552174733a\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://bost.ocks.org/mike/\"\n  }), \"https://bost.ocks.org/mike/\"))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/plotting-functions/","title":"Plotting Functions with React and d3.js","tags":[],"keywords":[],"date":"April 18, 2020"},"previous":{"__typename":"MdxBlogPost","id":"26f772d2-9d92-57d7-953c-c6aa8bb6e664","excerpt":"Let's play with colors. Vizualization loves color. To map musical notes to color, we can do various things. rainbow with hsl One simple…","slug":"/coloring-pitches/","title":"Coloring Pitches","date":"April 01, 2020"},"next":{"__typename":"MdxBlogPost","id":"5b4e9753-a8e6-5932-a877-bf3fb1bb1930","excerpt":"Let's make a react component that can be used to animate anything directly inside MDX files: The above Animation uses a component called…","slug":"/animation/","title":"Animating React Components","date":"April 19, 2020"}},"pageContext":{"id":"d6c214c4-7204-5fda-bdd8-a3efaf8971f2","previousId":"26f772d2-9d92-57d7-953c-c6aa8bb6e664","nextId":"5b4e9753-a8e6-5932-a877-bf3fb1bb1930"}}}