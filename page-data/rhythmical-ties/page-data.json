{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/rhythmical-ties/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"9e8bfe92-aaaa-5c24-8aba-a0e97de3211d","excerpt":"In modern music, ties across barlines are a common way of adding interest to a melody. For example, take the beginning of the tune \"Blue…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rhythmical Ties\",\n  \"date\": \"2020-07-10T00:00:00.000Z\",\n  \"keywords\": [\"rhythmical\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In modern music, ties across barlines are a common way of adding interest to a melody. For example, take the beginning of the tune \\u201CBlue Monk\\u201D by Thelonious Monk:\"), mdx(Score, {\n    width: 600,\n    height: 100,\n    staves: [[{\n      key: 'd4',\n      duration: 8\n    }, {\n      key: 'eb4',\n      duration: 8\n    }, {\n      key: 'e4',\n      duration: 8\n    }, {\n      key: 'f4',\n      duration: 8\n    }, {\n      key: 'f4',\n      duration: '2',\n      tie: true\n    } //TBD: implement this for rhythmicalScore\n    ]],\n    mdxType: \"Score\"\n  }), mdx(\"p\", null, \"In this post, I want to implement that for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"../rhythmical-arrays/\"\n  }, \"rhythmical\"), \". Syntax proposal:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"[['d4', 'eb4', 'e4', 'f4'], '_'];\\n\")), mdx(\"p\", null, \"The \\u201D\", \"_\", \"\\u201D sign will tie the note to the previous.\"), mdx(\"h2\", {\n    \"id\": \"render-implementation\"\n  }, \"Render Implementation\"), mdx(\"p\", null, \"If we render the above events:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"renderRhythmObject({\\n  duration: 8,\\n  sequential: [['d4', 'eb4', 'e4', 'f4'], '_'],\\n});\\n\")), mdx(\"p\", null, \"\\u2026 the result (without path) looks like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  {\\n    \\\"value\\\": \\\"d4\\\",\\n    \\\"time\\\": 0,\\n    \\\"duration\\\": 1\\n  },\\n  {\\n    \\\"value\\\": \\\"eb4\\\",\\n    \\\"time\\\": 1,\\n    \\\"duration\\\": 1\\n  },\\n  {\\n    \\\"value\\\": \\\"e4\\\",\\n    \\\"time\\\": 2,\\n    \\\"duration\\\": 1\\n  },\\n  {\\n    \\\"value\\\": \\\"f4\\\",\\n    \\\"time\\\": 3,\\n    \\\"duration\\\": 1\\n  },\\n  {\\n    \\\"value\\\": \\\"_\\\",\\n    \\\"time\\\": 4,\\n    \\\"duration\\\": 4\\n  }\\n]\\n\")), mdx(\"p\", null, \"The last event would not be suitable for playback, as \\u201D\", \"_\", \"\\u201D is not a valid note name.\"), mdx(\"p\", null, \"To fix that, we can apply a tie by adding its duration to the preceeding event:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"const tieReducer = (filter) => (events, event, index, array) => {\\n  if (filter) {\\n    array = array.filter(filter);\\n  }\\n  // check if next event is a tie\\n  if (index + 1 < array.length && array[index + 1].value === '_') {\\n    return events.concat([{ ...event, duration: event.duration + array[index + 1].duration }]); // adds duration of next event to current\\n  }\\n  if (event.value === '_') {\\n    return events; // ignore tie\\n  }\\n  return events.concat([event]); // next event is no tie\\n};\\n// to apply the reducer, we use it with reduce on the rendered events:\\nrenderRhythmObject({\\n  duration: 8,\\n  sequential: [['d4', 'eb4', 'e4', 'f4'], '_'],\\n}).reduce(tieReducer(), []);\\n\")), mdx(\"p\", null, \"Result (again without path):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"[\\n  {\\n    \\\"value\\\": \\\"d4\\\",\\n    \\\"time\\\": 0,\\n    \\\"duration\\\": 1\\n  },\\n  {\\n    \\\"value\\\": \\\"eb4\\\",\\n    \\\"time\\\": 1,\\n    \\\"duration\\\": 1\\n  },\\n  {\\n    \\\"value\\\": \\\"e4\\\",\\n    \\\"time\\\": 2,\\n    \\\"duration\\\": 1\\n  },\\n  {\\n    \\\"value\\\": \\\"f4\\\",\\n    \\\"time\\\": 3,\\n    \\\"duration\\\": 5\\n  }\\n]\\n\")), mdx(\"p\", null, \"Now the last event has a duration of 5, which is 1 (duration of \\u201Cf4\\u201D) + 4 (duration of \\u201D\", \"_\", \"\\u201D)!\\nThese events are now suitable for playback:\"), mdx(Player, {\n    fold: true,\n    events: renderRhythmObject({\n      duration: 2,\n      sequential: [['d4', 'eb4', 'e4', 'f4'], '_']\n    }).reduce(tieReducer(), []),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"Forgive me that this example doesn\\u2019t swing like it should.. you have to wait for that feature to be implemented\\u2026\"), mdx(\"h2\", {\n    \"id\": \"score-implementation\"\n  }, \"Score implementation\"), mdx(\"p\", null, \"In a score, we have to keep the events seperated, but add the tie flag:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function rhythmicalScore(rhythm: NestedRhythm<string>) {\\n  return Rhythm.render(rhythm, rhythm.length)\\n    .map((e) => [e.value, Math.floor(e.time), 1 / e.duration])\\n    .reduce((groups: any[][], [note, bar, duration]) => {\\n      // added this part\\n      let tie = false;\\n      if (note === '_') {\\n        let lastNote;\\n        if (groups.length && groups[groups.length - 1].length) {\\n          const lastGroup = groups[groups.length - 1];\\n          lastNote = lastGroup[lastGroup.length - 1];\\n        }\\n        note = lastNote ? lastNote.key : 'r';\\n        tie = lastNote ? true : false;\\n      }\\n      // end of tie logic\\n      if (!groups.length || bar > groups.length - 1) {\\n        groups.push([]);\\n      }\\n      if (duration === 4) {\\n        duration = 'q';\\n      }\\n      if (note === 'r') {\\n        duration = duration + 'r';\\n        note = 'b4';\\n      }\\n      groups[groups.length - 1].push({ key: note, duration, tie }); // changed to object syntax\\n      return groups;\\n    }, []);\\n}\\n\")), mdx(\"p\", null, \"Now the tie symbol works in the score:\"), mdx(Score, {\n    width: 600,\n    height: 100,\n    staves: rhythmicalScore([[['d4', 'eb4', 'e4', 'f4'], '_']]),\n    mdxType: \"Score\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<Score width={600} height={100} staves={rhythmicalScore([[['d4', 'eb4', 'e4', 'f4'], '_']])} />\\n\")), mdx(\"h2\", {\n    \"id\": \"sandman\"\n  }, \"sandman\"), mdx(\"p\", null, \"Now here\\u2019s a more sophisticated (non swung) example:\"), mdx(Player, {\n    fold: true,\n    instruments: {\n      MK2md2: MK2md2\n    },\n    events: renderRhythmObject({\n      duration: 48,\n      parallel: [[['c5', [{\n        value: '_',\n        duration: 3\n      }, 'c5']], ['d5', ['_', 'g4']], ['c5', [{\n        value: '_',\n        duration: 3\n      }, 'c5']], ['d5', ['_', 'r']], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r'], ['r', 'r']], [[['r', {\n        value: 'e5',\n        duration: 3\n      }], ['_', [{\n        value: 'e5',\n        duration: 3\n      }, 'r']]], [['r', {\n        value: 'f5',\n        duration: 3\n      }], ['_', 'r']], [['r', {\n        value: 'e5',\n        duration: 3\n      }], ['_', [{\n        value: 'e5',\n        duration: 3\n      }, 'r']]], [['r', {\n        value: 'f5',\n        duration: 3\n      }], ['_', 'r']], 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r'], [[['r', 'g5'], [['_', 'g5'], [{\n        value: '_',\n        duration: 3\n      }, 'r']]], [['r', 'a5'], 'r'], [['r', 'g5'], [['_', 'g5'], [{\n        value: '_',\n        duration: 3\n      }, 'r']]], [['r', 'a5'], 'r'], 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r', 'r'], {\n        sequential: [[['r', 'r', 'r', 'b5'], ['a5', 'r', 'r', 'r']], [['r', 'r', 'r', 'c6'], ['b5', 'r']], [['r', 'r', 'r', 'b5'], ['a5', 'r', 'r', 'r']], [['r', 'r', 'r', 'c6'], ['b5', ['g5', 'a5']]], [['b5', {\n          value: 'a5',\n          duration: 3\n        }], ['_']], [['b5', 'b5', 'f#5', 'b5'], ['_']], [['r', 'c6', 'c6', 'b5'], ['c6', {\n          value: 'c6',\n          duration: 2\n        }, 'b5']], [['f5', 'f5', 'e5', 'f5'], ['_']], [['r', 'b5', 'b5', 'a5'], ['b5', {\n          value: 'r',\n          duration: 2\n        }, 'a5']], [['e5', 'e5', 'd5', 'e5'], ['_', {\n          value: 'g5',\n          duration: 3\n        }]], [['r', 'd6', 'd6', 'c6'], ['d6', 'c6', 'd6', 'c6']], [['eb6', 'eb6'], ['e6', {\n          value: 'd6',\n          duration: 3\n        }]], // repeat\n        [['b5', {\n          value: 'a5',\n          duration: 3\n        }], ['_']], [['b5', 'b5', 'a5', 'b5'], ['_']], [['r', 'c6', 'c6', 'b5'], ['c6', {\n          value: 'c6',\n          duration: 2\n        }, 'b5']], [['f5', ['e5', 'f5']], ['_']], [['d5', ['f5', 'a5']], ['_', 'd6', 'd6', 'c6']], [['d6'], ['r', ['c6', 'd6']]], [['e6', 'e6'], ['e6', 'c6', 'e6', 'c6']], [['_'], ['r', 'g4', 'a4', 'b4']]]\n      }]\n    }).reduce(tieReducer(), []).map(function (event) {\n      return _objectSpread(_objectSpread({}, event), {}, {\n        value: event.value !== 'r' ? Note.transpose(event.value, Interval.fromSemitones(-15)) : 'r'\n      });\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"Caution: Only press play if you\\u2019re on WIFI as it uses ~46MB of samples\"), mdx(\"h2\", {\n    \"id\": \"next-steps\"\n  }, \"Next Steps\"), mdx(\"p\", null, \"In a future post, I want to implement more \\u201Cpost processing\\u201D features, which will operate on the rendered events, like:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"swing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"dynamics from pitch\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"auto tie (do not attack repeated notes again)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"test tie feature in a polyphonic setting (could need extra fixes)\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/rhythmical-ties/","title":"Rhythmical Ties","tags":[],"keywords":["rhythmical"],"date":"July 10, 2020","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"cbdf3ab2-bea0-56d9-8ea8-28dcdc5ca6a0","excerpt":"Caution: Playing the examples will load ~60MB of samples. Make sure you are on Wifi! To get away from cheap synth sounds, let's implement…","slug":"/sampler-instruments/","title":"Using Sampled Instruments with Tone.js","date":"July 08, 2020"},"next":{"__typename":"MdxBlogPost","id":"2b49a6a1-d665-5745-b2b9-71579ed46c30","excerpt":"To bring rhythmical one step closer to being a hackable backing track player, I want to implement one of the most important things: chord…","slug":"/rhythmical-chords/","title":"Rhythmical Chords","date":"July 30, 2020"}},"pageContext":{"id":"9e8bfe92-aaaa-5c24-8aba-a0e97de3211d","previousId":"cbdf3ab2-bea0-56d9-8ea8-28dcdc5ca6a0","nextId":"2b49a6a1-d665-5745-b2b9-71579ed46c30"}},"staticQueryHashes":["386998304","4198970465","764694655"]}