{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/voicing-permutation/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"e4b24033-4328-5d37-86d0-53a94a1f1495","excerpt":"In the  rhythmical chords post \nI talked about two possible methods to generate chord voicings and implemented the first of them: voicingâ€¦","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Voicing Permutation\",\n  \"date\": \"2020-08-11T00:00:00.000Z\",\n  \"image\": \"./img/voicing-permutation.png\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"In the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://felixroos.github.io/blog/rhythmical-chords/\"\n  }, \"rhythmical chords post\"), \"\\nI talked about two possible methods to generate chord voicings and implemented the first of them: voicing dictionaries.\\nIn this this post, I will tackle the second, much more difficult method: voicing permutation.\"), mdx(\"h2\", {\n    \"id\": \"permutation-basics\"\n  }, \"Permutation Basics\"), mdx(\"p\", null, \"Permutation means generating all possible combinations of elements within certain rules.\\nIf you want a better understanding of the source code below the examples, read \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://felixroos.github.io/blog/combinatorial-search/\"\n  }, \"my post about combinatorial search\"), \".\\nBefore we get to voicings, let\\u2019s talk about some basic models:\"), mdx(\"h3\", {\n    \"id\": \"the-combination-lock-\"\n  }, \"The Combination Lock \\uD83D\\uDD13\"), mdx(\"p\", null, \"The permutations of a 3 digit combination lock can be visualized with this \\u201Cdecision tree\\u201D:\"), mdx(\"div\", {\n    style: {\n      height: 400,\n      overflow: 'auto'\n    }\n  }, mdx(PermutationTree, {\n    height: 11000,\n    children: permutate({\n      find: function find(path, solutions) {\n        if (path.length < 3) {\n          return Array.from({\n            length: 10\n          }, function (_, i) {\n            return i;\n          });\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 3;\n      }\n    }),\n    mdxType: \"PermutationTree\"\n  })), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"p\", null, \"This function creates the permutation tree:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function permutate(options, path = [], solutions = []) {\\n  let { find, validate, map } = options;\\n  map = map || ((e) => e);\\n  const candidates = find(path, solutions); // find candidates\\n  const isValid = validate(path, solutions); // validate current path\\n  if (isValid) {\\n    solutions.push(path); // add solution\\n  }\\n  return map({\\n    name: path[path.length - 1] ?? '',\\n    path,\\n    isValid,\\n    children: candidates.map(\\n      (e) => permutate(options, path.concat([e]), solutions) // recur\\n    )\\n  });\\n}\\n\")), mdx(\"p\", null, \"Usage:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<PermutationTree\\n  height={11000}\\n  children={permutate({\\n    find: (path, solutions) => {\\n      if (path.length < 3) {\\n        return Array.from({ length: 10 }, (_, i) => i);\\n      }\\n      return [];\\n    },\\n    validate: (path) => path.length === 3\\n  })}\\n/>\\n\")), mdx(\"p\", null, \"PermutationTree:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import React from 'react';\\nimport { select } from 'd3-selection';\\nimport { cluster, hierarchy } from 'd3-hierarchy';\\n\\nexport default function PermutationTree(props) {\\n  let { width = 600, height = 200, children, onClick } = props;\\n  const root: any = tree(children, width);\\n  return (\\n    <svg\\n      viewBox={`-10 ${-height / 2} ${width} ${height}`}\\n      ref={(el) => {\\n        const svg = select(el);\\n        // lines\\n        svg\\n          .append('g')\\n          .attr('fill', 'none')\\n          .attr('stroke', '#555')\\n          .attr('stroke-opacity', 0.4)\\n          .attr('stroke-width', 1.5)\\n          .selectAll('path')\\n          .data(root.links())\\n          .join('path')\\n          .attr(\\n            'd',\\n            (d: any) => `\\n        M${d.target.y},${d.target.x}\\n        C${d.source.y + root.dy / 2},${d.target.x}\\n         ${d.source.y + root.dy / 2},${d.source.x}\\n         ${d.source.y},${d.source.x}`\\n          );\\n        // circles\\n        svg\\n          .append('g')\\n          .selectAll('circle')\\n          .data(root.descendants())\\n          .join('circle')\\n          .attr('cx', (d: any) => d.y)\\n          .attr('cy', (d: any) => d.x)\\n          .attr('r', 3)\\n          .attr('fill', (d: any) => {\\n            return d.data.color || (d.children ? '#555' : '#999');\\n          });\\n        // labels\\n        svg\\n          .append('g')\\n          .attr('font-family', 'sans-serif')\\n          .attr('font-size', 10)\\n          .attr('stroke-linejoin', 'round')\\n          .attr('stroke-width', 3)\\n          .attr('cursor', 'pointer')\\n          .selectAll('text')\\n          .data(root.descendants())\\n          .join('text')\\n          .on('click', (e, d) => {\\n            onClick && onClick(d);\\n          })\\n          .attr('x', (d: any) => d.y)\\n          .attr('y', (d: any) => d.x)\\n          .attr('dy', '0.31em')\\n          .attr('dx', (d: any) => (d.children ? -6 : 6))\\n          .text((d: any) =>\\n            d.children\\n              ? d.data.name\\n              : d.data.name + ' \\u27A1 ' + d.data.path.join(' ')\\n          )\\n          .filter((d: any) => d.children)\\n          .attr('text-anchor', 'end')\\n          .clone(true)\\n          .lower()\\n          .attr('stroke', 'white');\\n        // svg.attr('viewBox', autoBox as any);\\n      }}\\n    />\\n  );\\n}\\n\\nexport function tree(nodes, width = 600) {\\n  const root: any = hierarchy(nodes);\\n  root.dx = 10;\\n  root.dy = width / (root.height + 1);\\n  return cluster().nodeSize([root.dx, root.dy])(root);\\n}\\n\")), mdx(\"p\", null, \"This tree will be used throughout the post to vizualize permutation hierarchies.\")), mdx(\"p\", null, \"For each of the 3 digits, we have 10 possible numbers to pick, so we get a total of 1000 = 10\", mdx(\"sup\", null, \"3\"), \" different combinations.\\nThe model has the following rules:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"strict order (e.g. 123 !== 321)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"non unique picks (e.g. 121 is valid)\")), mdx(\"h3\", {\n    \"id\": \"seat-orderings---\"\n  }, \"Seat Orderings \\uD83D\\uDC69 \\uD83D\\uDC73 \\uD83D\\uDC76\"), mdx(\"p\", null, \"Let\\u2019s say we have 3 people: \\uD83D\\uDC69 \\uD83D\\uDC73 \\uD83D\\uDC76. If we want to make a nice family photo and let them sit on 3 chairs, we have the following possibilities:\"), mdx(PermutationTree, {\n    height: 200,\n    children: permutate({\n      find: function find(path, solutions) {\n        if (path.length < 3) {\n          return ['ðŸ‘©', 'ðŸ‘³', 'ðŸ‘¶'].filter(function (e) {\n            return !path.includes(e);\n          });\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 3;\n      }\n    }),\n    mdxType: \"PermutationTree\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<PermutationTree\\n  height={200}\\n  children={permutate({\\n    find: (path, solutions) => {\\n      if (path.length < 3) {\\n        return ['\\uD83D\\uDC69', '\\uD83D\\uDC73', '\\uD83D\\uDC76'].filter((e) => !path.includes(e));\\n      }\\n      return [];\\n    },\\n    validate: (path) => path.length === 3\\n  })}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"As opposed to the numbers in the combination lock, people cannot be duplicated. So we get a total of 3! = 3\", \"*\", \"2\", \"*\", \"1 = 6 different combinations.\\nThe rules are:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"strict order\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"unique picks\")), mdx(\"h3\", {\n    \"id\": \"lottery-urn-\"\n  }, \"Lottery Urn \\u26B1\"), mdx(\"p\", null, \"In a lottery Urn (at least the ones I know), 6 balls are pulled out of a pool of 49 unique numbered balls. The Rules:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no strict order\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"unique picks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"picking only a subset\")), mdx(\"p\", null, \"According to math people, the number of combinations can be calculated with:\"), mdx(BlockMath, {\n    mdxType: \"BlockMath\"\n  }, \"\\\\frac{n!}{r! * (n - r)!} = \\\\frac{49!}{6! * (49 - 6)!} = 13983816\"), mdx(\"p\", null, \"So to get all numbers correct, you have roughly a chance of 1:14 million.\\nFor that reason I will not show a graph here, but we will see a simpler graph the same type soon.\"), mdx(\"p\", null, \"Now that we know of the basic methods of permutation, where do voicings belong?\\nLet\\u2019s try out different models..\"), mdx(\"h2\", {\n    \"id\": \"permutating-pitches\"\n  }, \"Permutating Pitches\"), mdx(\"p\", null, \"If we permutate without octaves, we can basically use all possible chord notes and arrange them in different orders.\\nThe equivalent above would be the seat orderings \\uD83D\\uDC69 \\uD83D\\uDC73 \\uD83D\\uDC76, but with unique pitches instead of persons.\"), mdx(\"p\", null, \"For example, let\\u2019s permutate the notes of a C major chord:\"), mdx(VoicingPermutator, {\n    options: {\n      find: function find(path, solutions) {\n        if (path.length < 3) {\n          return ['C', 'E', 'G'].filter(function (e) {\n            return !path.includes(e);\n          });\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 3;\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length < 3) {\\n        return ['C', 'E', 'G'].filter((e) => !path.includes(e));\\n      }\\n      return [];\\n    },\\n    validate: (path) => path.length === 3\\n  }}\\n/>\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function VoicingPermutator({ range, options }) {\\n  const piano = useMemo(() => tinypiano.load(), []);\\n  const playNode = (hasOctaves = false) => ({ data: { path, isLeaf } }) => {\\n    const notes = hasOctaves ? path : renderUp(path, 3);\\n    notes.forEach((note) => piano.triggerAttackRelease(note, 4));\\n  };\\n  const tree = permutate(options);\\n\\n  return (\\n    <>\\n      <PermutationTree height={200} onClick={playNode(false)} children={tree} />\\n      <Player\\n        instruments={{ tinypiano }}\\n        fold={false}\\n        events={renderRhythm(\\n          {\\n            duration: 8,\\n            sequential: flatTree(tree)\\n              .reduce(arrangePermutations(range), [])\\n              .sort(sortByMeanMidi)\\n          },\\n          [inherit('color')]\\n        )}\\n      />\\n    </>\\n  );\\n}\\n\")), mdx(\"p\", null, \"Render notes:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function renderUp(pitches, bottomOctave) {\\n  const res = [];\\n  let octave = bottomOctave;\\n  pitches.forEach((pitch, index) => {\\n    if (index && Note.chroma(pitches[index - 1]) >= Note.chroma(pitch)) {\\n      octave += 1;\\n    }\\n    res.push(pitch + octave);\\n  });\\n  return res;\\n}\\n\\nfunction flatTree(tree) {\\n  return flatObject(tree, {\\n    isDeep: ({ children }) => children?.length,\\n    getChildren: ({ children }) => children\\n  } as any)\\n    .filter(({ isValid }) => isValid)\\n    .map(({ path }) => path);\\n}\\n// takes 2D pitch array and arranges all possible transpositions\\nexport const arrangePermutations = (range = ['C3', 'C5']) => (voicings, combination) => {\\n  return voicings.concat(\\n    setsInRange(combination, range).map((notes) => ({\\n      parallel: notes,\\n    }))\\n  );\\n}\\n\\nexport function setsInRange(pitches, range = ['D3', 'A4']) {\\n  const notesInRange = Range.chromatic(range) // gives array of notes inside range\\n  // get all possible start notes for voicing\\n  const starts = notesInRange\\n    // only get the start notes:\\n    .filter(note => Note.chroma(note) === Note.chroma(pitches[0]))\\n    // replace Range.chromatic notes with the correct enharmonic equivalents\\n    .map(note => enharmonicEquivalent(note, pitches[0]))\\n  // render one voicing for each start note\\n  return starts.map(start => renderUp(pitches, Note.octave(start)))\\n    // filter out voicings that contain notes that overshoot\\n    .filter(notes => !notes.find(note => Note.midi(note) > Note.midi(range[1])));\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://felixroos.github.io/blog/rhythmical-chords/#enharmonic-considerations\"\n  }, \"enharmonicEquivalent\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://felixroos.github.io/blog/rhythmical-reducers/#back-to-the-basics\"\n  }, \"flatObject\")))), mdx(\"br\", null), mdx(\"p\", null, \"I now rendered the combinations inside a specific range + sorted them by mean height.\"), mdx(\"p\", null, \"Some of those combinations are pretty wide.. We will look at ways to filter those\\nout later.\"), mdx(\"h3\", {\n    \"id\": \"allowing-doubled-notes\"\n  }, \"Allowing Doubled Notes\"), mdx(\"p\", null, \"When voicing a chord, we might want to double a note. This would be equivalent to a 3 digits combination lock where each digit can have 3 possible values \\uD83D\\uDD13:\"), mdx(VoicingPermutator, {\n    hidePlayer: true,\n    height: 400,\n    options: {\n      find: function find(path, solutions) {\n        if (path.length < 3) {\n          return ['C', 'E', 'G'];\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 3;\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  hidePlayer={true}\\n  height={400}\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length < 3) {\\n        return ['C', 'E', 'G'];\\n      }\\n      return [];\\n    },\\n    validate: (path) => path.length === 3\\n  }}\\n/>\\n\"))), mdx(\"p\", null, \"Now now we have a total of 3\", mdx(\"sup\", null, \"3\"), \" = 27 different combinations, where many of them are unpractical.\\nWe might filter out..\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"those who do not contain the third (E), as it is the most essential note\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"those who repeat the same note directly\")), mdx(VoicingPermutator, {\n    options: {\n      find: function find(path, solutions) {\n        if (path.length < 3) {\n          return ['C', 'E', 'G'].filter(function (e) {\n            return !path.length || path[path.length - 1] !== e;\n          });\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 3 && path.includes('E');\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length < 3) {\\n        return ['C', 'E', 'G'].filter(\\n          (e) => !path.length || path[path.length - 1] !== e\\n        );\\n      }\\n      return [];\\n    },\\n    validate: (path) => path.length === 3 && path.includes('E')\\n  }}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"Note that some dots are red, which indicates an invalid leaf.\\nIn this case these are combinations without the pitch E.\"), mdx(\"h3\", {\n    \"id\": \"allowing-less-notes\"\n  }, \"Allowing Less Notes\"), mdx(\"p\", null, \"Additionally, we might also pick less notes, for example voicing C major with two notes:\"), mdx(VoicingPermutator, {\n    options: {\n      find: function find(path, solutions) {\n        if (path.length < 2) {\n          return ['C', 'E', 'G'].filter(function (e) {\n            return !path.length || path[path.length - 1] !== e;\n          });\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 2 && path.includes('E');\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"no doubling\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"E is required\")), mdx(\"p\", null, \"This is now like a lottery urn \\u26B1 where we pull 2 out of 3, but with strict order.\"), mdx(\"h3\", {\n    \"id\": \"allowing-more-notes\"\n  }, \"Allowing More Notes\"), mdx(\"p\", null, \"Of course, we can also voice a C major chord with four notes (if we are allowed to double).\\nHere are just some examples that would come out:\"), mdx(VoicingPermutator, {\n    height: 1100,\n    scrollHeight: 400,\n    hidePlayer: true,\n    options: {\n      find: function find(path, solutions) {\n        if (path.length < 4) {\n          return ['C', 'E', 'G'];\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 4;\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"p\", null, \"If we forbid doubles and require E:\"), mdx(VoicingPermutator, {\n    height: 380,\n    hidePlayer: false,\n    options: {\n      find: function find(path, solutions) {\n        if (path.length < 4) {\n          return ['C', 'E', 'G'].filter(function (e) {\n            return !path.length || path[path.length - 1] !== e;\n          });\n        }\n\n        return [];\n      },\n      validate: function validate(path) {\n        return path.length === 4 && path.includes('E');\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  height={380}\\n  hidePlayer={false}\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length < 4) {\\n        return ['C', 'E', 'G'].filter(\\n          (e) => !path.length || path[path.length - 1] !== e\\n        );\\n      }\\n      return [];\\n    },\\n    validate: (path) => path.length === 4 && path.includes('E')\\n  }}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"max-interval-limit\"\n  }, \"Max Interval Limit\"), mdx(\"p\", null, \"As some voicings are pretty wide, we could limit the distance between notes.\\nLet\\u2019s refresh our ears and use D-7 this time:\"), mdx(VoicingPermutator, {\n    height: 300,\n    hidePlayer: false,\n    options: {\n      find: function find(path, solutions) {\n        if (path.length >= 4) {\n          return [];\n        }\n\n        return ['D', 'F', 'A', 'C'].filter(function (e) {\n          if (path.length && path[path.length - 1] === e) {\n            // forbid immediate doubling\n            return false;\n          }\n\n          if (path.length && Interval.semitones(Interval.distance(path[path.length - 1], e)) > 5) {\n            return false;\n          }\n\n          return true;\n        });\n      },\n      validate: function validate(path) {\n        return path.length === 4 && path.includes('F');\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  height={250}\\n  hidePlayer={false}\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length >= 4) {\\n        return [];\\n      }\\n      return ['D', 'F', 'A', 'C'].filter((e) => {\\n        if (path.length && path[path.length - 1] === e) {\\n          // forbid immediate doubling\\n          return false;\\n        }\\n        if (\\n          path.length &&\\n          Interval.semitones(Interval.distance(path[path.length - 1], e)) > 5\\n        ) {\\n          return false;\\n        }\\n        return true;\\n      });\\n    },\\n    validate: (path) => path.length === 4 && path.includes('F')\\n  }}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"Here, the next note is constrained to be <= 5 semitones away.\\nIf we look at the tree, we see that it starts to get asymmetrical.\"), mdx(\"h3\", {\n    \"id\": \"min-interval-limit\"\n  }, \"Min Interval Limit\"), mdx(\"p\", null, \"We could also avoid intervals that are too small:\"), mdx(VoicingPermutator, {\n    height: 500,\n    hidePlayer: false,\n    range: ['C3', 'G5'],\n    options: {\n      find: function find(path, solutions) {\n        if (path.length >= 4) {\n          return [];\n        }\n\n        return ['D', 'F', 'A', 'C'].filter(function (e) {\n          if (path.length && path[path.length - 1] === e) {\n            // forbid immediate doubling\n            return false;\n          }\n\n          if (path.length && Interval.semitones(Interval.distance(path[path.length - 1], e)) < 5) {\n            return false;\n          }\n\n          return true;\n        });\n      },\n      validate: function validate(path) {\n        return path.length === 4 && path.includes('F');\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  height={250}\\n  hidePlayer={false}\\n  range={['C3', 'G5']}\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length >= 4) {\\n        return [];\\n      }\\n      return ['D', 'F', 'A', 'C'].filter((e) => {\\n        if (path.length && path[path.length - 1] === e) {\\n          // forbid immediate doubling\\n          return false;\\n        }\\n        if (\\n          path.length &&\\n          Interval.semitones(Interval.distance(path[path.length - 1], e)) < 5\\n        ) {\\n          return false;\\n        }\\n        return true;\\n      });\\n    },\\n    validate: (path) => path.length === 4 && path.includes('F')\\n  }}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"Here, the next note must be at least 5 semitones away.\"), mdx(\"h3\", {\n    \"id\": \"limitations\"\n  }, \"Limitations\"), mdx(\"p\", null, \"In all of the above permutations, we just used the pitches. This has some serious limitations:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we cannot express voicings where the interval between two siblings exceeds 1 octave\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the extra step to generate the absolute notes seems redundant\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"we cannot apply permutation rules that depend on pitch height (like lower interval limits)\")), mdx(\"p\", null, \"If you think this is minor, or you do not really understand what I\\u2019m talking about, wait until you see the alternative.\"), mdx(\"h2\", {\n    \"id\": \"permutating-notes\"\n  }, \"Permutating Notes\"), mdx(\"p\", null, \"Instead of using just pitches, we could start with all possible notes (with octave) inside a range, and permutate with that. For example, D-7:\"), mdx(Keyboard, {\n    options: {\n      range: ['C3', 'C5'],\n      scaleX: 1,\n      scaleY: 1,\n      colorize: [{\n        keys: pitchesInRange(['D', 'F', 'A', 'C'], ['C3', 'C5']),\n        color: interpolateSinebow(0.5)\n      }]\n    },\n    mdxType: \"Keyboard\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"export function pitchesInRange(pitches, range = ['C3', 'C5']) {\\n  return Range.chromatic(range)\\n    .filter((note) =>\\n      pitches.find((pitch) => Note.chroma(pitch) === Note.chroma(note))\\n    )\\n    .map((note) =>\\n      enharmonicEquivalent(\\n        note,\\n        pitches.find((pitch) => Note.chroma(pitch) === Note.chroma(note))\\n      )\\n    );\\n}\\n\"))), mdx(\"p\", null, \"The colored keys are all possible notes we can pick inside our range (C3-C5).\\nNow we should ignore the order, as all notes are now unique.\\nThis brings us to the lottery model e.g. 3 out of 4:\"), mdx(VoicingPermutator, {\n    height: 400,\n    hidePlayer: false,\n    range: ['C3', 'C5'],\n    hasOctaves: true,\n    options: {\n      find: function find(path, solutions) {\n        if (path.length >= 4) {\n          return [];\n        } // this should not be calculated everytime (throw pitchesInRange outside)...\n\n\n        return pitchesInRange(['D', 'F', 'A', 'C'], ['C3', 'C5']).filter(function (e, i, array) {\n          if (path.length && array.indexOf(e) <= array.indexOf(path[path.length - 1])) {\n            // picks from left to right\n            return false;\n          }\n\n          if (path.length && Interval.semitones(Interval.distance(path[path.length - 1], e)) > 5) {\n            return false;\n          }\n\n          return true;\n        });\n      },\n      validate: function validate(path) {\n        return path.length === 4 && path.find(function (p) {\n          return Note.chroma(p) === Note.chroma('F');\n        });\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  height={400}\\n  hidePlayer={false}\\n  range={['C3', 'C5']}\\n  hasOctaves={true}\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length >= 4) {\\n        return [];\\n      }\\n      // this should not be calculated everytime (throw pitchesInRange outside)...\\n      return pitchesInRange(['D', 'F', 'A', 'C'], ['C3', 'C5']).filter(\\n        (e, i, array) => {\\n          if (\\n            path.length &&\\n            array.indexOf(e) <= array.indexOf(path[path.length - 1])\\n          ) {\\n            // picks from left to right\\n            return false;\\n          }\\n          if (\\n            path.length &&\\n            Interval.semitones(Interval.distance(path[path.length - 1], e)) > 5\\n          ) {\\n            return false;\\n          }\\n          return true;\\n        }\\n      );\\n    },\\n    validate: (path) =>\\n      path.length === 4 && path.find((p) => Note.chroma(p) === Note.chroma('F'))\\n  }}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"top-pitch-classes\"\n  }, \"Top Pitch Classes\"), mdx(\"p\", null, \"We could restrict our voicings to certain top pitch classes:\"), mdx(VoicingPermutator, {\n    height: 200,\n    hidePlayer: false,\n    range: ['C3', 'C5'],\n    hasOctaves: true,\n    options: {\n      find: function find(path, solutions) {\n        if (path.length >= 4) {\n          return [];\n        } // this should not be calculated everytime (throw pitchesInRange outside)...\n\n\n        return pitchesInRange(['D', 'F', 'A', 'C'], ['C3', 'C5']).filter(function (e, i, array) {\n          if (!path.length && !['C', 'F'].map(Note.chroma).includes(Note.chroma(e))) {\n            return false;\n          }\n\n          if (path.length && array.indexOf(e) >= array.indexOf(path[path.length - 1])) {\n            // picks from right to left !\n            return false;\n          }\n\n          if (path.length && Interval.semitones(Interval.distance(e, path[path.length - 1])) > 5) {\n            return false;\n          }\n\n          return true;\n        });\n      },\n      validate: function validate(path) {\n        return path.length === 4 && path.find(function (p) {\n          return Note.chroma(p) === Note.chroma('F');\n        });\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  height={200}\\n  hidePlayer={false}\\n  range={['C3', 'C5']}\\n  hasOctaves={true}\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length >= 4) {\\n        return [];\\n      }\\n      // this should not be calculated everytime (throw pitchesInRange outside)...\\n      return pitchesInRange(['D', 'F', 'A', 'C'], ['C3', 'C5']).filter(\\n        (e, i, array) => {\\n          if (\\n            !path.length &&\\n            !['C', 'F'].map(Note.chroma).includes(Note.chroma(e))\\n          ) {\\n            return false;\\n          }\\n          if (\\n            path.length &&\\n            array.indexOf(e) >= array.indexOf(path[path.length - 1])\\n          ) {\\n            // picks from right to left !\\n            return false;\\n          }\\n          if (\\n            path.length &&\\n            Interval.semitones(Interval.distance(e, path[path.length - 1])) > 5\\n          ) {\\n            return false;\\n          }\\n          return true;\\n        }\\n      );\\n    },\\n    validate: (path) =>\\n      path.length === 4 && path.find((p) => Note.chroma(p) === Note.chroma('F'))\\n  }}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"Here, only voicings with C or F at the top are valid.\\nThe trick here is that we permutate from the top down, to be able to start with the top note to cut most branches.\"), mdx(\"h3\", {\n    \"id\": \"bottom-pitch-classes\"\n  }, \"Bottom Pitch Classes\"), mdx(\"p\", null, \"Let\\u2019s flip the previous example around..\"), mdx(VoicingPermutator, {\n    height: 240,\n    hidePlayer: false,\n    range: ['C3', 'C5'],\n    hasOctaves: true,\n    options: {\n      find: function find(path, solutions) {\n        if (path.length >= 4) {\n          return [];\n        } // this should not be calculated everytime (throw pitchesInRange outside)...\n\n\n        return pitchesInRange(['D', 'F', 'A', 'C'], ['C3', 'C5']).filter(function (e, i, array) {\n          if (!path.length && !['C', 'F'].map(Note.chroma).includes(Note.chroma(e))) {\n            return false;\n          }\n\n          if (path.length && array.indexOf(e) <= array.indexOf(path[path.length - 1])) {\n            // picks from left to right\n            return false;\n          }\n\n          if (path.length && Interval.semitones(Interval.distance(path[path.length - 1], e)) > 5) {\n            return false;\n          }\n\n          return true;\n        });\n      },\n      validate: function validate(path) {\n        return path.length === 4 && path.find(function (p) {\n          return Note.chroma(p) === Note.chroma('F');\n        });\n      }\n    },\n    mdxType: \"VoicingPermutator\"\n  }), mdx(\"p\", null, \"This example accepts either C of F as bottom note. Now we are going from bottom up again.\"), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"<VoicingPermutator\\n  height={240}\\n  hidePlayer={false}\\n  range={['C3', 'C5']}\\n  hasOctaves={true}\\n  options={{\\n    find: (path, solutions) => {\\n      if (path.length >= 4) {\\n        return [];\\n      }\\n      // this should not be calculated everytime (throw pitchesInRange outside)...\\n      return pitchesInRange(['D', 'F', 'A', 'C'], ['C3', 'C5']).filter(\\n        (e, i, array) => {\\n          if (\\n            !path.length &&\\n            !['C', 'F'].map(Note.chroma).includes(Note.chroma(e))\\n          ) {\\n            return false;\\n          }\\n          if (\\n            path.length &&\\n            array.indexOf(e) <= array.indexOf(path[path.length - 1])\\n          ) {\\n            // picks from left to right\\n            return false;\\n          }\\n          if (\\n            path.length &&\\n            Interval.semitones(Interval.distance(path[path.length - 1], e)) > 5\\n          ) {\\n            return false;\\n          }\\n          return true;\\n        }\\n      );\\n    },\\n    validate: (path) =>\\n      path.length === 4 && path.find((p) => Note.chroma(p) === Note.chroma('F'))\\n  }}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"outlook\"\n  }, \"Outlook\"), mdx(\"p\", null, \"As this post now exceeds the magical limit of 1000 lines (only the MDX part), I will postpone the rest to a future post.\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"formulate an object format for voicing rules\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"migrate rules from Voicing.getCombinations\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"note importance rule => turn chord symbol to note importance hierarchy\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"write rhythmical plugin that generate voicing permutations\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"think about different ways to sort voicings\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"read bill evans voicing book and apply rules\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-chord-voicings/chord-voicing-rules/\"\n  }, \"http://www.thejazzpianosite.com/jazz-piano-lessons/jazz-chord-voicings/chord-voicing-rules/\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://en.wikipedia.org/wiki/Voicing_(music)\"\n  }, \"https://en.wikipedia.org/wiki/Voicing_(music)\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"use \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://observablehq.com/@d3/d3-hierarchy?collection=@d3/d3-hierarchy\"\n  }, \"https://observablehq.com/@d3/d3-hierarchy?collection=@d3/d3-hierarchy\"), \" e.g. path\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"or \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://observablehq.com/@d3/collapsible-tree?collection=@d3/d3-hierarchy\"\n  }, \"https://observablehq.com/@d3/collapsible-tree?collection=@d3/d3-hierarchy\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"maybe even replace flatObject with d3.hierarchy \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/d3/d3-hierarchy#hierarchy\"\n  }, \"https://github.com/d3/d3-hierarchy#hierarchy\"))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/voicing-permutation/","title":"Voicing Permutation","tags":[],"keywords":[],"date":"August 11, 2020","image":{"childImageSharp":{"fluid":{"base64":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA9UlEQVQoz02RiQ6CMBBE+f9fNIpUIUrA0HL1AEZmsZUmk577OrubbdsGisN7j77vsSwLQggyD8OQ1hTvp2mCtRbeeehRI1c5VKHkLMNvMMg5J4cxmJrnOd1xNsakdfABH/PB9X5FcS/EUEbAOI7yiADu13VN0lofbvbHhHRdl1w66wR4uV2Q33JhJCADqAinYgnEzU8EEiZlCHtJ5gGv+oX6XSMs4Z8yg+mILs8OWcMIJ6Rt2wRkymYyeJQPlM8SPuwpx6ZQDIxuI6RpGkk57umQn1hnBcimqKdCVVZHynQXu8z53FE6PDeJezYpwikBljuwOoBfN8cgilgA/sQAAAAASUVORK5CYII=","aspectRatio":2.7777777777777777,"src":"/blog/static/b1cac11a30f26f7b1b07320adce300f5/ee604/voicing-permutation.png","srcSet":"/blog/static/b1cac11a30f26f7b1b07320adce300f5/69585/voicing-permutation.png 200w,\n/blog/static/b1cac11a30f26f7b1b07320adce300f5/497c6/voicing-permutation.png 400w,\n/blog/static/b1cac11a30f26f7b1b07320adce300f5/ee604/voicing-permutation.png 800w,\n/blog/static/b1cac11a30f26f7b1b07320adce300f5/f3583/voicing-permutation.png 1200w,\n/blog/static/b1cac11a30f26f7b1b07320adce300f5/8259f/voicing-permutation.png 1296w","sizes":"(max-width: 800px) 100vw, 800px"}}},"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"35bc9fc8-9385-5688-a480-3383b7827fb8","excerpt":"So far, rhythmical knows two ways of data transformation/mutation: plugins  as preprocessors reducers  as postprocessors In this post, Iâ€¦","slug":"/rhythmical-reducers/","title":"Rhythmical Mutations","date":"August 02, 2020"},"next":{"__typename":"MdxBlogPost","id":"44906244-bde8-5211-8609-c087f7b866d8","excerpt":"I always get nostalgia when listening to the soundtracks of the  SNES , for example: I transcribed many of those  here Chipsynth SFCâ€¦","slug":"/chipsynth-sfc/","title":"Recreating SNES Music with Chipsynth SFC","date":"October 20, 2020"}},"pageContext":{"id":"e4b24033-4328-5d37-86d0-53a94a1f1495","previousId":"35bc9fc8-9385-5688-a480-3383b7827fb8","nextId":"44906244-bde8-5211-8609-c087f7b866d8"}},"staticQueryHashes":["386998304","4198970465","764694655"]}