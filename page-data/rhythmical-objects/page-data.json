{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/rhythmical-objects/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"4c59f9e6-3f00-5f54-b5bf-7bd71f4936f8","excerpt":"In the last post, we implemented the  rhythmical array notation .\nToday, I want to write about why and how the more powerful rhythmical…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Rhythmical Objects\",\n  \"date\": \"2020-05-29T00:00:00.000Z\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(Player, {\n    fold: true,\n    instruments: {\n      piano: piano,\n      drums: drums\n    },\n    events: renderRhythmObject({\n      duration: 14,\n      instrument: 'piano',\n      parallel: [[['e5', ['b4', 'c5'], 'd5', ['c5', 'b4']], ['a4', ['a4', 'c5'], 'e5', ['d5', 'c5']], ['b4', ['r', 'c5'], 'd5', 'e5'], ['c5', 'a4', 'a4', 'r'], [['r', 'd5'], ['r', 'f5'], 'a5', ['g5', 'f5']], ['e5', ['r', 'c5'], 'e5', ['d5', 'c5']], ['b4', ['b4', 'c5'], 'd5', 'e5'], ['c5', 'a4', 'a4', 'r']], [['e2', 'e3', 'e2', 'e3', 'e2', 'e3', 'e2', 'e3'], ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'a2', 'a3'], ['g#2', 'g#3', 'g#2', 'g#3', 'e2', 'e3', 'e2', 'e3'], ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'b1', 'c2'], ['d2', 'd3', 'd2', 'd3', 'd2', 'd3', 'd2', 'd3'], ['c2', 'c3', 'c2', 'c3', 'c2', 'c3', 'c2', 'c3'], ['b1', 'b2', 'b1', 'b2', 'e2', 'e3', 'e2', 'e3'], ['a1', 'a2', 'a1', 'a2', 'a1', 'a2', 'a1', 'a2']], {\n        instrument: 'drums',\n        value: [['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'], ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'], ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'], ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'], ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'], ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'], ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'], ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh']]\n      }]\n    }, [inheritProperty('instrument')]),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"<Player\\n  fold={true}\\n  events={renderRhythmObject(\\n    {\\n      duration: 14,\\n      parallel: [\\n        [\\n          ['e5', ['b4', 'c5'], 'd5', ['c5', 'b4']],\\n          ['a4', ['a4', 'c5'], 'e5', ['d5', 'c5']],\\n          ['b4', ['r', 'c5'], 'd5', 'e5'],\\n          ['c5', 'a4', 'a4', 'r'],\\n          [['r', 'd5'], ['r', 'f5'], 'a5', ['g5', 'f5']],\\n          ['e5', ['r', 'c5'], 'e5', ['d5', 'c5']],\\n          ['b4', ['b4', 'c5'], 'd5', 'e5'],\\n          ['c5', 'a4', 'a4', 'r']\\n        ],\\n        [\\n          ['e2', 'e3', 'e2', 'e3', 'e2', 'e3', 'e2', 'e3'],\\n          ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'a2', 'a3'],\\n          ['g#2', 'g#3', 'g#2', 'g#3', 'e2', 'e3', 'e2', 'e3'],\\n          ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'b1', 'c2'],\\n          ['d2', 'd3', 'd2', 'd3', 'd2', 'd3', 'd2', 'd3'],\\n          ['c2', 'c3', 'c2', 'c3', 'c2', 'c3', 'c2', 'c3'],\\n          ['b1', 'b2', 'b1', 'b2', 'e2', 'e3', 'e2', 'e3'],\\n          ['a1', 'a2', 'a1', 'a2', 'a1', 'a2', 'a1', 'a2']\\n        ],\\n        {\\n          instrument: 'drums',\\n          value: [\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'],\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'],\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'],\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'],\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'],\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'],\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh'],\\n            ['bd', 'hh', 'bd', 'hh', 'bd', ['hh', 'hh'], 'bd', 'hh']\\n          ]\\n        }\\n      ]\\n    },\\n    [inheritProperty('instrument')]\\n  )}\\n/>\\n\"))), mdx(\"br\", null), mdx(\"p\", null, \"In the last post, we implemented the \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"../rhythmical-arrays/\"\n  }), \"rhythmical array notation\"), \".\\nToday, I want to write about why and how the more powerful rhythmical object format is implemented.\"), mdx(\"p\", null, \"The array notation can be seen as a feature subset of the object notation.\\nThe implementation from last post will be obsolete, but the concepts of recursive flattening + paths stays relevant and helps to prevent analysis paralysis.\"), mdx(\"h2\", {\n    \"id\": \"features\"\n  }, \"Features\"), mdx(\"p\", null, \"In addition to the features of the array notation, here are things we can do with object notation:\"), mdx(\"h3\", {\n    \"id\": \"polyphony\"\n  }, \"Polyphony\"), mdx(\"p\", null, \"Using the Object syntax, we can express polyphony:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"{\\n  parallel: [\\n    { sequential: ['E3', 'F3', 'G3'], color: 'orchid' },\\n    { sequential: ['C3', 'D3', 'E3'], color: 'palegreen' }\\n  ];\\n}\\n\")), mdx(Player, {\n    center: 0,\n    height: 100,\n    noteRange: ['C3', 'G3'],\n    events: renderRhythmObject({\n      duration: 3,\n      parallel: [{\n        sequential: ['E3', 'F3', 'G3'],\n        color: 'orchid'\n      }, {\n        sequential: ['C3', 'D3', 'E3'],\n        color: 'palegreen'\n      }]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"This is impossible to formulate with just arrays.\\nAs an alternative, the same end result could be achieved with this notation:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"{\\n  sequential: [\\n    { parallel: ['C3', 'E3'], color: 'aquamarine' },\\n    { parallel: ['D3', 'F3'], color: 'skyblue' },\\n    { parallel: ['E3', 'G3'], color: 'slateblue' }\\n  ];\\n}\\n\")), mdx(Player, {\n    height: 100,\n    noteRange: ['C3', 'G3'],\n    center: 0,\n    events: renderRhythmObject({\n      duration: 3,\n      sequential: [{\n        parallel: ['C3', 'E3'],\n        color: 'aquamarine'\n      }, {\n        parallel: ['D3', 'F3'],\n        color: 'skyblue'\n      }, {\n        parallel: ['E3', 'G3'],\n        color: 'slateblue'\n      }]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"Depending on the context, both ways can be useful:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the first approach can be used for multiple voices in a piece (horizontal approach)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the second can be used for chords inside a single voice (vertical approach)\")), mdx(\"p\", null, \"As we can nest arbitrarily deep, we can also combine both approaches:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"{\\n    color: 'orchid',\\n    duration: 3,\\n    parallel: [\\n      ['G3', ['A3', 'C4'], 'B3'],\\n      [\\n        { parallel: ['C3', 'E3'], color: 'aquamarine' },\\n        { parallel: ['D3', 'F3'], color: 'skyblue' },\\n        { parallel: ['E3', 'G3'], color: 'slateblue' }\\n      ]\\n    ]\\n}\\n\")), mdx(Player, {\n    height: 200,\n    center: 0,\n    noteRange: ['C3', 'C4'],\n    events: renderRhythmObject({\n      color: 'orchid',\n      duration: 3,\n      parallel: [['G3', ['A3', 'C4'], 'B3'], [{\n        parallel: ['C3', 'E3'],\n        color: 'aquamarine'\n      }, {\n        parallel: ['D3', 'F3'],\n        color: 'skyblue'\n      }, {\n        parallel: ['E3', 'G3'],\n        color: 'slateblue'\n      }]]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"This idea of parallel and sequential blocks is similar to \", mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"http://recherche.ircam.fr/equipes/repmus/LispSecondLanguage/functional/functional.html\"\n  }), \"Lisp as a second Language\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The combination with nested array notation + durations makes it even more powerful\")), mdx(\"h3\", {\n    \"id\": \"inheritance\"\n  }, \"Inheritance\"), mdx(\"p\", null, \"In the example above, the colors show how we can use inheritance:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"color \", mdx(\"em\", {\n    parentName: \"li\"\n  }, \"orchid\"), \" is defined the root object\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"all children that do not override the color will have that color\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"if children do set a color, all of their children will keep the new color\")), mdx(\"p\", null, \"This concept is useful for many things, like setting instruments, velocities, styles etc\\u2026\"), mdx(\"h3\", {\n    \"id\": \"default-values\"\n  }, \"Default values\"), mdx(\"p\", null, \"By utilizing default values, we do not have to use objects for many tasks. If we use arrays or strings, default values will be assumed, like:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"duration = 1\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"type = sequential\")), mdx(\"p\", null, \"So we only need objects if we want to set non-default properties.\"), mdx(\"h3\", {\n    \"id\": \"song-example\"\n  }, \"Song Example\"), mdx(\"p\", null, \"Let\\u2019s combine all features by spelling an example, like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.youtube.com/watch?v=J7ATTjg7tpE\"\n  }), \"Oye Como Va by Santana\"), \".\\nThe groove goes like this:\"), mdx(Score, {\n    width: 620,\n    height: 100,\n    clef: \"\",\n    timeSignature: \"\",\n    staves: rhythmicalScore([[['b4', 'r', 'b4', 'r'], ['r', 'b4', 'r', 'b4']], [['r', ['r', 'b4']], [['r', 'b4'], 'r']]]),\n    mdxType: \"Score\"\n  }), mdx(Player, {\n    height: 100,\n    center: 0,\n    events: renderRhythmObject({\n      duration: 4,\n      value: [[['B4', 'r', 'B4', 'r'], ['r', 'B4', 'r', 'B4']], [['r', ['r', 'B4']], [['r', 'B4'], 'r']]]\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"The rhythmical notation is:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"[\\n  [\\n    ['B4', 'r', 'B4', 'r'],\\n    ['r', 'B4', 'r', 'B4']\\n  ],\\n  [\\n    ['r', ['r', 'B4']],\\n    [['r', 'B4'], 'r']\\n  ]\\n];\\n\")), mdx(\"p\", null, \"If we now wanted to play a chord with that groove, we can just do this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"const chord = { parallel: ['C3', 'Eb3', 'G3'] };\\nconst groove = [\\n  [\\n    [chord, 'r', chord, 'r'],\\n    ['r', chord, 'r', chord]\\n  ],\\n  [\\n    ['r', ['r', chord]],\\n    [['r', chord], 'r']\\n  ]\\n];\\n\")), mdx(Player, {\n    height: 100,\n    center: 0,\n    events: function () {\n      var chord = {\n        parallel: ['C3', 'Eb3', 'G3']\n      };\n      return renderRhythmObject({\n        duration: 4,\n        parallel: [{\n          instrument: 'drums',\n          value: ['hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh', 'hh']\n        }, [[[chord, 'r', chord, 'r'], ['r', chord, 'r', chord]], [['r', ['r', chord]], [['r', chord], 'r']]]]\n      }, [inheritProperty('instrument')]);\n    }(),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"Finally, we can add the melody as a second voice:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"{\\n  parallel: [\\n    {\\n      sequential: [\\n        [\\n          ['C4', 'F4', 'Eb4', 'F4'],\\n          ['C4', { value: 'r', duration: 3 }]\\n        ],\\n        [\\n          [{ value: 'r', duration: 3 }, 'Eb4'],\\n          ['G4', 'r', 'F4', 'r']\\n        ]\\n      ],\\n      color: 'darksalmon'\\n    },\\n    [\\n      [\\n        [chord, 'r', chord, 'r'],\\n        ['r', chord, 'r', chord]\\n      ],\\n      [\\n        ['r', ['r', chord]],\\n        [['r', chord], 'r']\\n      ]\\n    ]\\n  ];\\n}\\n\")), mdx(Player, {\n    height: 200,\n    events: function () {\n      var chord = {\n        parallel: ['C3', 'Eb3', 'G3']\n      };\n      return renderRhythmObject({\n        duration: 4,\n        parallel: [{\n          sequential: [[['C4', 'F4', 'Eb4', 'F4'], ['C4', {\n            value: 'r',\n            duration: 3\n          }]], [[{\n            value: 'r',\n            duration: 3\n          }, 'Eb4'], ['G4', 'r', 'F4', 'r']]],\n          color: 'darksalmon'\n        }, [[[chord, 'r', chord, 'r'], ['r', chord, 'r', chord]], [['r', ['r', chord]], [['r', chord], 'r']]]]\n      }, [inheritProperty('instrument')]);\n    }(),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"If you still don\\u2019t like the syntax, you should have a look at string shorthand notations described \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://felixroos.github.io/rhythmical/\"\n  }), \"here\"), \".\\nThe string notation is a topic for another post.\"), mdx(\"h2\", {\n    \"id\": \"implementation\"\n  }, \"Implementation\"), mdx(\"p\", null, \"Now, let\\u2019s implement all of this..\"), mdx(\"h3\", {\n    \"id\": \"ways-of-representation\"\n  }, \"Ways of Representation\"), mdx(\"p\", null, \"Let\\u2019s first go back to the basics. With javascript, we can make use of:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Strings / Numbers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Arrays\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Objects <\\u2014 new\")), mdx(\"p\", null, \"For javascript, all of those are treated as Objects internally, but we care about the syntax here.\\nWe could represent one note in three different ways:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"\\\"C4 D3 E3\\\" // string\\n[\\\"C4\\\", \\\"D3\\\", \\\"E3\\\"] // array\\n{\\\"sequential\\\": [\\\"C4\\\", \\\"D3\\\", \\\"E3\\\"]} // object\\n\")), mdx(\"p\", null, \"We have a hierarchy of semantical limitation vs syntactical simplicity here:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Strings are the most limited but most simple: No nesting, but the least characters\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Arrays are less limited but more verbose: With Nesting, but more syntax\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Objects are limitless but most verbose: Any properties can be added for extra functionality, but even more syntax\")), mdx(\"h3\", {\n    \"id\": \"domain-specific-language\"\n  }, \"Domain Specific Language\"), mdx(\"p\", null, \"We could even extend the features of the string by writing some regex magic or even a Domain Specific Language. For example, we could allow nesting and durations:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {}), \"\\\"C4 [D3 E3] F3*2\\\"\\n\")), mdx(\"p\", null, \"As this is a huge topic, it will be a topic for another post. This post will mainly focus on the background concepts of the format.\\nJust keep in mind that the format for the end usage will look even better, similar to TidalCycles mini notation.\\nThe \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://felixroos.github.io/rhythmical/\"\n  }), \"REPL\"), \" already uses an experimental implementation of string shorthand notation.\"), mdx(\"h2\", {\n    \"id\": \"unification\"\n  }, \"Unification\"), mdx(\"p\", null, \"Before we implement the flattening we need some helpers for unification:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function toObject<T>(agnostic: AgnosticChild<T>): ValueChild<T> {\\n  if (typeof agnostic !== 'object' || Array.isArray(agnostic)) {\\n    return { value: agnostic };\\n  }\\n  return agnostic;\\n}\\nexport function toArray<T>(array: T | T[]): T[] {\\n  if (!Array.isArray(array)) {\\n    return [array] as T[];\\n  }\\n  return array as T[];\\n}\\nexport type ValueChild<T> = { value?: AgnosticChild<T>; [key: string]: any };\\nexport type AgnosticChild<T> = ValueChild<T> | T[] | T;\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ValueChild is just an arbitrary object with the reserved property \\u201Cvalue\\u201D\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"AgnosticChild can be either primitive, Array of primitives or ValueChild\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"So AgnosticChild can be any hierarchy of objects via value properties\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"toArray ensures the output to be an Array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"toObject ensures the output to be a ValueChild\")), mdx(\"details\", null, mdx(\"summary\", null, \"show example tests\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"test('toObject', () => {\\n  expect(toObject('')).toEqual({ value: '' });\\n  expect(toObject('C')).toEqual({ value: 'C' });\\n  expect(toObject({ m: 'C' })).toEqual({ m: 'C' });\\n  expect(toObject(['C', 'D'])).toEqual({ value: ['C', 'D'] });\\n  expect(toObject('C')).toEqual({ value: 'C' });\\n});\\ntest('toArray', () => {\\n  expect(toArray('')).toEqual(['']);\\n  expect(toArray([])).toEqual([]);\\n  expect(toArray('C')).toEqual(['C']);\\n  expect(toArray({ m: 'C' })).toEqual([{ m: 'C' }]);\\n});\\n\"))), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"flattening-nested-objects\"\n  }, \"Flattening nested Objects\"), mdx(\"p\", null, \"With the above helper methods, we can implement a basic flattening method:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function flatObject<T>(\\n  agnostic: AgnosticChild<T>,\\n  props: FlatObjectProps<T> = {}\\n): ValueChild<T>[] {\\n  const getChildren: ChildrenResolver<T> =\\n    props.getChildren || getChildrenWithPath;\\n  let flat: ValueChild<T>[] = [];\\n  const children = getChildren(agnostic, props);\\n  children.forEach((child) => {\\n    if (child.value && typeof child.value === 'object') {\\n      flat = flat.concat(flatObject(child, props));\\n    } else {\\n      flat.push(child);\\n    }\\n  });\\n  return flat;\\n}\\nexport interface FlatObjectProps<T> {\\n  getChildren?: ChildrenResolver<T>;\\n  [key: string]: any;\\n}\\nexport type ChildrenResolver<T> = (\\n  agnostic: AgnosticChild<T>,\\n  props?: FlatObjectProps<T>\\n) => ValueChild<T>[];\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"getChildren resolves children from the given AgnosticChild (if any)\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"this is where we can inject functionality without\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"for each resolved child\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"that has an object as value, we call that value again with flatObject\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"that has a primitive as value, we just append the child to the flat array\")))), mdx(\"p\", null, \"The default children resolver \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"getChildrenWithPath\"), \" is this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function getChildrenWithPath<T>(\\n  agnostic: AgnosticChild<T>\\n): ValueChild<T>[] {\\n  let o = toObject<T>(agnostic);\\n  const children = toArray(o.value) || [];\\n  return children.map((child, i, children) => ({\\n    ...toObject(child),\\n    path: (o.path || []).concat([[i, children.length]])\\n  }));\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"here we first ensure we have an object\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"then we transform the value to an array\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"then we append the path to the child\")), mdx(\"details\", null, mdx(\"summary\", null, \"show example tests\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"expect(flatObject(['C', ['D', 'E']])).toEqual([\\n  { value: 'C', path: [[0, 2]] },\\n  {\\n    value: 'D',\\n    path: [\\n      [1, 2],\\n      [0, 2]\\n    ]\\n  },\\n  {\\n    value: 'E',\\n    path: [\\n      [1, 2],\\n      [1, 2]\\n    ]\\n  }\\n]);\\n\\nexpect(flatObject({ value: ['C', ['D', 'E']] })).toEqual([\\n  { value: 'C', path: [[0, 2]] },\\n  {\\n    value: 'D',\\n    path: [\\n      [1, 2],\\n      [0, 2]\\n    ]\\n  },\\n  {\\n    value: 'E',\\n    path: [\\n      [1, 2],\\n      [1, 2]\\n    ]\\n  }\\n]);\\nexpect(flatObject(['C', { value: ['D', 'E'] }])).toEqual([\\n  { value: 'C', path: [[0, 2]] },\\n  {\\n    value: 'D',\\n    path: [\\n      [1, 2],\\n      [0, 2]\\n    ]\\n  },\\n  {\\n    value: 'E',\\n    path: [\\n      [1, 2],\\n      [1, 2]\\n    ]\\n  }\\n]);\\nexpect(flatObject([{ value: 'C' }, { value: ['D', 'E'] }])).toEqual([\\n  { value: 'C', path: [[0, 2]] },\\n  {\\n    value: 'D',\\n    path: [\\n      [1, 2],\\n      [0, 2]\\n    ]\\n  },\\n  {\\n    value: 'E',\\n    path: [\\n      [1, 2],\\n      [1, 2]\\n    ]\\n  }\\n]);\\n\"))), mdx(\"p\", null, \"Maybe this implementation is hard to grasp, or it may seem overkill to have an extra function to resolve the children, but we will see why this is really helpful when we implement rhythmical features.\"), mdx(\"h2\", {\n    \"id\": \"durations\"\n  }, \"Durations\"), mdx(\"p\", null, \"Like already mentioned in the last post, we need a way to change the duration of events. This can be done with a custom getChildren method:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function getRhythmChildren<T>(\\n  agnostic: AgnosticChild<T>\\n): ValueChild<T>[] {\\n  let o = toObject<T>(agnostic);\\n  const children = toArray(o.value) || [];\\n  const duration = sumDurations(children);\\n  return children.map((child, i, children) => {\\n    const position = sumDurations(children.slice(0, i));\\n    child = toObject(child);\\n    const path = (o.path || []).concat([\\n      [position, child.duration || 1, duration]\\n    ]);\\n    return { ...child, path };\\n  });\\n}\\n// wrap flatObject with custom getChildren method:\\nexport function flatRhythmObject<T>(\\n  agnostic: AgnosticChild<T>\\n): ValueChild<T>[] {\\n  return flatObject(agnostic, {\\n    getChildren: getRhythmChildren\\n  });\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"path format: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"[position, childDuration, parentDuration]\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the position is the sum of all previous child durations\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the childDuration defaults to 1 if not set\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"the parent duration is the sum of all child durations\")), mdx(\"p\", null, \"sumDurations:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function sumDurations<T>(children: AgnosticChild<T>[]) {\\n  return children.reduce(\\n    (sum, child) => sum + (toObject(child).duration || 1),\\n    0\\n  );\\n}\\n\")), mdx(\"p\", null, \"Now we can finally use durations like:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"[{ value: 'C4', duration: 3 }, 'D4'];\\n\")), mdx(Player, {\n    center: 0,\n    events: renderRhythmObject([{\n      value: 'C4',\n      duration: 3\n    }, 'D4']),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show example tests\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"expect(flatRhythmObject(['C', ['D', 'E']])).toEqual([\\n  { value: 'C', path: [[0, 1, 2]] },\\n  {\\n    value: 'D',\\n    path: [\\n      [1, 1, 2],\\n      [0, 1, 2]\\n    ]\\n  },\\n  {\\n    value: 'E',\\n    path: [\\n      [1, 1, 2],\\n      [1, 1, 2]\\n    ]\\n  }\\n]);\\nexpect(flatRhythmObject([{ value: 'C', duration: 2 }, ['D', 'E']])).toEqual([\\n  { value: 'C', path: [[0, 2, 3]], duration: 2 },\\n  {\\n    value: 'D',\\n    path: [\\n      [2, 1, 3],\\n      [0, 1, 2]\\n    ]\\n  },\\n  {\\n    value: 'E',\\n    path: [\\n      [2, 1, 3],\\n      [1, 1, 2]\\n    ]\\n  }\\n]);\\nexpect(\\n  flatRhythmObject({\\n    duration: 2,\\n    value: [{ value: 'C', duration: 2 }, ['D', 'E']]\\n  })\\n).toEqual([\\n  { value: 'C', path: [[0, 2, 3]], duration: 2 },\\n  {\\n    value: 'D',\\n    path: [\\n      [2, 1, 3],\\n      [0, 1, 2]\\n    ]\\n  },\\n  {\\n    value: 'E',\\n    path: [\\n      [2, 1, 3],\\n      [1, 1, 2]\\n    ]\\n  }\\n]);\\nexpect(flatRhythmObject({ value: ['C', 'E', 'G'], type: 'parallel' })).toEqual([\\n  { value: 'C', path: [[0, 1, 1]] },\\n  { value: 'E', path: [[0, 1, 1]] },\\n  { value: 'G', path: [[0, 1, 1]] }\\n]);\\n\"))), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"polyphony-1\"\n  }, \"Polyphony\"), mdx(\"p\", null, \"By adding types, we can change how the path is set:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"const types = { sequential: 'sequential', parallel: 'parallel' };\\n\\n// set value + type based on shorthand property\\nexport function toRhythmObject<T>(agnostic: AgnosticChild<T>) {\\n  let o = toObject<T>(agnostic);\\n  if (o[types.sequential]) {\\n    o.type = types.sequential;\\n    o.value = o[types.sequential];\\n    delete o[types.sequential];\\n  }\\n  if (o[types.parallel]) {\\n    o.type = types.parallel;\\n    o.value = o[types.parallel];\\n    delete o[types.parallel];\\n  }\\n  return o;\\n}\\n\\n// add paths based on duration + type\\nexport function getRhythmChildren<T>(\\n  agnostic: AgnosticChild<T>\\n): ValueChild<T>[] {\\n  let o = toRhythmObject<T>(agnostic);\\n  let {\\n    value: parentValue,\\n    type: parentType,\\n    path: parentPath,\\n    color: parentColor\\n  } = o;\\n  const children = toArray(parentValue) || [];\\n  const duration = sumDurations(children);\\n  const maxDuration = max(children.map((c) => toObject(c).duration || 1));\\n  return children.map((child, i, children) => {\\n    child = toRhythmObject(child);\\n    // add paths depending on type\\n    let path;\\n    if (!parentType || parentType === types.sequential) {\\n      const position = sumDurations(children.slice(0, i));\\n      path = (parentPath || []).concat([\\n        [position, child.duration || 1, duration]\\n      ]);\\n    } else if (parentType === types.parallel) {\\n      path = (parentPath || []).concat([[0, o.duration || 1, maxDuration]]);\\n    } else {\\n      throw new Error(parentType + ': type not supported');\\n    }\\n    // drill path and color\\n    return { ...child, path, color: child.color || parentColor };\\n  });\\n}\\n\")), mdx(\"p\", null, \"This opens up the world of harmony:\"), mdx(Player, {\n    center: 0,\n    events: renderRhythmObject([{\n      value: ['C3', 'E3', 'G3'],\n      type: 'parallel'\n    }, {\n      value: ['D3', 'F3', 'A3'],\n      type: 'parallel'\n    }]),\n    mdxType: \"Player\"\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"[\\n  { value: ['C3', 'E3', 'G3'], type: 'parallel' },\\n  { value: ['D3', 'F3', 'A3'], type: 'parallel' }\\n];\\n\")), mdx(\"h2\", {\n    \"id\": \"feature-encapsulation\"\n  }, \"Feature encapsulation\"), mdx(\"p\", null, \"As I plan to add a lot more features, and the code above already starts to get hard to read, I ended up encapsulating features into seperate methods.\\nI am aware that this slightly drains the performance of the rendering but the performance should not be an issue.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function applyFeatures<T>(\\n  agnostic: AgnosticChild<T>,\\n  features: Feature<T>[]\\n): AgnosticChild<T> {\\n  features.forEach((feature) => {\\n    agnostic = feature(agnostic);\\n  });\\n  return agnostic;\\n}\\nexport declare type Feature<T> = (\\n  agnostic: AgnosticChild<T>\\n) => AgnosticChild<T>;\\nexport type ValueChild<T> = { value?: AgnosticChild<T>; [key: string]: any };\\nexport type AgnosticChild<T> = ValueChild<T> | T[] | T;\\n\")), mdx(\"br\", null), mdx(\"h3\", {\n    \"id\": \"inheritance-1\"\n  }, \"Inheritance\"), mdx(\"p\", null, \"Here is a simple feature that inherits a property from parent to child. The child has the ability to override the parent property:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"export function inheritProperty<T>(property) {\\n  return (_parent: AgnosticChild<T>): AgnosticChild<T> => {\\n    const parent = toObject(_parent);\\n    if (!parent[property] || !parent.value) {\\n      return parent;\\n    }\\n    return {\\n      ...parent,\\n      value: toArray(parent.value).map((child) => {\\n        const childObj = toObject(child);\\n        return {\\n          ...childObj,\\n          [property]: childObj[property] || parent[property]\\n        };\\n      })\\n    };\\n  };\\n}\\ninheritProperty('color'); // => can be applied to parent\\n\")), mdx(Player, {\n    center: 0,\n    events: renderRhythmObject({\n      duration: 4,\n      value: Array.from({\n        length: 9\n      }, function (_, i) {\n        return {\n          color: interpolateRainbow(i / 9),\n          value: {\n            parallel: [0, 4, 7].map(function (step) {\n              return Note.fromMidi(Note.midi('C3') + i + step);\n            }).concat([{\n              value: Note.fromMidi(Note.midi('C4') + i),\n              color: interpolateRainbow((9 - i) / 9)\n            }])\n          }\n        };\n      })\n    }),\n    mdxType: \"Player\"\n  }), mdx(\"details\", null, mdx(\"summary\", null, \"show source\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-ts\"\n  }), \"Array.from({ length: 9 }, (_, i) => ({\\n  color: interpolateRainbow(i / 9),\\n  value: {\\n    parallel: [1, 3, 5]\\n      .map((step) => Note.fromMidi(Note.midi('C3') + i + step - 1))\\n      .concat([\\n        {\\n          value: Note.fromMidi(Note.midi('C4') + i),\\n          color: interpolateRainbow((9 - i) / 9)\\n        }\\n      ])\\n  }\\n}));\\n\"))), mdx(\"br\", null), mdx(\"h2\", {\n    \"id\": \"next-steps\"\n  }, \"Next Steps\"), mdx(\"p\", null, \"This is the basic implementation of rhythmical object format! Future extensions could be:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"setting instruments\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"using variables\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"assign values from parent to children (like duration for different time signatures)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"playback component\")));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/rhythmical-objects/","title":"Rhythmical Objects","tags":[],"keywords":[],"date":"May 29, 2020"},"previous":{"__typename":"MdxBlogPost","id":"3dc66d40-f4bc-5565-9061-581e1b6a44cf","excerpt":"In this post, I want to describe how and why  rhythmical  is implemented. Nested vs Flat Arrays The goal of rhythmical is to convert rhythms…","slug":"/rhythmical-arrays/","title":"Rhythmical Arrays","date":"May 27, 2020"},"next":{"__typename":"MdxBlogPost","id":"6dd1e095-9570-58e5-80b8-ddf949a7fa94","excerpt":"Before implementing more rhythmical features, it would be good to hear some results. This is where the Player comes in.\nThe Player itself…","slug":"/rhythmical-playback/","title":"Tone.js Playback","date":"June 09, 2020"}},"pageContext":{"id":"4c59f9e6-3f00-5f54-b5bf-7bd71f4936f8","previousId":"3dc66d40-f4bc-5565-9061-581e1b6a44cf","nextId":"6dd1e095-9570-58e5-80b8-ddf949a7fa94"}}}