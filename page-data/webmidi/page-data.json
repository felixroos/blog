{"componentChunkName":"component---node-modules-gatsby-theme-blog-core-src-templates-post-query-js","path":"/webmidi/","result":{"data":{"site":{"siteMetadata":{"title":"Loophole Letters","social":[{"name":"github","url":"https://github.com/felixroos"},{"name":"GitHub","url":"https://github.com/gatsbyjs"}]}},"blogPost":{"__typename":"MdxBlogPost","id":"ac2b32d3-ca18-596f-89a7-db1f04563617","excerpt":"With the Web MIDI API, we can send and receive MIDI events from javascript.\nThis allows us to trigger notes on any instrument! Turning MIDI…","body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Using MIDI with JavaScript\",\n  \"date\": \"2020-12-30T00:00:00.000Z\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"With the Web MIDI API, we can send and receive MIDI events from javascript.\\nThis allows us to trigger notes on any instrument!\"), mdx(\"h2\", {\n    \"id\": \"turning-midi-into-sound\"\n  }, \"Turning MIDI into sound\"), mdx(\"p\", null, \"Before we get started, we need to make sure we can actually hear something:\"), mdx(\"h3\", {\n    \"id\": \"external-instrument\"\n  }, \"External Instrument\"), mdx(\"p\", null, \"One way to turn MIDI into sound is to trigger an external hardware instrument.\\nFor example, we could send the MIDI from the browser though an audio interface MIDI output to the MIDI input of a synth.\"), mdx(\"h3\", {\n    \"id\": \"internal-midi\"\n  }, \"Internal MIDI\"), mdx(\"p\", null, \"As described \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://stackoverflow.com/questions/43544357/how-to-connect-web-midi-api-to-native-application-like-ableton-live\"\n  }), \"here\"), \", MIDI can be received from the browser via IAC (at least on macOS).\\nWith it, we can control any software instrument / daw on the same computer. I am using Ableton, setting up a MIDI instrument track.\"), mdx(\"h2\", {\n    \"id\": \"live-coding-with-runjs\"\n  }, \"Live Coding with RunJS\"), mdx(\"p\", null, \"A quick and simple solution to trigger midi from javascript is using \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://runjs.dev/\"\n  }), \"RunJS\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/djipco/webmidi\"\n  }), \"webmidi\"), \".\\nAfter installation, we can use the following function to run any midi logic:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import WebMidi from 'webmidi';\\n\\nfunction run(fn, clear = true) {\\n  WebMidi.enable((err) => {\\n    if (err) {\\n      throw new Error('Web Midi could not be enabled...');\\n    }\\n    if (WebMidi.outputs.length === 0) {\\n      throw new Error('No output found...');\\n    }\\n    // console.log('outputs', WebMidi.outputs)\\n    const output = WebMidi.outputs[0]; // use the input you like\\n    console.log(`using output \\\"${output.name}\\\"`);\\n    if (clear) {\\n      output.sendChannelMode('allnotesoff');\\n    }\\n    setTimeout(() => fn(output), 5);\\n  });\\n}\\nconst stopAll = () => run(() => output.sendChannelMode('allnotesoff'));\\n// test chord:\\nrun((output) => output.playNote(['C3', 'E3', 'G3', 'B3'], 1));\\nstopAll(); // stops all notes if no run call is active\\n\")), mdx(\"p\", null, \"I found it best to disable \\u201Cauto-run code on change\\u201D to trigger the code only when wanted with CMD+R.\\nIf you have an instrument connected that listens for channel 1, the above code should produce a beatiful C major 7 chord.\"), mdx(\"h3\", {\n    \"id\": \"scale-trainer\"\n  }, \"Scale Trainer\"), mdx(\"p\", null, \"Another way to use this is ear training. We can trigger random notes out of a given scale like this:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import { Interval, Note, Scale } from '@tonaljs/tonal';\\n\\nconst random = (a) => a[Math.floor(a.length * Math.random())];\\n\\nconst scaleTrainer = (root, scale, clear) =>\\n  run((output) => {\\n    const notes = [root, random(Scale.get(`${root} ${scale}`).notes)];\\n    console.log('play notes', notes);\\n    output.playNote(notes, 2);\\n  }, clear);\\n\\nscaleTrainer('C4', 'dorian', false);\\n\")), mdx(\"p\", null, \"This is just an example how we can get creative with this tool.\"), mdx(\"h2\", {\n    \"id\": \"running-from-a-web-browser\"\n  }, \"Running from a Web Browser\"), mdx(\"p\", null, \"Currently, the Web MIDI API only has \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://github.com/djipco/webmidi#browser-support\"\n  }), \"limited browser support\"), \".\"), mdx(\"h3\", {\n    \"id\": \"usewebmidi\"\n  }, \"useWebMidi\"), mdx(\"p\", null, \"The following hook can be used to interface with WebMidi:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import { useEffect, useState } from 'react';\\nimport WebMidi from 'webmidi';\\n\\nexport default function useWebMidi({ ready, connected, disconnected }: any) {\\n  const [loading, setLoading] = useState(true);\\n  const [outputs, setOutputs] = useState<any[]>(WebMidi?.outputs || []);\\n  useEffect(() => {\\n    WebMidi.enable((err) => {\\n      if (err) {\\n        //throw new Error(\\\"Web Midi could not be enabled...\\\");\\n        console.warn('Web Midi could not be enabled..');\\n        return;\\n      }\\n      // Reacting when a new device becomes available\\n      WebMidi.addListener('connected', (e) => {\\n        setOutputs([...WebMidi.outputs]);\\n        connected?.(WebMidi, e);\\n      });\\n\\n      // Reacting when a device becomes unavailable\\n      WebMidi.addListener('disconnected', (e) => {\\n        setOutputs([...WebMidi.outputs]);\\n        disconnected?.(WebMidi, e);\\n      });\\n      ready?.(WebMidi);\\n      setLoading(false);\\n    });\\n  }, [ready, connected, disconnected, outputs]);\\n  const outputByName = (name) => WebMidi.getOutputByName(name);\\n  return { loading, outputs, outputByName };\\n}\\n\")), mdx(\"h3\", {\n    \"id\": \"midiselect\"\n  }, \"MidiSelect\"), mdx(\"p\", null, \"Let\\u2019s use the hook to show a midi output selector:\"), mdx(State, {\n    initial: {},\n    mdxType: \"State\"\n  }, function (_ref2) {\n    var _state$output;\n\n    var setState = _ref2.setState,\n        state = _ref2.state;\n    return mdx(React.Fragment, null, mdx(MidiSelect, {\n      onChange: function onChange(output) {\n        return setState({\n          output: output\n        });\n      },\n      mdxType: \"MidiSelect\"\n    }), state.output && mdx(\"p\", null, (_state$output = state.output) === null || _state$output === void 0 ? void 0 : _state$output.name, \" selected\", mdx(\"br\", null), mdx(\"button\", {\n      onClick: function onClick() {\n        var _state$output2;\n\n        return (_state$output2 = state.output) === null || _state$output2 === void 0 ? void 0 : _state$output2.playNote('A4');\n      }\n    }, \"play A4\"), mdx(\"button\", {\n      onClick: function onClick() {\n        var _state$output3;\n\n        return (_state$output3 = state.output) === null || _state$output3 === void 0 ? void 0 : _state$output3.sendChannelMode('allnotesoff');\n      }\n    }, \"stop\")));\n  }), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import MidiSelect from '../components/midi/MidiSelect.tsx';\\nimport { State } from 'react-powerplug';\\n\\n<State initial={{}}>\\n  {({ setState, state }) => (\\n    <React.Fragment>\\n      <MidiSelect onChange={(output) => setState({ output })} />\\n      {state.output && (\\n        <p>\\n          {state.output?.name} selected\\n          <br />\\n          <button onClick={() => state.output?.playNote('A4')}>play A4</button>\\n          <button onClick={() => state.output?.sendChannelMode('allnotesoff')}>stop</button>\\n        </p>\\n      )}\\n    </React.Fragment>\\n  )}\\n</State>;\\n\")), mdx(\"h2\", {\n    \"id\": \"midi-instrument\"\n  }, \"Midi Instrument\"), mdx(\"p\", null, \"We can now use the above knowledge to create a special midi instrument for the rhythmical player.\"), mdx(Player, {\n    fold: true,\n    hierarchy: false,\n    instruments: {\n      piano: midi('IAC-Treiber Bus 1', 1)\n    },\n    events: renderRhythm({\n      duration: 14,\n      instrument: 'piano',\n      parallel: [[['e5', ['b4', 'c5'], 'd5', ['c5', 'b4']], ['a4', ['a4', 'c5'], 'e5', ['d5', 'c5']], ['b4', ['r', 'c5'], 'd5', 'e5'], ['c5', 'a4', 'a4', 'r'], [['r', 'd5'], ['r', 'f5'], 'a5', ['g5', 'f5']], ['e5', ['r', 'c5'], 'e5', ['d5', 'c5']], ['b4', ['b4', 'c5'], 'd5', 'e5'], ['c5', 'a4', 'a4', 'r']], [['e2', 'e3', 'e2', 'e3', 'e2', 'e3', 'e2', 'e3'], ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'a2', 'a3'], ['g#2', 'g#3', 'g#2', 'g#3', 'e2', 'e3', 'e2', 'e3'], ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'b1', 'c2'], ['d2', 'd3', 'd2', 'd3', 'd2', 'd3', 'd2', 'd3'], ['c2', 'c3', 'c2', 'c3', 'c2', 'c3', 'c2', 'c3'], ['b1', 'b2', 'b1', 'b2', 'e2', 'e3', 'e2', 'e3'], ['a1', 'a2', 'a1', 'a2', 'a1', 'a2', 'a1', 'a2']]]\n    }, [inherit('instrument')]),\n    mdxType: \"Player\"\n  }), mdx(\"p\", null, \"The instrument can be used like any other \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://felixroos.github.io/blog/rhythmical-playback/#using-multiple-instruments\"\n  }), \"instrument\"), \":\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"<Player\\n  fold={true}\\n  hierarchy={false}\\n  instruments={{ piano: midi('IAC-Treiber Bus 1', 1) }}\\n  events={renderRhythm(\\n    {\\n      duration: 14,\\n      instrument: 'piano',\\n      parallel: [\\n        [\\n          ['e5', ['b4', 'c5'], 'd5', ['c5', 'b4']],\\n          ['a4', ['a4', 'c5'], 'e5', ['d5', 'c5']],\\n          ['b4', ['r', 'c5'], 'd5', 'e5'],\\n          ['c5', 'a4', 'a4', 'r'],\\n          [['r', 'd5'], ['r', 'f5'], 'a5', ['g5', 'f5']],\\n          ['e5', ['r', 'c5'], 'e5', ['d5', 'c5']],\\n          ['b4', ['b4', 'c5'], 'd5', 'e5'],\\n          ['c5', 'a4', 'a4', 'r'],\\n        ],\\n        [\\n          ['e2', 'e3', 'e2', 'e3', 'e2', 'e3', 'e2', 'e3'],\\n          ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'a2', 'a3'],\\n          ['g#2', 'g#3', 'g#2', 'g#3', 'e2', 'e3', 'e2', 'e3'],\\n          ['a2', 'a3', 'a2', 'a3', 'a2', 'a3', 'b1', 'c2'],\\n          ['d2', 'd3', 'd2', 'd3', 'd2', 'd3', 'd2', 'd3'],\\n          ['c2', 'c3', 'c2', 'c3', 'c2', 'c3', 'c2', 'c3'],\\n          ['b1', 'b2', 'b1', 'b2', 'e2', 'e3', 'e2', 'e3'],\\n          ['a1', 'a2', 'a1', 'a2', 'a1', 'a2', 'a1', 'a2'],\\n        ],\\n      ],\\n    },\\n    [inherit('instrument')]\\n  )}\\n/>\\n\")), mdx(\"p\", null, \"This is the source code for the instrument:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import WebMidi, { Output } from 'webmidi';\\nimport * as Tone from 'tone';\\nimport enableWebMidi from '../../midi/enableWebMidi';\\n\\nexport function midi(outputName, channel) {\\n  return () => new Promise((resolve, reject) => {\\n    enableWebMidi().then(() => {\\n      if (WebMidi.outputs.length === 0) {\\n        throw new Error('No output found...');\\n      }\\n      const output = WebMidi.getOutputByName(outputName) as Output;\\n      const s = {\\n        triggerAttackRelease: (note, duration, time?, velocity?) => {\\n          // https://github.com/Tonejs/Tone.js/issues/805#issuecomment-748172477\\n          const timingOffset = WebMidi.time - Tone.context.currentTime * 1000\\n          time = time * 1000 + timingOffset;\\n          output?.playNote(note, channel, { time, duration: duration * 1000 - 5, velocity: 0.5 });\\n        },\\n        connect: (dest) => { return s },\\n        toMaster: () => { return s },\\n      }\\n      // onload(instrument)\\n      resolve(s);\\n    }).catch(() => {\\n      throw new Error('Web Midi could not be enabled...');\\n    });\\n  })\\n}\\n\")), mdx(\"p\", null, \"You might wonder what enableWebMidi is doing there, and why not use WebMidi.enable?\\nThis is a workaround to be able to use WebMidi multiple times on one page. It seems that WebMidi.enable will only work once.. The enableWebMidi function looks like that:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-js\"\n  }), \"import WebMidi from 'webmidi';\\n\\nexport default function enableWebMidi() {\\n  return new Promise((resolve, reject) => {\\n    if (WebMidi.enabled) {\\n      // if already enabled, just resolve WebMidi\\n      resolve(WebMidi);\\n      return;\\n    }\\n    WebMidi.enable((err) => {\\n      if (err) {\\n        reject(err);\\n      }\\n      resolve(WebMidi);\\n    });\\n  });\\n}\\n\")), mdx(\"h2\", {\n    \"id\": \"more\"\n  }, \"More\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/Tonejs/Midi\"\n  }), \"https://github.com/Tonejs/Midi\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/djipco/webmidi#nodejs-support\"\n  }), \"https://github.com/djipco/webmidi#nodejs-support\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://github.com/Tonejs/Tone.js/issues/805#issuecomment-748172477\"\n  }), \"accurate midi scheduling with tone.js\"))));\n}\n;\nMDXContent.isMDXComponent = true;","slug":"/webmidi/","title":"Using MIDI with JavaScript","tags":[],"keywords":[],"date":"December 30, 2020","image":null,"imageAlt":null,"socialImage":null},"previous":{"__typename":"MdxBlogPost","id":"c5dc26e8-7436-5b02-a016-b4030ee1d635","excerpt":"I made a few experiments on Audio Recording, using the Web Audio API. First, I created a simple project: ... added some html: ... and a…","slug":"/web-audio-recorder/","title":"Recording Audio on the Web","date":"October 27, 2020"},"next":null},"pageContext":{"id":"ac2b32d3-ca18-596f-89a7-db1f04563617","previousId":"c5dc26e8-7436-5b02-a016-b4030ee1d635"}},"staticQueryHashes":["386998304","4198970465","764694655"]}